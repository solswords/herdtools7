\chapter{Static Evaluation\label{chap:StaticEvaluation}}

In this chapter, we define how to statically evaluate an expression
to yield a literal value.

\hypertarget{def-staticeval}{}
\TypingRuleDef{StaticEval}
The function
\[
  \staticeval(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \;\aslto\;
  \overname{\literal}{\vv} \cup
  \overname{\TTypeError}{\TypeErrorConfig}
\]
evaluates an expression $\ve$
in the static environment $\tenv$, returning a literal $\vv$.
If the evaluation terminates by a thrown exception of a value that is not a literal
(for example, a record value), the result is a type error.

\hypertarget{def-staticallyevaluable}{}
We say that an expression $\ve$ is \staticallyevaluable{} in a given static environment $\tenv$ if
applying $\staticeval(\tenv, \ve) \typearrow \vv$ and $\vv$ is a literal value.

Static evaluation employs the dynamic semantics to evaluate $\ve$ and inspects the result to extract
a literal. The evaluation should be able to access global constants as well as local constants that
are bound in $\tenv$. Therefore, a dynamic environment is constructed from the constants defined in $\tenv$
(see \TypingRuleRef{StaticEnvToEnv}).

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\staticenvtoenv$ to $\tenv$ yields $\env$;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{normal\_literal}
    \begin{itemize}
      \item evaluating $\ve$ in $\env$ yields $\Normal(\nvliteral{\vv}, \Ignore)$.
    \end{itemize}

    \item \AllApplyCase{normal\_non\_literal}
    \begin{itemize}
      \item evaluating $\ve$ in $\env$ yields $\Normal(\vx, \Ignore)$
            where $\vx$ is not a native value for a literal;
      \item the result is a type error indicating that $\ve$ cannot be statically evaluated to a literal.
    \end{itemize}

    \item \AllApplyCase{abnormal}
    \begin{itemize}
      \item evaluating $\ve$ in $\env$ yields an abnormal configuration;
      \item the result is a type error indicating that $\ve$ cannot be statically evaluated to a literal.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[normal\_literal]{
  \staticenvtoenv(\tenv) \typearrow \env\\
  \evalexpr{\env, \ve} \evalarrow \Normal(\nvliteral{\vv}, \Ignore)
}{
  \staticeval(\tenv, \ve) \typearrow \vv
}
\end{mathpar}

\begin{mathpar}
\inferrule[normal\_non\_literal]{
  \staticenvtoenv(\tenv) \typearrow \env\\
  \evalexpr{\env, \ve} \evalarrow \Normal(\vx, \Ignore)\\
  \vx \neq \nvliteral{\Ignore}
}{
  \staticeval(\tenv, \ve) \typearrow \TypeErrorVal{\StaticEvaluationFailure}
}
\end{mathpar}

\begin{mathpar}
\inferrule[abnormal]{
  \staticenvtoenv(\tenv) \typearrow \env\\
  \evalexpr{\env, \ve} \evalarrow C\\
  \configdomain{C} \in \{\Throwing, \Error\}
}{
  \staticeval(\tenv, \ve) \typearrow \TypeErrorVal{\StaticEvaluationFailure}
}
\end{mathpar}
\CodeSubsection{\StaticEvalBegin}{\StaticEvalEnd}{../StaticInterpreter.ml}

\TypingRuleDef{StaticEnvToEnv}
\hypertarget{def-staticenvtoenv}{}
The function
\[
  \staticenvtoenv(\overname{\staticenvs}{\tenv}) \typearrow \overname{\envs}{\env}
\]
transforms the constants defined in the static environment $\tenv$ into an environment $\env$.

\ProseParagraph
\AllApply
\begin{itemize}
  \item define the global dynamic environment $\vglobal$ as the map that bind
        each $\id$ in the domain of $G^\tenv.\constantvalues$ to $\nvliteral{\vl}$
        if $G^\tenv.\constantvalues(\id) = \vl$;
  \item define the local dynamic environment $\vlocal$ as the map that bind
        each $\id$ in the domain of $L^\tenv.\constantvalues$ to $\nvliteral{\vl}$
        if $L^\tenv.\constantvalues(\id) = \vl$;
  \item define the environment $\env$ to have the static component $\tenv$ and the dynamic
        environment $(\vglobal, \vlocal)$;
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vglobal \eqdef [\id \mapsto \nvliteral{\vl} \;|\; G^\tenv.\constantvalues(\id) = \vl]\\
  \vlocal \eqdef [\id \mapsto \nvliteral{\vl} \;|\; L^\tenv.\constantvalues(\id) = \vl]
}{
  \staticenvtoenv(\tenv) \typearrow \overname{(\tenv, (\vglobal, \vlocal))}{\env}
}
\end{mathpar}
