\chapter{Subprogram Calls\label{chap:SubprogramCalls}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\Nexpr \derives\  & \Tidentifier \parsesep \PlistZero{\Nexpr} &\\
\Nstmt \derives \ & \Tidentifier \parsesep \PlistZero{\Nexpr} \parsesep \Tsemicolon &
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Syntax}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\expr \derives\ & \ECall(\call) &\\
\stmt \derives\ & \SCall(\call) &
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Typing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypertarget{def-annotatecall}{}
The function
\[
  \annotatecall(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\call}{\vcall}
   ) \aslto
  (\overname{\call}{\vcallp} \times
  \overname{\langle \ty \rangle}{\rettyopt} \times
  \overname{\TSideEffectSet}{\vses}
  )
\]
annotates the call $\vcall$ to a subprogram with call type $\calltype$, resulting in the following:
\begin{itemize}
  \item $\vcallp$ --- the updated call, with all arguments/parameters annotated and \\
        $\vcall.\callname$ updated to uniquely identify the call among the set of overloading subprograms declared with the same name;
  \item $\rettyopt$ --- the \optional\ annotated return type;
  \item $\vses$ --- the \sideeffectsetterm\ inferred for $\vcall$.
\end{itemize}
\ProseOtherwiseTypeError

The function is defined by the rule \TypingRuleRef{AnnotateCall}.

We also define helper functions via respective rules:
\begin{itemize}
  \item \TypingRuleRef{AnnotateCallActualsTyped}
  \item \TypingRuleRef{InsertStdlibParam}
  \item \TypingRuleRef{CheckParamsTypeSat}
  \item \TypingRuleRef{RenameTyEqs}
  \item \TypingRuleRef{SubstExprNormalize}
  \item \TypingRuleRef{SubstExpr}
  \item \TypingRuleRef{SubstConstraint}
  \item \TypingRuleRef{CheckArgsTypeSat}
  \item \TypingRuleRef{AnnotateRetTy}
  \item \TypingRuleRef{SubprogramForName}
  \item \TypingRuleRef{FilterCallCandidates}
  \item \TypingRuleRef{HasArgClash}
  \item \TypingRuleRef{ExpressionList}
\end{itemize}

\TypingRuleDef{AnnotateCall}
\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\annotateexprlist$ to annotate the expression list $\vcall.\callargs$ in $\tenv$ yields \\
        $\args$\ProseOrTypeError;
  \item applying $\annotateexprlist$ to annotate the expression list $\vcall.\callparams$ in $\tenv$ yields \\
        $\params$\ProseOrTypeError;
  \item applying $\annotatecallactualstyped$ to $\vcall.\callname$, $\params$, $\args$, and \\
        $\vcall.\callcalltype$ in $\tenv$ yields $(\vcallp, \retty, \vses)$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexprlist(\tenv, \vcall.\callargs) \typearrow \args \OrTypeError\\\\
  \annotateexprlist(\tenv, \vcall.\callparams) \typearrow \params \OrTypeError\\\\
  {
    \begin{array}{r}
  \annotatecallactualstyped(\tenv, \vcall.\callname, \params, \args, \vcall.\callcalltype) \typearrow \\
   (\vcallp, \retty, \vses) \OrTypeError
    \end{array}
  }
}{
  \annotatecall(\tenv, \vcall) \typearrow
  (\vcallp, \retty)
}
\end{mathpar}
\CodeSubsection{\AnnotateCallBegin}{\AnnotateCallEnd}{../Typing.ml}
\identi{VFDP} \identd{TRFW} \identr{KMDB}
\identi{YMHX} \identr{CCVD} \identr{QYBH} \identr{PFWQ} \identr{ZLWD}
\identi{FLKF} \identd{PMBL} \identr{MWBN} \identr{TZSP} \identr{SBWR}
\identi{CMLP} \identr{BQJG} \identr{RTCF}

\TypingRuleDef{AnnotateCallActualsTyped}
\hypertarget{def-annotatecallactualstyped}{}
The function
\[
  \begin{array}{r}
  \annotatecallactualstyped(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{(\ty \times\expr \times \TSideEffectSet)^*}{\params} \aslsep
    \overname{(\ty \times\expr)^*}{\typedargs} \aslsep
    \overname{\subprogramtype}{\calltype}
  ) \\ \aslto
  (\overname{\call}{\vcall} \aslsep
  \overname{\langle \ty \rangle}{\rettyopt})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
is similar to $\annotatecall$, except that it accepts annotated version of parameter/argument expressions as inputs (that is, pairs consisting of a type and an expression).
\ProseOtherwiseTypeError


\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\unziplistthree$ to $\typedargs$ yields the corresponding list of types $\argtypes$,
        list of expressions $\args$, and a list of \sideeffectdescriptorsetsterm\ $\vsessargs$;
  \item \Prosenonconflictingunion{$\vsessargs$}{$\vsesargs$};
  \item applying $\subprogramforname$ to match $\name$ and $\argtypes$ in $\tenv$
        yields \\ $(\namep, \funcsig, \vsescall)$\ProseOrTypeError;
  \item define $\vses$ as the union of $\vsesargs$ and $\vsescall$;
  \item either the $\subprogramtype$ of $\funcsig$ equals $\calltype$,
        or the $\subprogramtype$ of $\funcsig$ is $\STGetter$ and $\calltype$ is $\STFunction$\ProseTerminateAs{\BadCall};
  \item applying $\insertstdlibparam$ to $\funcsig$, $\params$, and $\argtypes$ yields new parameters $\paramsone$;
  \item checking that the lengths of $\funcsig.\funcparameters$ and $\paramsone$ are the same yields $\True$\ProseTerminateAs{\BadCall};
  \item checking that the lengths of $\funcsig.\funcargs$ and $\args$ are the same yields $\True$\ProseTerminateAs{\BadCall};
  \item applying $\checkparamstypesat$ to $\paramsone$
        to check that the actual parameters have correct types with respect to $\funcsig.\funcparameters$
        in $\tenv$ yields $\True$\ProseOrTypeError;
  \item define $\eqs$ as the association of declared parameter names in $\funcsig.\funcparameters$ with actual parameters $\paramsone$;
  \item applying $\checkargstypesat$ to $\argtypes$ and $\eqs$
        to check that the actual arguments have correct types with respect to $\funcsig.\funcargs$
        in $\tenv$ yields $\True$\ProseOrTypeError;
  \item applying $\annotateretty$ to $\eqs$, $\calltype$, and $\funcsig.\funcreturntype$
        to check that the two call types match and to substitute actual parameter arguments in the formal return type
        yields $\rettyopt$ \ProseOrTypeError;
  \item define $\vcall$ as the call with name $\namep$, parameters taken from $\paramsone$, arguments $\vargs$,
        and call type $\funcsig.\funcsubprogramtype$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \unziplistthree(\typedargs) = (\argtypes, \args, \vsessargs)\\
  \nonconflictingunion(\vsessargs) \typearrow \vsesargs \OrTypeError\\\\
  \subprogramforname(\tenv, \name, \argtypes) \typearrow
  (\nameone, \funcsig, \vsescall) \OrTypeError \\
  {
    \vb \eqdef
    \left(
    \begin{array}{l}
      \funcsig.\funcsubprogramtype = \calltype \; \lor \\
      (\funcsig.\funcsubprogramtype = \STGetter \; \land \\ \quad \calltype = \STFunction)
    \end{array}
    \right)
  }\\\\
  \vses \eqdef \vsesargs \cup \vsescall\\
  \checktrans{\vb}{\BadCall} \checktransarrow \True \OrTypeError \\
  \insertstdlibparam(\funcsig, \params, \argtypes) \typearrow \paramsone\\\\
  \equallength(\funcsig.\funcparameters, \paramsone) \typearrow \paramaritymatch \\\\
  \checktrans{\paramaritymatch}{\BadCall} \checktransarrow \True \OrTypeError\\\\
  \equallength(\funcsig.\funcargs, \args) \typearrow \aritymatch\\
  \checktrans{\aritymatch}{\BadCall} \checktransarrow \True \OrTypeError\\\\
  \checkparamstypesat(\tenv, \funcsig.\funcparameters, \paramsone) \typearrow \True \OrTypeError\\\\
  \eqs \eqdef [(\vx_i, \Ignore) \in \funcsig.\funcargs_i ,\; (\Ignore, \vv_i, \Ignore) \in \paramsone: (\vx_i, \vv_i) ] \\
  \checkargstypesat(\tenv, \funcsig.\funcargs, \argtypes, \eqs) \typearrow \True \OrTypeError\\\\
  \annotateretty(\tenv, \calltype, \funcsig.\funcreturntype, \eqs) \typearrow \rettyopt \OrTypeError
}{
  {
    \begin{array}{r}
  \annotatecallactualstyped(\tenv, \name, \params, \typedargs, \calltype) \typearrow \\
  \left(\overname{\left\{
      \begin{array}{rcl}
        \callname &:& \namep,\\
        \callparams &:& [(\Ignore, \vv_i, \Ignore) \in \paramsone: \vv_i],\\
        \callargs &:& \args,\\
        \callcalltype &:& \funcsig.\funcsubprogramtype
      \end{array}
  \right\}}{\vcall}
  , \rettyopt, \vses\right)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\AnnotateCallActualsTypedBegin}{\AnnotateCallActualsTypedEnd}{../Typing.ml}

\TypingRuleDef{InsertStdlibParam}
\hypertarget{def-insertstdlibparam}{}
The function
\[
\insertstdlibparam(
  \overname{\func}{\funcsig} \aslsep
  \overname{(\ty\times\expr)^*}{\params} \aslsep
  \overname{\ty^*}{\argtypes}
  ) \aslto \\
  \overname{(\ty\times\expr\times\TSideEffectSet)^*}{\paramsone}
\]
inserts the (optionally) omitted input parameter of a standard library function call.

Note that this function relies on all standard library functions with input parameters having one of two simple forms:
\begin{lstlisting}
  func stdlibA{N}  (arg1: bits(N), ...) => ...
  func stdlibB{M,N}(arg1: bits(N), ...) => bits(...M...)
\end{lstlisting}


\ProseParagraph
\AllApply
\begin{itemize}
  \item $\funcsig.\funcparameters$ is either
    a list with one parameter with a name $\vx$,
    or a list with two parameters, the second of which has a name $\vx$\ProseTerminateAs{\params};
  \item $\funcsig.\funcargs$ has a \head{} formal argument whose type is $\TBits(\EVar(\vx))$\ProseTerminateAs{\params};
  \item $\argtypes$ has a \head{} actual argument type of $\TBits(\ve)$\ProseTerminateAs{\params};
  \item $\funcsig.\funcbuiltin$ is $\True$\ProseTerminateAs{\params};
  \item the length of $\params$ is less than the length of $\funcsig.\funcparameters$\ProseTerminateAs{\params};
  \item $\paramsone$ is the \constrainedinteger{} for $\ve$ with an empty set of \sideeffectdescriptorsterm,
        appended to $\params$\ProseTerminateAs{\params}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \funcsig.\funcparameters \eqname [(\vx, \Ignore)] \;\lor\;
  \funcsig.\funcparameters \eqname [\Ignore, (\vx, \Ignore)] \; \terminateas \params \\\\
  \funcsig.\funcargs \eqname [(\Ignore, \TBits(\EVar(\vx)))] \concat \Ignore \; \terminateas \params \\\\
  \argtypes \eqname [\TBits(\ve)] \concat \Ignore \; \terminateas \params \\\\
  \funcsig.\funcbuiltin = \True \; \terminateas \params \\\\
  \listlen{\params} < \listlen{\funcsig.\funcparameters} \; \terminateas \params \\\\
  \paramsone \eqdef \params \concat [(\TInt(\wellconstrained(\AbbrevConstraintExact{\ve})), \ve, \emptyset)] \; \terminateas \params
}{
  \insertstdlibparam(\funcsig, \params, \argtypes) \aslto \paramsone
}
\end{mathpar}

\TypingRuleDef{CheckParamsTypeSat}
\hypertarget{def-checkparamstypesat}{}
The function
\[
\begin{array}{r}
\checkparamstypesat(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier\times\langle\ty\rangle)^*}{\funcsigparams} \aslsep
  \overname{(\ty\times\expr\times\TSideEffectSet)^*}{\params}
  ) \aslto \\
  \{\True\}\ \cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
checks that annotated parameters $\params$ are correct with respect to the declared parameters $\funcsigparams$.
\ProseOtherwiseTypeError\
It assumes that $\funcsigparams$ and $\params$ have the same length.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\funcsigparams$ is an empty list;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApply
  \begin{itemize}
    \item $\funcsigparams$ is a non-empty list with \head\ $(\vx, \tydeclopt)$ and \\
          \tail\ $\funcsigparamsone$, and
          $\params$ is a non-empty list with \head\ \\
          $(\tyactual, \eactual, \vsesactual)$ and \tail\ $\paramsone$;
    \item \Prosechecksymbolicallyevaluable{$\vsesactual$};
    \item checking that $\tyactual$ represents a \constrainedinteger{} yields $\True$\ProseOrTypeError;
    \item \OneApplies
    \begin{itemize}
      \item \AllApplyCase{parameterized}
      \begin{itemize}
        \item $\tyactual$ is a \parameterizedintegertype{} for the parameter $\vx$, that is, \\
              $\langle\TInt(\parameterized(\vx))\rangle$.
      \end{itemize}

      \item \AllApplyCase{other}
      \begin{itemize}
        \item $\tydeclopt$ is not $\None$, that is, $\langle\tydecl\rangle$;
        \item $\tydecl$ is not the \parameterizedintegertype{} for the parameter $\vx$;
        \item checking that $\tyactual$ \typesatisfies{} $\tydecl$ in $\tenv$ yields
              $\True$\ProseOrTypeError;
      \end{itemize}
    \end{itemize}
    \item applying $\checkparamstypesat$ to $\funcsigparamsone$ and $\paramsone$ in $\tenv$
          yields \\ $\True$\ProseOrTypeError.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{
}{
  \checkparamstypesat(\tenv, \overname{\emptylist}{\funcsigparams}, \Ignore) \typearrow \True
}
\and
\inferrule[parameterized]{
  \funcsigparams \eqname [(\vx, \tydeclopt)] \concat \funcsigparamsone\\
  \params \eqname [(\tyactual, \eactual, \vsesactual)] \concat \paramsone\\
  \checksymbolicallyevaluable(\vsesactual) \typearrow \True\OrTypeError\\\\
  \checkconstrainedinteger(\tenv, \tyactual) \typearrow \True\OrTypeError\\\\
  \commonprefixline\\\\
  \tydeclopt = \langle\TInt(\parameterized(\vx))\rangle\\\\
  \checkparamstypesat(\tenv, \funcsigparamsone, \paramsone) \typearrow \True \OrTypeError
}{
  \checkparamstypesat(\tenv, \funcsigparams, \params) \typearrow \True
}
\and
\inferrule[other]{
  \funcsigparams \eqname [(\vx, \tydeclopt)] \concat \funcsigparamsone\\
  \params \eqname [(\tyactual, \eactual, \vsesactual)] \concat \paramsone\\
  \checksymbolicallyevaluable(\vsesactual) \typearrow \True\OrTypeError\\\\
  \checkconstrainedinteger(\tenv, \tyactual) \typearrow \True\OrTypeError\\\\
  \commonprefixline\\\\
  \tydeclopt \eqname \langle\tydecl\rangle\\
  \tydecl \neq \TInt(\parameterized(\vx))\\
  \checktypesat(\tenv, \tyactual, \tydecl) \typearrow \True \OrTypeError\\\\
  \checkparamstypesat(\tenv, \funcsigparamsone, \paramsone) \typearrow \True \OrTypeError
}{
  \checkparamstypesat(\tenv, \funcsigparams, \params) \typearrow \True
}
\end{mathpar}

\TypingRuleDef{RenameTyEqs}
\hypertarget{def-renametyeqs}{}
The function
\[
\renametyeqs(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier\times\expr)^*}{\eqs} \aslsep
  \overname{\ty}{\tty}
) \aslto
\overname{\ty}{\newty} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
transforms the type $\tty$ in the static environment $\tenv$,
by substituting parameter names with their corresponding expressions in
$\eqs$, yielding the type $\newty$.
\ProseOtherwiseTypeError

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{t\_bits}
  \begin{itemize}
    \item $\tty$ is a bitvector type with width expression $\ve$ and fields $\fields$, that is, $\TBits(\ve, \fields)$;
    \item applying $\substexprnormalize$ to $\eqs$ and $\ve$ in $\tenv$ yields the expression $\newe$;
    \item define $\newty$ as a bitvector type with expression $\newe$ and fields $\fields$.
  \end{itemize}

  \item \AllApplyCase{t\_int\_wellconstrained}
  \begin{itemize}
    \item $\tty$ is a well-constrained integer type with constraints $\constraints$;
    \item applying $\substconstraint$ to each constraint $\constraints[\vi]$, for $\vi$ in \\
          $\listrange(\constraints)$, yields the constraint $\newc_\vi$;
    \item define $\newconstraints$ as the list of constraints $\newc_\vi$, for $\vi$ in \\
          $\listrange(\constraints)$;
    \item define $\newty$ as the well-constrained integer type with constraints \\
          $\newconstraints$.
  \end{itemize}

  \item \AllApplyCase{t\_int\_parameterized}
  \begin{itemize}
    \item $\tty$ is a \parameterizedintegertype\ for the parameter $\name$;
    \item applying $\substexprnormalize$ to $\eqs$ and the expression $\EVar(\name)$ yields $\ve$;
    \item define $\newty$ as the well-constrained integer type with the single constraint for $\ve$, that is,
          $\TInt(\wellconstrained(\ConstraintExact(\ve)))$.
  \end{itemize}

  \item \AllApplyCase{t\_tuple}
  \begin{itemize}
    \item $\tty$ is the \tupletypeterm{} over the list of tuples $\tys$, that is, $\TTuple(\tys)$;
    \item applying $\renametyeqs$ to $\eqs$ and the type $\tys[\vi]$, for each $\vi$ in \\
          $\listrange(\tys)$, yields the type $\newty_\vi$;
    \item define $\newtys$ as the list of types $\newty_\vi$, for each $\vi$ in $\listrange(\tys)$;
    \item define $\newty$ as the \tupletypeterm{} over $\newtys$, that is, $\TTuple(\newtys)$.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\tty$ is not one of the types in the previous cases,
          that is, $\tty$ is not a bitvector type, nor an integer type, nor a \tupletypeterm{};
    \item $\newty$ is $\tty$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[t\_bits]{
  \substexprnormalize(\tenv, \eqs, \ve) \typearrow \newe
}{
  \renametyeqs(\tenv, \eqs, \overname{\TBits(\ve, \fields)}{\tty}) \typearrow \overname{\TBits(\newe, \fields)}{\newty}
}
\and
\inferrule[t\_int\_wellconstrained]{
  \vi\in\listrange(\constraints): \substconstraint(\tenv, \constraints[\vi]) \typearrow \newc_\vi\\
  \newconstraints \eqdef [\vi\in\listrange(\constraints): \newc_\vi]\\
  \newty \eqdef \TInt(\wellconstrained(\newconstraints))
}{
  \renametyeqs(\tenv, \eqs, \overname{\TInt(\wellconstrained(\constraints))}{\tty}) \typearrow
  \newty
}
\and
\inferrule[t\_int\_parameterized]{
  \substexprnormalize(\eqs, \EVar(\name)) \typearrow \ve\\
  \newty \eqdef \TInt(\wellconstrained(\ConstraintExact(\ve)))
}{
  \renametyeqs(\tenv, \eqs, \overname{\TInt(\parameterized(\name))}{\tty}) \typearrow \newty
}
\and
\inferrule[t\_tuple]{
  \vi\in\listrange(\tys): \renametyeqs(\eqs, \tys[\vi]) \typearrow \newty_\vi\\
  \newtys \eqdef [\vi\in\listrange(\tys): \newty_\vi]
}{
  \renametyeqs(\tenv, \eqs, \overname{\TTuple(\tys)}{\tty}) \typearrow
  \overname{\TTuple(\newtys)}{\newty}
}
\and
\inferrule[other]{
  \astlabel(\tty) \not\in \{\TBits, \TInt, \TTuple\}
}{
  \renametyeqs(\tenv, \eqs, \tty) \typearrow \overname{\tty}{\newty}
}
\end{mathpar}

\TypingRuleDef{SubstExprNormalize}
\hypertarget{def-substexprnormalize}{}
The function
\[
\substexprnormalize(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier\times\expr)^*}{\eqs} \aslsep
  \overname{\expr}{\ve}
) \aslto \overname{\newe}{\expr}
\]
transforms the expression $\ve$ in the static environment $\tenv$,
by substituting parameter names with their corresponding expressions in
$\eqs$, and then attempting to symbolically simplify the result, yielding the expression $\newe$.
\ProseOtherwiseTypeError

\ProseParagraph
\AllApply
\begin{itemize}
  \item transforming $\ve$ in the static environment $\tenv$, by substituting the parameter expressions
        $\eqs$, yields $\veone$;
  \item symbolically simplifying $\veone$ in $\tenv$ yields $\newe$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \substexpr(\tenv, \ve) \typearrow \veone\\
  \normalize(\tenv, \veone) \typearrow \newe
}{
  \substexprnormalize(\tenv, \eqs, \ve) \typearrow \newe
}
\end{mathpar}

\TypingRuleDef{SubstExpr}
\hypertarget{def-substexpr}{}
The function
\[
\substexpr(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier\times\expr)^*}{\substs} \aslsep
  \overname{\expr}{\ve}
) \aslto \overname{\expr}{\newe}
\]
transforms the expression $\ve$ in the static environment $\tenv$,
by substituting parameter names with their corresponding expressions in
$\substs$, yielding the expression $\newe$.
\ProseOtherwiseTypeError

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{e\_var\_in\_substs}
  \begin{itemize}
    \item $\ve$ is a variable expression for the identifier $\vs$, that is, $\EVar(\vs)$;
    \item applying $\assocopt$ to $\vs$ and $\substs$ yields the expression $\newe$.
          That is, $\vs$ is a parameter with an associated expression;
  \end{itemize}

  \item \AllApplyCase{e\_var\_not\_in\_substs}
  \begin{itemize}
    \item $\ve$ is the variable expression for the identifier $\vs$, that is, $\EVar(\vs)$;
    \item applying $\assocopt$ to $\vs$ and $\substs$ yields $\None$.
          That is, $\vs$ is not a parameter with an associated expression;
    \item define $\newe$ is $\ve$.
  \end{itemize}

  \item \AllApplyCase{e\_unop}
  \begin{itemize}
    \item $\ve$ is the unary operator expression for the operator $\op$ and expression $\ve$, that is, $\EUnop(\op, \veone)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the unary operator expression for the operator $\op$ and expression $\veonep$, that is, $\EUnop(\op, \veonep)$.
  \end{itemize}

  \item \AllApplyCase{e\_binop}
  \begin{itemize}
    \item $\ve$ is the binary operator expression for the operator $\op$ and expressions $\veone$ and $\vetwo$, that is, $\EBinop(\op, \veone, \vetwo)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item applying $\substexpr$ to $\substs$ and $\vetwo$ in $\tenv$ yields $\vetwop$;
    \item define $\newe$ as the unary operator expression for the operator $\op$ and expression $\veonep$, that is, $\EUnop(\op, \veonep)$.
  \end{itemize}

  \item \AllApplyCase{e\_cond}
  \begin{itemize}
    \item $\ve$ is the conditional expression for expressions $\veone$, $\vetwo$, and $\vethree$, that is, \\
          $\ECond(\veone, \vetwo, \vethree)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item applying $\substexpr$ to $\substs$ and $\vetwo$ in $\tenv$ yields $\vetwop$;
    \item applying $\substexpr$ to $\substs$ and $\vethree$ in $\tenv$ yields $\vethreep$;
    \item define $\newe$ as the conditional expression for expressions $\veonep$, $\vetwop$, and $\vethreep$, that is, $\ECond(\veonep, \vetwop, \vethreep)$.
  \end{itemize}

  \item \AllApplyCase{e\_call}
  \begin{itemize}
    \item $\ve$ is the call expression for subprogram $\vx$ with arguments $\vargs$ and parameter expressions $\paramargs$,
          that is, $\ECall(\vx, \vargs, \paramargs)$;
    \item applying $\substexpr$ to $\substs$ and every argument expression $\vargs[\vi]$, for $\vi$ in
          $\listrange(\vargs)$ yields $\ve_\vi$;
    \item define $\vargsp$ as $\ve_\vi$ for each $\vi$ in $\listrange(\vargs)$;
    \item define $\newe$ as the call expression for subprogram $\vx$ with arguments $\vargsp$ and parameter expressions $\paramargs$,
    that is, $\ECall(\vx, \vargsp, \paramargs)$.
  \end{itemize}

  \item \AllApplyCase{e\_getarray}
  \begin{itemize}
    \item $\ve$ is the \arrayaccess\ expression for base expression $\veone$ and index expression $\vetwo$,
          that is, $\EGetArray(\veone, \vetwo)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item applying $\substexpr$ to $\substs$ and $\vetwo$ in $\tenv$ yields $\vetwop$;
    \item define $\newe$ as the \arrayaccess\ expression for base expression $\veonep$ and index expression $\vetwop$,
    that is, $\EGetArray(\veonep, \vetwop)$.
  \end{itemize}

  \item \AllApplyCase{e\_getenumarray}
  \begin{itemize}
    \item $\ve$ is the \arrayaccess\ expression for base expression $\veone$ and an enumeration-typed index expression $\vetwo$,
          that is, $\EGetEnumArray(\veone, \vetwo)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item applying $\substexpr$ to $\substs$ and $\vetwo$ in $\tenv$ yields $\vetwop$;
    \item define $\newe$ as the \arrayaccess\ expression for base expression $\veonep$ and \\
          enumeration-typed index expression $\vetwop$,
          that is, $\EGetEnumArray(\veonep, \vetwop)$.
  \end{itemize}

  \item \AllApplyCase{e\_getfield}
  \begin{itemize}
    \item $\ve$ is the field access expression for base expression $\ve$ and field $\vx$,
          that is, $\EGetField(\veone, \vx)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the field access expression for base expression $\ve$ and field $\vx$,
          that is, $\EGetField(\veonep, \vx)$.
  \end{itemize}

  \item \AllApplyCase{e\_getfields}
  \begin{itemize}
    \item $\ve$ is the access to fields $\fields$ with base expression $\veone$, that is, \\
          $\EGetFields(\veone, \fields)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the access to fields $\fields$ with base expression $\veonep$, that is, $\EGetFields(\veonep, \fields)$.
  \end{itemize}

  \item \AllApplyCase{e\_getitem}
  \begin{itemize}
    \item $\ve$ is the access to tuple item $\vi$ of the tuple expression $\veone$, that is, \\
          $\EGetItem(\veone, \vi)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the access to tuple item $\vi$ of the tuple expression $\veonep$, that is, \\
          $\EGetItem(\veonep, \vi)$.
  \end{itemize}

  \item \AllApplyCase{e\_pattern}
  \begin{itemize}
    \item $\ve$ is the pattern expression of expression $\veone$ and patterns $\vps$, that is, \\
          $\EPattern(\veone, \vps)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the pattern expression of expression $\veonep$ and patterns $\vps$, that is, $\EPattern(\veonep, \vps)$.
  \end{itemize}

  \item \AllApplyCase{e\_record}
  \begin{itemize}
    \item $\ve$ is the record expression of record type $\vt$ and list of fields $\fields$;
    \item for every pair $(\vx,\veone)$ in $\fields$, applying $\substexpr$ to $\substs$ $\veone$ in $\tenv$ yields $\veonep_\vx$;
    \item define $\fieldsp$ as the list of pairs $(\vx,\veonep_\vx)$ for every pair $(\vx,\veone)$ in $\fields$;
    \item define $\newe$ as the record expression of record type $\vt$ and list of fields $\fieldsp$.
  \end{itemize}

  \item \AllApplyCase{e\_slice}
  \begin{itemize}
    \item $\ve$ is the slicing expression for subexpression $\veone$ and list of slices $\vslices$, that is, $\ESlice(\veone, \vslices)$;
    \item applying $\substexpr$ to $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as slicing expression for subexpression $\veonep$ and list of slices $\vslices$, that is, $\ESlice(\veonep, \vslices)$.
  \end{itemize}

  \item \AllApplyCase{e\_tuple}
  \begin{itemize}
    \item $\ve$ is the tuple expression of expressions $\ves$, that is, $\ETuple(\ves)$;
    \item applying $\substexpr$ to $\substs$ and every expression $\ves[\vi]$ in $\tenv$, for every $\vi$ in $\listrange(\ves)$
          yields $\newe_\vi$;
    \item define $\vesp$ as the list of expressions $\newe_\vi$, for every $\vi$ in $\listrange(\ves)$;
    \item define $\newe$ as the tuple expression of expressions $\vesp$, that is, $\ETuple(\vesp)$.
  \end{itemize}

  \item \AllApplyCase{e\_array}
  \begin{itemize}
    \item $\ve$ is an array construction expression with length expression $\length$ and value expression $\vvalue$, that is,
          $\EArray\{\EArrayLength: \length, \EArrayValue: \vvalue\}$;
    \item applying $\substexpr$ to $\substs$ and $\length$ in $\tenv$ yields $\lengthp$;
    \item applying $\substexpr$ to $\substs$ and $\vvalue$ in $\tenv$ yields $\vvaluep$;
    \item define $\newe$ as the array construction expression with length expression \\
          $\lengthp$ and initial element value expression $\vvaluep$, that is, \\
          $\EArray\{\EArrayLength: \lengthp, \EArrayValue: \vvaluep\}$.
  \end{itemize}

  \item \AllApplyCase{e\_enumarray}
  \begin{itemize}
    \item $\ve$ is an array construction expression for an enumeration-typed index
          with list of labels $\vlabels$ and initial element value expression $\vvalue$, that is, \\
          $\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \vvalue\}$;
    \item applying $\substexpr$ to $\substs$ and $\vvalue$ in $\tenv$ yields $\vvaluep$;
    \item define $\newe$ as the array construction expression with list of labels $\vlabels$
          and value expression $\vvaluep$, that is,
          $\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \vvaluep\}$.
  \end{itemize}

  \item \AllApplyCase{e\_atc}
  \begin{itemize}
    \item $\ve$ is the type assertion of expression $\veone$ and type $\vt$, that is, $\EATC(\veone, \vt)$;
    \item applying $\substexpr$ to $\substs$ and $\veone$ in $\tenv$ yields $\veonep$;
    \item define $\newe$ as the type assertion of expression $\veonep$ and type $\vt$, that is, $\EATC(\veonep, \vt)$.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\ve$ is either a literal expression or an arbitrary value expression;
    \item define $\newe$ as $\ve$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[e\_var\_in\_substs]{
  \assocopt(\vs, \substs) \typearrow \langle\newe\rangle
}{
  \substexpr(\tenv, \substs, \overname{\EVar(\vs)}{\ve}) \typearrow \newe
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_var\_not\_in\_substs]{
  \assocopt(\vs, \substs) \typearrow \None
}{
  \substexpr(\tenv, \substs, \overname{\EVar(\vs)}{\ve}) \typearrow \overname{\ve}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\
}{
  \substexpr(\tenv, \substs, \overname{\EUnop(\op, \veone)}{\ve}) \typearrow \overname{\EUnop(\op, \veonep)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\\
  \substexpr(\tenv, \substs, \vetwop) \typearrow \vetwop
}{
  \substexpr(\tenv, \substs, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow \overname{\EBinop(\op, \veonep, \vetwop)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_cond]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\\
  \substexpr(\tenv, \substs, \vetwop) \typearrow \vetwop\\
  \substexpr(\tenv, \substs, \vethreep) \typearrow \vethreep\\
}{
  \substexpr(\tenv, \substs, \overname{\ECond(\veone, \vetwo, \vethree)}{\ve}) \typearrow \overname{\ECond(\veonep, \vetwop, \vethreep)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_call]{
  \vi\in\listrange(\vargs): \substexpr(\tenv, \substs, \vargs[\vi]) \typearrow \ve_\vi\\
  \vargsp \eqdef [\vi\in\listrange(\vargs): \ve_\vi]
}{
  {
    \begin{array}{r}
  \substexpr(\tenv, \substs, \overname{\ECall(\vx, \vargs, \paramargs)}{\ve}) \typearrow \\ \overname{\ECall(\vx, \vargsp, \paramargs)}{\newe}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getarray]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\\
  \substexpr(\tenv, \substs, \vetwop) \typearrow \vetwop
}{
  \substexpr(\tenv, \substs, \overname{\EGetArray(\veone, \vetwo)}{\ve}) \typearrow \overname{\EGetArray(\veonep, \vetwop)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getenumarray]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep\\
  \substexpr(\tenv, \substs, \vetwop) \typearrow \vetwop
}{
  \substexpr(\tenv, \substs, \overname{\EGetEnumArray(\veone, \vetwo)}{\ve}) \typearrow \overname{\EGetEnumArray(\veonep, \vetwop)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getfield]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EGetField(\veone, \vx)}{\ve}) \typearrow \overname{\EGetField(\veonep, \vx)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getfields]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EGetFields(\veone, \fields)}{\ve}) \typearrow \overname{\EGetFields(\veonep, \fields)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getitem]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EGetItem(\veone, \vi)}{\ve}) \typearrow \overname{\EGetItem(\veonep, \vi)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_pattern]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EPattern(\veone, \vps)}{\ve}) \typearrow \overname{\EPattern(\veonep, \vps)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_record]{
  (\vx, \veone)\in\fields: \substexpr(\tenv, \substs, \veone) \typearrow \veone_\vx\\
  \fieldsp \eqdef [(\vx, \veone)\in\fields: (\vx, \veone_\vx)]
}{
  \substexpr(\tenv, \substs, \overname{\ERecord(\vt, \fields)}{\ve}) \typearrow \overname{\ERecord(\vt, \fieldsp)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_slice]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\ESlice(\veone, \slices)}{\ve}) \typearrow \overname{\ESlice(\veonep, \slices)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_tuple]{
  \vi\in\listrange(\ves): \substexpr(\tenv, \substs, \ves[\vi]) \typearrow \newe_\vi\\
  \vesp \eqdef [\vi\in\listrange(\ves): \newe_\vi]
}{
  \substexpr(\tenv, \substs, \overname{\ETuple(\ves)}{\ve}) \typearrow \overname{\ETuple(\vesp)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_array]{
  \substexpr(\tenv, \substs, \length) \typearrow \lengthp\\
  \substexpr(\tenv, \substs, \vvalue) \typearrow \vvaluep
}{
  {
    \begin{array}{r}
  \substexpr(\tenv, \substs, \overname{\EArray\{\EArrayLength: \length, \EArrayValue: \vvalue\}}{\ve}) \typearrow\\
  \overname{\EArray\{\EArrayLength: \length, \EArrayValue: \vvaluep\}}{\newe}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_enumarray]{
  \substexpr(\tenv, \substs, \vvalue) \typearrow \vvaluep
}{
  {
    \begin{array}{r}
  \substexpr(\tenv, \substs, \overname{\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \vvalue\}}{\ve}) \typearrow\\
  \overname{\EEnumArray\{\EArrayLabels: \length, \EArrayValue: \vvaluep\}}{\newe}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_atc]{
  \substexpr(\tenv, \substs, \veone) \typearrow \veonep
}{
  \substexpr(\tenv, \substs, \overname{\EATC(\veone, \vt)}{\ve}) \typearrow \overname{\EATC(\veonep, \vt)}{\newe}
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\ve) \in \{\ELiteral, \EArbitrary\}\
}{
  \substexpr(\tenv, \substs, \ve) \typearrow \overname{\ve}{\newe}
}
\end{mathpar}

\CodeSubsection{\SubstExprBegin}{\SubstExprEnd}{../ASTUtils.ml}

\TypingRuleDef{SubstConstraint}
\hypertarget{def-substconstraint}{}
The function
\[
\substconstraint(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier\times\expr)^*}{\eqs} \aslsep
  \overname{\intconstraint}{\vc}
) \aslto \overname{\newc}{\intconstraint}
\]
transforms the integer constraint $\vc$ in the static environment $\tenv$,
by substituting parameter names with their corresponding expressions in
$\eqs$, and then attempting to symbolically simplify the result,
yielding the integer constraint $\newc$.
\ProseOtherwiseTypeError

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is an exact constraint for the expression $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\substexprnormalize$ in $\tenv$ to $\eqs$ and $\ve$ yields $\newe$;
    \item define $\newc$ as the exact constraint for the expression $\newe$, that is, \\
          $\ConstraintExact(\newe)$.
  \end{itemize}

  \item \AllApplyCase{range}
  \begin{itemize}
    \item $\vc$ is a range constraint for the expressions $\veone$ and $\vetwo$, that is, \\
          $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\substexprnormalize$ in $\tenv$ to $\eqs$ and $\veone$ yields $\veonep$;
    \item applying $\substexprnormalize$ in $\tenv$ to $\eqs$ and $\vetwo$ yields $\vetwop$;
    \item define $\newc$ as the range constraint for the expressions $\veonep$ and $\vetwop$, that is, $\ConstraintRange(\veonep, \vetwop)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \substexprnormalize(\tenv, \eqs, \ve) \typearrow \newe
}{
  \substconstraint(\tenv, \eqs, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \overname{\ConstraintExact(\newe)}{\newc}
}
\and
\inferrule[range]{
  \substexprnormalize(\tenv, \eqs, \veone) \typearrow \veonep\\
  \substexprnormalize(\tenv, \eqs, \vetwo) \typearrow \vetwop
}{
  \substconstraint(\tenv, \eqs, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \overname{\ConstraintRange(\veonep, \vetwop)}{\newc}
}
\end{mathpar}

\TypingRuleDef{CheckArgsTypeSat}
\hypertarget{def-checkargstypesat}{}
The function
\[
\begin{array}{r}
  \checkargstypesat(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{(\identifier\times\ty)^*}{\funcsigargs} \aslsep
    \overname{\ty^*}{\argtypes} \aslsep
    \overname{(\identifier\times\expr)^*}{\eqs}
  ) \aslto \\
  \{\True\}\ \cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
checks that the types $\argtypes$ \typesatisfy\ the types of the corresponding
formal arguments $\funcsigargs$ with the parameters substituted with their corresponding
arguments as per $\eqs$ and results in a type error otherwise.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item both $\funcsigargs$ and $\argtypes$ are empty;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item view $\funcsigargs$ as a list with \head\ $(\Ignore, \tydecl)$ and \tail\ $\funcsigargsone$;
    \item view $\argtypes$ as a list with \head\ $\tyactual$ and \tail\ \\
          $\argtypesone$;
    \item applying $\renametyeqs$ to $\eqs$ and $\tydecl$ in $\tenv$
          to substitute parameter arguments in $\tydecl$ yields $\tydeclp$\ProseOrTypeError;
    \item checking that $\tyactual$ \typesatisfies\ $\tydeclp$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item applying $\checkargstypesat$ to $\funcsigargsone$, $\argtypesone$, \\
          and $\eqs$ in $\tenv$
          yields $\True$\ProseOrTypeError;
    \item the result is $\True$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
We note that \TypingRuleRef{AnnotateCallActualsTyped} guarantees
that $\funcsigargs$ and $\argtypes$ have the same length.

\begin{mathpar}
\inferrule[empty]{}{
  \checkargstypesat(\tenv, \overname{\emptylist}{\funcsigargs}, \overname{\emptylist}{\argtypes}, \eqs)
  \typearrow \True
}
\and
\inferrule[non\_empty]{
  \funcsigargs \eqname [(\Ignore, \tydecl)] \concat \funcsigargsone\\
  \argtypes \eqname [\tyactual] \concat \argtypesone\\
  \renametyeqs(\tenv, \eqs, \tydecl) \typearrow \tydeclp\OrTypeError\\\\
  \checktypesat(\tenv, \tyactual, \tydeclp) \typearrow \True\OrTypeError\\\\
  \checkargstypesat(\tenv, \funcsigargsone, \argtypesone, \eqs) \typearrow \True\OrTypeError
}{
  \checkargstypesat(\tenv, \funcsigargs, \argtypes, \eqs) \typearrow \True
}
\end{mathpar}

\TypingRuleDef{AnnotateRetTy}
\hypertarget{def-annotateretty}{}
The function
\[
\begin{array}{r}
\annotateretty(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\subprogramtype}{\calltype} \aslsep
  \overname{\langle\ty\rangle}{\funcsigrettyopt}
  \overname{(\identifier\times\expr)^*}{\eqsthree}
) \aslto \\
\overname{\langle\ty\rangle}{\rettyopt}
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the \optional\ return type $\funcsigrettyopt$ given with the subprogram type
$\calltype$ with respect to the parameter expressions $\eqs$,
yielding the \optional\ annotated type $\rettyopt$.
\ProseOtherwiseTypeError

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{function\_or\_getter}
  \begin{itemize}
    \item $\calltype$ is one of $\STFunction$ or $\STGetter$;
    \item $\funcsig$ is $\langle\tty\rangle$;
    \item applying $\renametyeqs$ to $\eqs$ and $\tty$ yields $\ttyone$\ProseOrTypeError;
    \item $\rettyopt$ is $\langle\ttyone\rangle$.
  \end{itemize}

  \item \AllApplyCase{procedure\_or\_setter}
  \begin{itemize}
    \item $\calltype$ is one of $\STProcedure$ or $\STSetter$;
    \item $\funcsigrettyopt$ is $\None$;
    \item define $\rettyopt$ as $\None$.
  \end{itemize}

  \item \AllApplyCase{ret\_type\_mismatch}
  \begin{itemize}
    \item the condition that $\calltype$ is one of $\STProcedure$ or $\STSetter$
          if and only if $\funcsigrettyopt$ is $\None$ does not hold;
    \item the result is a type error indicating the mismatch.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[function\_or\_getter]{
  \calltype \in \{\STFunction, \STGetter\}\\
  \renametyeqs(\eqs, \tty) \typearrow \ttyone \OrTypeError
}{
  \annotateretty(\tenv, \calltype, \overname{\langle\tty\rangle}{\funcsigrettyopt}, \eqs) \typearrow
  \overname{\langle\ttyone\rangle}{\rettyopt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[procedure\_or\_setter]{
  \calltype \in \{\STProcedure, \STSetter\}\\
}{
  \annotateretty(\tenv, \calltype, \overname{\None}{\funcsigrettyopt}, \eqs) \typearrow
  \overname{\None}{\rettyopt}
}
\end{mathpar}

\begin{mathpar}
\inferrule[ret\_type\_mismatch]{
  {
  \neg\left(
    \begin{array}{c}\calltype \in \{\STProcedure, \STSetter\} \leftrightarrow \\
      \funcsigrettyopt=\None
    \end{array}
  \right)
  }
}{
  \annotateretty(\tenv, \calltype, \funcsigrettyopt, \eqs) \typearrow
  \TypeErrorVal{\BadCall}
}
\end{mathpar}

\TypingRuleDef{SubprogramForName}
\hypertarget{def-subprogramforname}{}
The function
\[
  \begin{array}{rl}
    \subprogramforname(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Strings}{\name} \aslsep
    \overname{\ty^*}{\callerargtypes}
  )
  \aslto &
  \begin{array}{l}
    (
    \overname{\Strings}{\namep} \aslsep
    \overname{\func}{\callee} \aslsep
    \overname{\TSideEffectSet}{\vses}
    )\
  \cup\\
   \overname{\TTypeError}{\TypeErrorConfig}
  \end{array}
  \end{array}
\]
looks up the static environment $\tenv$ for a subprogram associated with $\name$
and the list of argument types $\calleeargtypes$ and determines which one of the following
cases holds:
\begin{itemize}
  \item there is no declared subprogram that matches $\name$ and $\calleeargtypes$;
  \item there is exactly one subprogram that matches $\name$ and $\calleeargtypes$;
  \item there is more than one subprogram that matches $\name$ and $\calleeargtypes$;
\end{itemize}
The first and last cases result in a type error.
If the second case holds, the function returns a tuple which comprises:
\begin{itemize}
\item $\namep$ --- the string that uniquely identifies this subprogram;
\item $\callee$ --- the AST node defining the called subprogram; and
\item $\vses$ --- the set of \sideeffectdescriptorsterm{} associated with $\name$.
\end{itemize}
\ProseOtherwiseTypeError

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{undefined}
  \begin{itemize}
    \item $\tenv$ does not contain a binding for $\name$ in the $\overloadedsubprograms$ map
          ($G^\tenv.\overloadedsubprograms$);
    \item the result is a type error indicating that the identifier has not been declared (as a subprogram).
  \end{itemize}

  \item \AllApplyCase{no\_candidates}
  \begin{itemize}
    \item $\tenv$ binds $\name$ via $\overloadedsubprograms$ map to $\renamingset$ and $\vses$;
    \item filtering the subprograms in $\renamingset$ with the caller argument types $\callerargtypes$
          in $\tenv$ (see \TypingRuleRef{FilterCallCandidates}) yields an empty set\ProseOrTypeError;
    \item the result is a type error indicating that the call given by $\name$ and \\ $\callerargtypes$
          does not match any defined subprogram.
  \end{itemize}

  \item \AllApplyCase{too\_many\_candidates}
  \begin{itemize}
    \item $\tenv$ binds $\name$ via $\overloadedsubprograms$ map to $\renamingset$ and $\vses$;
    \item filtering the subprograms in $\renamingset$ with the caller argument types $\callerargtypes$
          in $\tenv$ (see \TypingRuleRef{FilterCallCandidates}) yields $\matchingrenamings$\ProseOrTypeError;
    \item $\matchingrenamings$ contains at least two elements;
    \item the result is a type error indicating that the call given by $\name$ and \\
          $\callerargtypes$ matches more than one defined subprogram.
  \end{itemize}

  \item \AllApplyCase{one\_candidate}
  \begin{itemize}
    \item $\tenv$ binds $\name$ via $\overloadedsubprograms$ map to $\renamingset$ and $\vses$;
    \item filtering the subprograms in $\renamingset$ with the caller argument types $\callerargtypes$
          in $\tenv$ (see \TypingRuleRef{FilterCallCandidates}) yields $\matchingrenamings$\ProseOrTypeError;
    \item $\matchingrenamings$ contains a single element --- $(\namep, \callee)$\ProseOrTypeError;
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[undefined]{
  G^\tenv.\overloadedsubprograms(\name) = \bot
}{
  \subprogramforname(\tenv, \name, \callerargtypes) \typearrow \TypeErrorVal{\UndefinedIdentifier}
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_candidates]{
  G^\tenv.\overloadedsubprograms(\name) = (\renamingset, \vses)\\
  {
    \begin{array}{r}
      \filtercallcandidates(\tenv, \callerargtypes, \renamingset) \typearrow \emptyset \OrTypeError
    \end{array}
  }
}{
  \subprogramforname(\tenv, \name, \callerargtypes) \typearrow \TypeErrorVal{\BadCall}
}
\end{mathpar}

\begin{mathpar}
\inferrule[too\_many\_candidates]{
  G^\tenv.\overloadedsubprograms(\name) = (\renamingset, \vses)\\
  {
    \begin{array}{r}
      \filtercallcandidates(\tenv, \callerargtypes, \renamingset) \typearrow \\ \matchingrenamings \OrTypeError
    \end{array}
  }\\\\
  \cardinality{\matchingrenamings} \geq 2
}{
  \subprogramforname(\tenv, \name, \callerargtypes) \typearrow \TypeErrorVal{\BadCall}
}
\end{mathpar}

\begin{mathpar}
\inferrule[one\_candidate]{
  G^\tenv.\overloadedsubprograms(\name) = (\renamingset, \vses)\\
  {
    \begin{array}{r}
      \filtercallcandidates(\tenv, \callerargtypes, \renamingset) \typearrow \\ \matchingrenamings \OrTypeError
    \end{array}
  }\\\\
  \matchingrenamings = [(\namep, \callee)]
}{
  {
    \begin{array}{r}
  \subprogramforname(\tenv, \name, \callerargtypes) \typearrow \\ (\namep, \callee, \vses)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\SubprogramForNameBegin}{\SubprogramForNameEnd}{../Typing.ml}

\TypingRuleDef{FilterCallCandidates}
\hypertarget{def-filtercandidates}{}
The helper function
\[
  \filtercallcandidates(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty^*}{\formaltypes} \aslsep
    \overname{\pow{\Strings}}{\candidates}
    )
  \aslto \overname{(\Strings\times\func)^*}{\matches}
\]
iterates over the list of unique subprogram names in $\candidates$ and checks whether
their lists of arguments clash with the types in $\formaltypes$ in $\tenv$.
The result is the set of pairs consisting of the names and function definitions of the
subprograms whose arguments clash in $\candidates$.
\ProseOtherwiseTypeError

The names $\candidates$ are assumed to exist in $G^\tenv.\subprograms$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{no\_candidates}
  \begin{itemize}
    \item $\candidates$ is empty;
    \item $\matches$ is empty.
  \end{itemize}

  \item \AllApplyCase{candidates\_exist}
  \begin{itemize}
    \item $\candidates$ is a list with \head\ $\name$ and \tail\ $\candidatesone$;
    \item the function definition associated with $\name$ in $\tenv$ is $\funcdef$;
    \item determining whether there is an argument clash between $\formaltypes$ and the arguments in $\funcdef$
          (that is, $\funcdef.\funcargs$) yields $\vb$\ProseOrTypeError;
    \item filtering the call candidates in $\candidatesone$ with $\formaltypes$ in $\tenv$ yields $\matchesone$\ProseOrTypeError;
    \item if $\vb$ is $\True$ then $\matches$ is the list with \head\ $(\name,\funcdef)$ and \tail\ $\matchesone$,
          and otherwise it is $\matchesone$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[no\_candidates]
{}{
  \filtercallcandidates(\tenv, \formaltypes, \overname{\emptylist}{\candidates}) \typearrow \overname{\emptylist}{\matches}
}
\and
\inferrule[candidates\_exist]
{
  \funcdef \eqdef G^\tenv.\subprograms(\name) \\
  \hasargclash(\tenv, \formaltypes, \funcdef.\funcargs) \typearrow \vb \OrTypeError\\\\
  \filtercallcandidates(\tenv, \formaltypes, \candidatesone) \typearrow \matchesone \OrTypeError\\\\
  \matches \eqdef \choice{\vb}{\;[(\name,\funcdef)] \concat \matchesone}{\;\matchesone}
}{
  \filtercallcandidates(\tenv, \formaltypes, \overname{[\name] \concat \candidatesone}{\candidates}) \typearrow \matches
}
\end{mathpar}

\TypingRuleDef{HasArgClash}
\hypertarget{def-hasargclash}{}
The function
\[
  \hasargclash(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\ty^*}{\formaltys} \aslsep
    \overname{(\identifier\times\ty)^*}{\vargs}
  )
  \aslto \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether a list of types $\formaltys$ clashes with the list of types appearing
in the list of arguments $\vargs$ in $\tenv$, yielding the result in $\vb$.
\ProseOtherwiseTypeError

\ProseParagraph
\AllApply
\begin{itemize}
  \item equating the list lengths of $\formaltys$ and $\vargs$ either yields $\True$
        or $\False$, which short-circuits the entire rule;
  \item $\argtys$ is the list of types appearing in $\vargs$, in the same order;
  \item for each $\vi$ in the list of indices of $\formaltys$, applying $\typeclashes$ to
        $\formaltys[\vi]$ and $\argtys[\vi]$ in $\tenv$ yields $\True$\ProseTerminateAs{\False, \TypeErrorConfig};
  \item $\vb$ is $\True$ (unless the rule short-circuited with $\False$ or a type error).
\end{itemize}

\CodeSubsection{\HasArgClashBegin}{\HasArgClashEnd}{../Typing.ml}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \equallength(\formaltypes, \vargs) \typearrow \True \terminateas \False\\
  \argtys \eqdef [(\Ignore, \vt) \in \vargs: \vt]\\
  \vi\in\listrange(\formaltys): \typeclashes(\tenv, \formaltys[\vi], \argtys[\vi]) \typearrow \True \terminateas \False,\TypeErrorConfig
}{
  \hasargclash(\tenv, \formaltys, \vargs) \typearrow \overname{\True}{\vb}
}
\end{mathpar}

\TypingRuleDef{ExpressionList}
\hypertarget{def-annotateexprs}{}
The helper function
\[
  \annotateexprlist(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr^*}{\exprs})
  \aslto \overname{(\ty \times \expr \times \TSideEffectSet)^*}{\typedexprs}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of expressions $\exprs$ from left to right, yielding a list of tuples $\typedexprs$,
each consisting of a type, an annotated expression, and a \sideeffectsetterm.
\ProseOtherwiseTypeError

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\exprs$ is empty;
    \item $\typedexprs$ is empty.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\exprs$ has $\ve$ as its \head\ expression and $\exprsone$ as its \tail;
    \item annotating $\ve$ in $\tenv$ yields the pair $\typedexpr$ consisting of a type and an expression
    \ProseOrTypeError;
    \item annotating the expression list $\exprsone$ in $\tenv$ yields
    $\typedexprs$\ProseOrTypeError;
    \item $\typedexprs$ is the list with $\typedexpr$ as its \head\ and $\typedexprs$ as its \tail.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}
{
  \annotateexprlist(\tenv, \overname{\emptylist}{\exprs}) \typearrow \overname{\emptylist}{\typedexprs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \annotateexpr{\tenv, \ve} \typearrow \typedexpr \OrTypeError\\\\
  \annotateexprlist(\tenv, \exprsone) \typearrow \typedexprsone \OrTypeError
}{
  \annotateexprlist(\tenv, \overname{[\ve] \concat \exprsone}{\exprs}) \typearrow \overname{[\typedexpr] \concat \typedexprsone}{\typedexprs}
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Semantics}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The relation
\hypertarget{def-evalcall}{}
\[
  \begin{array}{c}
    \evalcall{\overname{\envs}{\env} \aslsep
    \overname{\Identifiers}{\name} \aslsep
    \overname{\expr^*}{\params} \aslsep
    \overname{\expr^*}{\args}} \;\aslrel\; \\
    \Normal(\overbracket{(\vals\times\XGraphs)^*}^{\vmstwo}, \overname{\envs}{\newenv}) \cup
    \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TDynError}{\DynErrorConfig}
  \end{array}
\]
evaluates a call to the subprogram named $\name$ in the environment $\env$,
with the parameter expressions $\params$ and the argument expressions
$\args$.
The evaluation results in either a list of returned values, each one associated
with an execution graph, and a new environment;
or an abnormal configuration.

The evaluation first evaluates the expressions corresponding to the arguments
and parameters and then passes their values in a resulting configuration
to the helper relation \texttt{eval\_subprogram}.

The relation
\hypertarget{def-evalsubprogram}{}
\[
  \begin{array}{c}
    \evalsubprogram{\overname{\envs}{\env} \aslsep
    \overname{\Identifiers}{\name} \aslsep
    \overname{(\vals \times \XGraphs)^*}{\params} \aslsep
    \overname{(\vals \times \XGraphs)^*}{\args}} \aslrel \\
    \Normal(\overname{(\vals^* \aslsep \XGraphs)}{\vvs}, \overname{\envs}{\newenv}) \cup
    \overname{\TThrowing}{\ThrowingConfig} \cup
    \overname{\TDynError}{\DynErrorConfig}
  \end{array}
\]
evaluates the subprogram named $\name$ in the environment $\env$, with
$\actualargs$ the list of actual arguments, and $\params$ the
list of arguments deduced by type equality.
The result is either a normal configuration or an abnormal configuration.
In the case of a normal configuration, it consists of a list of pairs
with a value and an identifier, and a new environment $\newenv$.
The values represent values returned by the subprogram call and the
identifiers are used in generating execution graph constraints for the
returned values.

The main subprogram call relation is given by
SemanticsRule.Call (see \SemanticsRuleRef{Call}).
%
The different types of subprogram calls are evaluated via one of the following rules:
\begin{itemize}
\item \SemanticsRuleRef{FPrimitive}
\item \SemanticsRuleRef{FCall}
\end{itemize}

We also define the following helper rules:
\begin{itemize}
  \item \SemanticsRuleRef{ReadValueFrom}
  \item \SemanticsRuleRef{WriteRetVals}
  \item \SemanticsRuleRef{AssignArgs}
  \item \SemanticsRuleRef{MatchFuncRes}
\end{itemize}

\SemanticsRuleDef{Call}
\ProseParagraph
\AllApply
\begin{itemize}
  \item evaluating each expression in $\args$ separately in $\env$ as per \\
        \SemanticsRuleRef{EExprListM} is $\Normal(\vvargs, \envone)$\ProseOrAbnormal;
  \item evaluating each expression in $\params$ separately in $\env$ as per\\
        \SemanticsRuleRef{EExprListM} is $\Normal(\vvparams, \envtwo)$\ProseOrAbnormal;
  \item $\envtwo$ consists of the static environment $\tenv$ and the dynamic environment $\denvtwo$;
  \item applying $\incrstacksize$ to $G^\denvtwo$ and $\name$ yields $\genv$;
  \item the environment $\envtwo'$ is defined as the environment
  consisting of the static environment $\tenv$ and the dynamic environment with the global component
  $\genv$ and an empty local component (intuitively, this is because the called subprogram does not have access
  to the local environment of the caller);
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{normal}
    \begin{itemize}
      \item evaluating the subprogram named $\name$ with parameters $\vvparams$ and arguments $\vvargs$ in
      $\denvtwo'$ is $\Normal(\vms, (\vglobal, \Ignore))$ (that is, we ignore the local environment
      of the callee)\ProseOrError;
      \item applying the helper relation $\readvaluefrom$ to $\vms$ yields $\vmstwo$;
      \item applying $\decrstacksize$ to $\vglobal$ and $\name$ yields $\genvtwo$;
      \item define $\newenv$ as the environment where the static environment is $\tenv$ and the dynamic environment consists
            of the dynamic global environment $\genvtwo$ and the dynamic local environment is taken from $\denvtwo$
            (that is, we restore the local environment to that of the caller and drop the local environment of the callee).
      \item the entire evaluation results in $\Normal(\vmstwo, \newenv)$.
    \end{itemize}

    \item \AllApplyCase{throwing}
    \begin{itemize}
      \item evaluating the subprogram named $\name$ with arguments $\vvargs$ and parameters $\vvparams$ in
            $\denvtwo'$ is $\Throwing(\vv, \envthrow)$\ProseOrError;
      \item applying the helper relation $\readvaluefrom$ to $\vms$ yields $\vmstwo$;
      \item applying $\decrstacksize$ to $\vglobal$ and $\name$ yields $\genvtwo$;
      \item define $\newenv$ as the environment where the static environment is $\tenv$ and the dynamic environment consists
            of the dynamic global environment $\genvtwo$ and the dynamic local environment is taken from $\denvtwo$
            (that is, we restore the local environment to that of the caller and drop the local environment of the callee).
      \item the entire evaluation results in $\Normal(\vmstwo, \newenv)$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[normal]{
  \evalexprlistm(\env, \args) \evalarrow \Normal(\vvargs, \envone)\OrAbnormal\\
  \evalexprlistm(\envone, \params) \evalarrow \Normal(\vvparams, \envtwo)\OrAbnormal\\
  \envtwo \eqname (\tenv, \denvtwo)\\
  \incrstacksize(G^\denvtwo, \name) \evalarrow \genv\\\\
  \envtwo' \eqdef (\tenv, (\genv, \emptyfunc))\\\\
  \commonprefixline\\\\
  \evalsubprogram{\envtwo', \name, \vvparams, \vvargs} \evalarrow \Normal(\vms, (\vglobal, \Ignore)) \OrDynError\\\\
  \readvaluefrom(\vms) \evalarrow \vmstwo\\
  \decrstacksize(\vglobal, \name) \evalarrow \genvtwo\\
  \newenv \eqdef (\tenv, (\vglobal, L^{\denvtwo}))
}{
  \evalcall{\env, \name, \params, \args} \evalarrow \Normal(\vmstwo, \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[throwing]{
  \evalexprlistm(\env, \args) \evalarrow \Normal(\vvargs, \envone)\OrAbnormal\\
  \evalexprlistm(\envone, \params) \evalarrow \Normal(\vvparams, \envtwo)\OrAbnormal\\
  \envtwo \eqname (\tenv, \denvtwo)\\
  \incrstacksize(G^\denvtwo, \name) \evalarrow \genv\\\\
  \envtwo' \eqdef (\tenv, (\genv, \emptyfunc))\\\\
  \commonprefixline\\\\
  \evalsubprogram{\envtwo', \name, \vvparams, \vvargs} \evalarrow \Throwing(\vv, \envthrow) \OrDynError\\\\
  \envthrow \eqname (\tenv, \denvthrow)\\
  \decrstacksize(\vglobal, \name) \evalarrow \genvtwo\\
  \newenv \eqdef (\tenv, (\genvtwo, L^{\denvtwo}))
}{
  \evalcall{\env, \name, \params, \args} \evalarrow \Throwing(\vv, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalCallBegin}{\EvalCallEnd}{../Interpreter.ml}

\SemanticsRuleDef{FPrimitive}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\env$ consists of the static environment $\tenv$ and the dynamic environment with $\genv$ as its
        global component and an empty local component;
  \item finding the function named $\name$ in the static environment $\tenv$ gives a $\func$ AST node
        with the body field \SBPrimitive;
  \item evaluating the primitive subprogram $\name$ with the actual arguments $\args$
        is $\Normal(\vms, \vgone)$\ProseOrError;
  \item writing the returned values $\vms$ as per \SemanticsRuleRef{WriteRetVals} gives $\vvsm$;
  \item $\vvsm$ is a pair consisting of the list of values $\vvs$ and execution graph $\vgtwo$;
  \item $\newg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ label;
  \item $\newenv$ is the environment with $\tenv$ as its static environment component
        and the dynamic environment consisting of $\genv$ as its global component and an empty local component;
  \item the result of the entire evaluation is $\Normal((\vvs, \newg), \newenv)$.
\end{itemize}

\FormallyParagraph
The following rule utilizes the transition relation
\hypertarget{def-evalprimitive}{}
\[
  \evalprimitive{\overname{\Identifiers}{\name} \aslsep \overname{(\vals\times\XGraphs)^*}{\args}} \bigtimes
  \Normal(\overname{(\vals\times\XGraphs)^*}{\vms} \aslsep \overname{\XGraphs}{\vgone}) \cup \overname{\TDynError}{\DynErrorConfig} \enspace,
\]
which parameterizes the ASL semantics and allows evaluating primitive subprograms.
\hypertarget{def-evalprimitivearrow}{}
That is, it is not a part of $\evalarrow$ but rather a separate transition relation denoted $\evalprimitivearrow$.

\begin{mathpar}
\inferrule{
  \env \eqname (\tenv, (\genv, \emptyfunc))\\
  G^\tenv.\subprograms(\name) = \{ \body = \SBPrimitive \ldots \}\\
  \evalprimitive{\name, \args} \evalprimitivearrow \Normal(\vms, \vgone) \OrDynError\\\\
  \writeretvals(\vms) \evalarrow \vvsm\\
  \vvsm \eqname (\vvs, \vgtwo)\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}\\
  \newenv \eqdef (\tenv, (\genv, \emptyfunc))
}{
  \evalsubprogram{\env, \name, \params, \args} \evalarrow \Normal((\vvs, \newg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalFPrimitiveBegin}{\EvalFPrimitiveEnd}{../Interpreter.ml}

\SemanticsRuleDef{FCall}
\ExampleDef{Subprogram Calls}
In \listingref{semantics-fcall},
the function \texttt{main} calls the function \texttt{foo} and the procedure \texttt{bar}.
\ASLListing{Evaluating subprogram calls}{semantics-fcall}{\semanticstests/SemanticsRule.FCall.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\env$ consists of the static environment $\tenv$ and the dynamic environment with the global
        component $\genv$ and an empty local component;
  \item finding the function named $\name$ in $\tenv$ (via the $\subprograms$ component of the static global environment of $\tenv$)
        gives the AST $\func$ node with body
        $\SBASL(\vbody)$, parameters $\paramdecls$, arguments $\argdecls$, and optional recursion limit expression $\vrecurselimit$;
  \item $\envone$ is the environment consisting of the static environment $\tenv$ and the dynamic
        environment consisting of the dynamic component from $\denv$ and an empty local component;
  \item applying $\checkrecurselimit$ to $\name$ and $\vrecurselimit$ in $\envone$ yields $\vgone$\ProseOrError;
  \item \Proseeqdef{$\argnames$}{the identifiers appearing as the first component of each pair in $\argdecls$};
  \item assigning the actual arguments with $((\envone, \emptygraph), \argnames, \args)$
        as per \SemanticsRuleRef{AssignArgs} gives $(\envtwo, \vgtwo)$ and ensures that each
        formal argument in $\argdecls$ is
        locally bound to the corresponding actual value in $\args$;
  \item \Proseeqdef{$\paramnames$}{the identifiers appearing as the first component of each pair in $\params$};
  \item assigning the actual parameters with $((\envtwo, \emptygraph), \paramnames, \paramdecls)$
        as per \SemanticsRuleRef{AssignArgs} gives $(\envthree, \vgthree)$ and ensures that each
        formal parameter in $\paramdecls$ is
        locally bound to the corresponding actual value in $\params$;
  \item evaluating the body of the subprogram $\vbody$ as a statement in $\envthree$
        is $\vres$\ProseOrAbnormal;
  \item matching the result $\vres$ to obtain a normal configuration as per \\
        \SemanticsRuleRef{MatchFuncRes} gives $C$;
  \item $\newg$ is the ordered composition of $\vgone$ with the $\asldata$ and $\vgtwo$ and $\vgthree$ with the $\aslpo$ edge;
  \item the result is $C$ with its graph substituted for $\newg$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \env \eqname (\tenv, \denv)\\
  {
    G^\tenv.\subprograms(\name) \eqname \left\{
      \begin{array}{rcl}
      \funcbody &:& \SBASL(\vbody),\\
      \funcargs &:& \argdecls,\\
      \funcparameters &:& \paramdecls,\\
      \funcrecurselimit &:& \vrecurselimit, \\
      &&\ldots
      \end{array}
      \right\}
  }\\
  \envone \eqdef (\tenv, (G^\denv, \emptyfunc))\\
  \checkrecurselimit(\envone, \name, \vrecurselimit) \evalarrow \vgone \OrDynError\\\\
  \argnames \eqdef [(\vx, \Ignore) \in \argdecls: \vx]\\
  \assignargs((\envone, \emptygraph), \argnames, \actualargs) \evalarrow (\envtwo, \vgtwo)\\
  \paramnames \eqdef [(\vx, \Ignore) \in \params: \vx]\\
  \assignargs((\envtwo, \vgtwo), \paramnames, \paramdecls) \evalarrow (\envthree, \vgthree)\\
  \evalstmt{\envthree, \vbody} \evalarrow \vres \OrAbnormal\\
  \matchfuncres(\vres) \evalarrow C\\
  \newg \eqdef \ordered{\vgone}{\asldata}{\ordered{\vgtwo}{\aslpo}{\vgthree}}\\
}{
  \evalsubprogram{\env, \name, \actualargs, \params} \evalarrow \withgraph{C}{\newg}
}
\end{mathpar}
\CodeSubsection{\EvalFCallBegin}{\EvalFCallEnd}{../Interpreter.ml}

\subsubsection{Comments}
\identr{DFWZ}
It is not an error for execution of a procedure or setter to end without a
return statement.

\SemanticsRuleDef{CheckRecurseLimit}
\hypertarget{def-checkrecurselimit}{}
The helper relation
\[
  \checkrecurselimit(\overname{\envs}{\env} \aslsep \overname{\identifier}{\name} \aslsep \overname{\expr?}{\velimitopt}) \aslto
  \overname{\XGraphs}{\vg} \cup \overname{\TDynError}{\DynErrorConfig}
\]
checks whether the value in the optional expression $\velimitopt$ has reached the limit associated with $\name$
in $\env$, yielding the execution graph resulting from evaluating the optional expression in $\vg$.
Otherwise, the result is a dynamic error indicating that the recursion limit has been reached.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{none}
  \begin{itemize}
    \item applying $\evallimit$ to $\velimitopt$ in $\env$ yields $(\None, \vg)$\ProseOrError;
    \item define $\vg$ as the empty graph.
  \end{itemize}

  \item \AllApplyCase{some\_ok}
  \begin{itemize}
    \item applying $\evallimit$ to $\velimitopt$ in $\env$ yields $(\langle\vlimit\rangle, \vg)$\ProseOrError;
    \item view $\env$ as $(\tenv, \denv)$;
    \item applying $\getstacksize$ to $\name$ in $\denv$ yields $\vstacksize$;
    \item $\vlimit$ is less than $\vstacksize$.
  \end{itemize}

  \item \AllApplyCase{some\_error}
  \begin{itemize}
    \item applying $\evallimit$ to $\velimitopt$ in $\env$ yields $(\langle\vlimit\rangle, \vg)$\ProseOrError;
    \item view $\env$ as $(\tenv, \denv)$;
    \item applying $\getstacksize$ to $\name$ in $\denv$ yields $\vstacksize$;
    \item $\vlimit$ is greater or equal to $\vstacksize$;
    \item the result is a dynamic
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{
  \evallimit(\env, \velimitopt) \evalarrow (\None, \vg) \OrDynError
}{
  \checkrecurselimit(\env, \name, \velimitopt) \evalarrow \overname{\emptygraph}{\vg}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some\_ok]{
  \evallimit(\env, \velimitopt) \evalarrow (\langle\vlimit\rangle, \vg) \OrDynError\\\\
  \env \eqname (\tenv, \denv)\\
  \getstacksize(\denv, \name) \evalarrow \vstacksize\\
  \vlimit < \vstacksize
}{
  \checkrecurselimit(\env, \name, \velimitopt) \evalarrow \vg
}
\end{mathpar}

\begin{mathpar}
\inferrule[some\_error]{
  \evallimit(\env, \velimitopt) \evalarrow (\langle\vlimit\rangle, \vg) \OrDynError\\\\
  \env \eqname (\tenv, \denv)\\
  \getstacksize(\denv, \name) \evalarrow \vstacksize\\
  \vlimit \geq \vstacksize
}{
  \checkrecurselimit(\env, \name, \velimitopt) \evalarrow \DynamicErrorVal{\LimitExceeded}
}
\end{mathpar}

\SemanticsRuleDef{ReadValueFrom}
\hypertarget{def-readvaluefrom}{}
The helper relation
\[
  \readvaluefrom(\vals \aslsep \Identifiers) \;\aslrel\; (\vals \times \XGraphs)
\]
generates an execution graph for reading the given value to a variable given
by the identifier, and pairs it with the given value.

\ProseParagraph
\AllApply
\begin{itemize}
  \item reading the value $\vv$ into the variable named $\id$ gives $\newg$;
  \item the result is $(\vv, \newg)$.
\end{itemize}

\CodeSubsection{\EvalReadValueFromBegin}{\EvalReadValueFromEnd}{../Interpreter.ml}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \readidentifier(\vv, \id) \evalarrow \newg
}{
  \readvaluefrom(\vv, \id) \evalarrow (\vv, \newg)
}
\end{mathpar}

\SemanticsRuleDef{WriteRetVals}
\hypertarget{def-writeretvals}{}
The relation
\[
  \writeretvals(\overname{(\overname{\overname{\vals}{\vv}\times\overname{\XGraphs}{\vgone}}{\vm})^*}{\vvsm}) \;\aslrel\;
  (\overname{\vals^*}{\vvs}\times\overname{\XGraphs}{\newg}) \enspace.
\]
generates Write Effects for the values
returned by the evaluation of a primitive subprogram:

\ProseParagraph
  \OneApplies
  \begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item the list of value-execution graphs $\vvsm$ is empty;
    \item the result is a pair consisting of an empty list and an empty graph.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item the list of value-execution graphs $\vvsm$ has $\vm$ as its head and $\vvsmone$ as its tail;
    \item $\vx$ is a fresh identifier;
    \item $\vm$ consists of the value $\vv$ and execution graph $\vgone$;
    \item the execution graph $\vgtwo$ is generating by writing the value $\vv$ for the variable named $\vx$;
    \item writing the returned values in $\vvsmone$ gives $(\vvsone, \vgthree)$;
    \item $\vs$ is defined as the list with $\vv$ as its head and $\vvsone$ as its tail;
    \item $\newg$ is defined by first taking the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge
    and then composing the resulting execution graph in parallel with $\vgthree$;
    \item the result of the entire evaluation is $(\vvs, \newg)$.
  \end{itemize}
\end{itemize}

%% Annotating the OCaml code is problematic, since the code for this rule is inside the code
%% for FPrimitive. One option is to factor it out into a separate function.
%
%   \CodeSubsection{\EvalWriteRetValsBegin}{\EvalWriteRetValsEnd}{../Interpreter.ml}

\FormallyParagraph
  \begin{mathpar}
    \inferrule[empty]{}
    {
      \writeretvals(\emptylist) \evalarrow (\emptylist, \emptygraph)
    }
    \and
    \inferrule[non\_empty]{
      \vvsm \eqname [\vm] \concat \vvsmone\\
      \vx \in \Identifiers \text{ is fresh}\\
      \vm \eqname (\vv, \vgone)\\
      \writeidentifier(\vx, \vv) \evalarrow \vgtwo\\
      \writeretvals(\vvsmone) \evalarrow (\vvsone, \vgthree)\\
      \vvs \eqdef [\vv] \concat \vvsone\\
      \newg \eqdef (\ordered{\vgone}{\asldata}{\vgtwo}) \parallelcomp \vgthree
    }
    {
      \writeretvals(\vvsm) \evalarrow (\vvs, \newg)
    }
  \end{mathpar}

\SemanticsRuleDef{AssignArgs}
The helper relation
\hypertarget{def-assignargs}{}
\[
  \assignargs(
    (\overname{\envs}{\env}\times\overname{\XGraphs}{\vgone})\aslsep
    \overname{\Identifiers^*}{\vids} \aslsep
    \overname{(\vals\times\XGraphs)^*} {\actuals}) \;\aslrel\;
              (\overname{\envs}{\newenv} \times \overname{\XGraphs}{\newg})
\]
updates the pair consisting of the environments $\env$ and \executiongraph\ $\vgone$
by assigning the values given by $\actuals$ to the identifiers given by $\vids$,
yielding the updated pair $(\newenv, \newg)$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item both $\vids$ and $\actuals$ are empty lists;
    \item \Proseeqdef{$\newenv$}{$\env$};
    \item \Proseeqdef{$\newg$}{$\vgone$}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vids$ has $\vx$ as its head and $\vidsone$ as its tail,
          and $\actuals$ has $\vm$ as its head and $\actualsone$ as its tail;
    \item declaring the local identifier $\vx$ with $\vm$ in $\env$ as per \SemanticsRuleRef{DeclareLocalIdentifierMM}
    gives \\ $(\envone, \vgtwo)$.
    \item assigning the remaining lists $\vidsone$ and $\actualsone$ with the environment $\envone$ and the ordered
          composition of $\vgone$ and $\vgtwo$ with the $\aslpo$ edge yields\\
          $(\newenv, \newg)$.
    \item the entire result of the evaluation is $(\newenv, \newg)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}
{
  \assignargs((\env, \vgone), \overname{\vids}{\emptylist}, \overname{\emptylist}{\actuals}) \evalarrow (\overname{\env}{\newenv}, \overname{\vgone}{\newg})
}
\end{mathpar}

\begin{mathpar}
  \inferrule[non\_empty]{
  \declarelocalidentifiermm(\env, \vx, \vm) \evalarrow (\envone, \vgtwo)\\
  \assignargs((\envone, \ordered{\vgone}{\aslpo}{\vgtwo}), \vidsone, \actualsone) \evalarrow (\newenv, \vg)
}{
  \assignargs((\env, \vgone), \overname{[\vx] \concat \vidsone}{\vids}, \overname{[\vm] \concat \actualsone}{\actuals}) \evalarrow (\newenv, \vg)
}
\end{mathpar}

\SemanticsRuleDef{MatchFuncRes}
The helper relation
\hypertarget{def-matchfuncres}{}
\[
    \matchfuncres(\TContinuing \cup \TReturning) \;\aslrel\;
                  \Normal(((\Identifiers\times\vals)^*\times\XGraphs)\aslsep\envs)
\]
converts continuing configurations and returning configurations
into corresponding normal configurations that can be returned by a subprogram evaluation.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{continuing}
  \begin{itemize}
    \item the given configuration is $\Continuing(\vg, \env)$. This happens when,
    for example, the subprogram called is either a setter or a procedure;
    \item the result is $\Normal((\emptylist, \vg), \env)$.
  \end{itemize}

  \item \AllApplyCase{returning}
  \begin{itemize}
    \item the given configuration is $\Returning(\xs, \retenv)$, which is the case of a function;
    \item $\xs$ is the list $\vv_i$, for $i=1..k$;
    \item define the list of fresh identifiers $\id_i$, for $i=1..k$;
    \item define $\vvs$ to be $(\vv_i, \id_i)$, for $i=1..k$;
    \item the result is $\Normal((\vvs, \emptygraph), \retenv)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule[continuing]{}
  {
    \matchfuncres(\Continuing(\vg, \env)) \evalarrow \Normal((\emptylist, \vg), \env)
  }
  \and
  \inferrule[returning]{
    \xs \eqname [i=1..k: \vv_i]\\
    i=1..k: \id_i \in \Identifiers\text{ is fresh}\\
    \vvs \eqdef [i=1..k: (\vv_i, \id_i)]
  }
  {
    \matchfuncres(\Returning(\xs, \retenv)) \evalarrow \Normal((\vvs, \emptygraph), \retenv)
  }
\end{mathpar}
