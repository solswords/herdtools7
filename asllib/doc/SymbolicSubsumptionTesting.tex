\chapter{Symbolic Subsumption Testing\label{chap:SymbolicSubsumptionTesting}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This chapter is concerned with implementing a \hyperlink{def-soundsubsumptiontest}{sound subsumption test}
for integer types, as defined in \secref{subsumptiontesting} and employed by
TypingRule.SubtypeSatisfaction (see \TypingRuleRef{SubtypeSatisfaction}).

\hypertarget{def-symbolicdomain}{}
The symbolic reasoning operates by first transforming types into expressions in a \emph{symbolic domain} AST
(defined next, reusing $\intconstraint$ from the untyped AST) over which it then operates:
\hypertarget{def-symdom}{}
\hypertarget{def-finite}{}
\[
  \begin{array}{rcl}
    \symdom &::=& \Finite(\powfin{\Z} \setminus \emptyset) \hypertarget{def-top}{}\\
            &|  & \Top                      \hypertarget{def-fromsymtax}{}\\
            &|  & \FromSyntax(\syntax)      \hypertarget{def-syntax}{}\\
    \syntax &::=& \intconstraint^*
  \end{array}
\]

\begin{itemize}
  \item We refer to an element of the form $\Finite(S)$ as a \emph{symbolic finite set integer domain},
        which represents the set of integers $S$;
  \item We refer to an element of the form $\FromSyntax(\vcs)$ as a \emph{symbolic constrained integer domain},
        which represents the set of integers given by the list of constraints $\vcs$; and
  \item We refer to an element of the form $\Top$ as a \emph{symbolic unconstrained integer domain},
        which represents the set of all integers.
\end{itemize}

The main rule is of this chapter is \TypingRuleRef{SymSubsumes}, which defines the function
$\symsubsumes$.

Other helper rules are as follows:
\begin{itemize}
  \item \TypingRuleRef{SymDomOfType}
  \item \TypingRuleRef{SymDomOfExpr}
  \item \TypingRuleRef{SymDomOfWidth}
  \item \TypingRuleRef{IntSetOp}
  \item \TypingRuleRef{IntSetToIntConstraints}
  \item \TypingRuleRef{SymDomOfLiteral}
  \item \TypingRuleRef{SymIntSetOfConstraints}
  \item \TypingRuleRef{ConstraintToIntSet}
  \item \TypingRuleRef{NormalizeToInt}
  \item \TypingRuleRef{SymDomIsSubset}
  \item \TypingRuleRef{ConstraintBinop}
\end{itemize}

\TypingRuleDef{SymSubsumes}
\hypertarget{def-symsubsumes}{}
The predicate
\[
  \symsubsumes(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt} \aslsep \overname{\ty}{\vs})
  \aslto \overname{\Bool}{\vb}
\]
soundly approximates $\subsumes(\tenv, \vt, \vs)$ for integer types.
\ProseOtherwiseTypeError

We assume that both $\vt$ and $\vs$ have been successfully annotated to integer types as per \chapref{Types}
(otherwise a typing error prevents us from applying this function).

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\symdomoftype$ to $\vt$ in $\tenv$ yields $\dt$;
  \item applying $\symdomoftype$ to $\vs$ in $\tenv$ yields $\ds$;
  \item applying $\symdomissubset$ to $\dt$ and $\ds$ in $\tenv$ yields $\vb$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \symdomoftype(\tenv, \vt) \typearrow \dt\\
  \symdomoftype(\tenv, \vs) \typearrow \ds\\
  \symdomissubset(\tenv, \dt, \ds) \typearrow \vb
}{
  \symsubsumes(\tenv, \vt, \vs) \typearrow \vb
}
\end{mathpar}

\TypingRuleDef{SymDomOfType}
\hypertarget{def-symdomoftype}{}
The function
\[
  \symdomoftype(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto \overname{\symdom}{\vd}
\]
transforms a type $\vt$ in a static environment $\tenv$ into a symbolic domain $\vd$.
It assumes its input type has an \underlyingtype{} which is an integer.
\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{int\_unconstrained}
  \begin{itemize}
    \item $\vt$ is the unconstrained integer type;
    \item define $\vd$ as $\Top$, which intuitively represents the entire set of integers.
  \end{itemize}

  \item \AllApplyCase{int\_parameterized}
  \begin{itemize}
    \item $\vt$ is the \parameterizedintegertype\ for the identifier $\id$;
    \item define $\vd$ as the symbolic constrained integer domain with a single constraint for the variable expression for $\id$,
          that is, \\ $\FromSyntax([\ConstraintExact(\EVar(\id))])$.
  \end{itemize}

  \item \AllApplyCase{int\_well\_constrained\_finite}
  \begin{itemize}
    \item $\vt$ is the well-constrained integer type for the list of constraints $\vcs$;
    \item applying $\intsetofintconstraints$ to $\vcs$ in $\tenv$ yields $\vis$;
    \item $\vis$ is a set of integers, that is, $\astlabel(\vis)$ is $\Finite$;
    \item define $\vd$ as the symbolic finite set integer domain for $\vis$.
  \end{itemize}

  \item \AllApplyCase{int\_well\_constrained\_symbolic}
  \begin{itemize}
    \item $\vt$ is the well-constrained integer type for the list of constraints $\vcs$;
    \item applying $\intsetofintconstraints$ to $\vcs$ in $\tenv$ yields $\vis$;
    \item $\vis$ is not a set of integers, that is, $\astlabel(\vis)$ is not $\Finite$;
    \item define $\vd$ as the symbolic constrained integer domain for the list of constraints $\vcs$, that is, $\FromSyntax(\vcs)$.
  \end{itemize}

  \item \AllApplyCase{t\_named}
  \begin{itemize}
    \item $\vt$ is the named type for identifier $\id$;
    \item applying $\makeanonymous$ to $\vt$ in $\tenv$ yields $\vtone$;
    \item applying $\symdomoftype$ to $\vtone$ in $\tenv$ yields $\vd$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[int\_unconstrained]{}{ \symdomoftype(\tenv, \overname{\unconstrainedinteger}{\vt}) \typearrow \overname{\Top}{\vd} }
\end{mathpar}

\begin{mathpar}
\inferrule[int\_parameterized]{}{
  \symdomoftype(\tenv, \overname{\TInt(\parameterized(\id))}{\vt}) \typearrow \\
  \overname{\FromSyntax([\ConstraintExact(\EVar(\id))])}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_well\_constrained\_finite]{
  \intsetofintconstraints(\tenv, \vcs) \typearrow \vis\\
  \astlabel(\vis) = \Finite
}{
  \symdomoftype(\tenv, \overname{\TInt(\wellconstrained(\vcs))}{\vt}) \typearrow \overname{\vis}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_well\_constrained\_symbolic]{
  \intsetofintconstraints(\tenv, \vcs) \typearrow \vis\\
  \astlabel(\vis) \neq \Finite
}{
  \symdomoftype(\tenv, \overname{\TInt(\wellconstrained(\vcs))}{\vt}) \typearrow \overname{\FromSyntax(\vcs)}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_named]{
  \vt = \TNamed(\id)\\
  \makeanonymous(\vt) \typearrow \vtone\\
  \symdomoftype(\tenv, \vtone) \typearrow \vd
}{
  \symdomoftype(\tenv, \vt) \typearrow \vd
}
\end{mathpar}

\TypingRuleDef{SymDomOfExpr}
\hypertarget{def-symdomofexpr}{}
The function
\[
\symdomofexpr(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\expr}{\ve}
) \aslto
\overname{\symdom}{\vd}
\]
assigns a symbolic domain $\vd$ to an \underline{integer typed} expression $\ve$ in the static environment $\tenv$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{e\_literal}
  \begin{itemize}
    \item $\ve$ is a literal expression for the literal $\vv$;
    \item applying $\symdomofliteral$ to $\vv$ yields $\vd$.
  \end{itemize}

  \item \AllApplyCase{e\_var\_constant}
  \begin{itemize}
    \item $\ve$ is a variable expression for the identifier $\vx$;
    \item applying $\lookupconstant$ to $\vx$ in $\tenv$ yields the literal $\vv$;
    \item applying $\symdomofliteral$ to $\vv$ yields $\vd$.
  \end{itemize}

  \item \AllApplyCase{e\_var\_type}
  \begin{itemize}
    \item $\ve$ is a variable expression for the identifier $\vx$;
    \item applying $\lookupconstant$ to $\vx$ in $\tenv$ yields $\bot$;
    \item applying $\typeof$ to $\vx$ in $\tenv$ yields $\vtone$;
    \item applying $\symdomoftype$ to $\vtone$ yields $\vd$.
  \end{itemize}

  \item \AllApplyCase{e\_unop\_minus}
  \begin{itemize}
    \item $\ve$ is a unary operation expression for the operation $\MINUS$ and subexpression $\veone$;
    \item applying $\symdomofexpr$ to the binary operation expression with the operation $\MINUS$
          and the literal expression for $0$ and $\veone$ in $\tenv$ yields $\vd$.
  \end{itemize}

  \item \AllApplyCase{e\_unop\_unknown}
  \begin{itemize}
    \item $\ve$ is a unary operation expression for an operation that is not $\MINUS$;
    \item define $\vd$ as $\FromSyntax([\ConstraintExact(\ve)])$
  \end{itemize}

  \item \AllApplyCase{e\_binop\_supported}
  \begin{itemize}
    \item $\ve$ is a binary operation expression for an operation that is one of $\PLUS$, $\MINUS$, or $\MUL$
          and subexpressions $\veone$ and $\vetwo$;
    \item applying $\symdomofexpr$ to $\veone$ in $\tenv$ yields a symbolic domain $\visone$;
    \item applying $\symdomofexpr$ to $\vetwo$ in $\tenv$ yields a symbolic domain $\vistwo$;
    \item applying $\intsetop$ to $\op$ and $\visone$ and $\vistwo$ yields $\vis$;
    \item define $\vd$ as $\vis$.
  \end{itemize}

  \item \AllApplyCase{e\_binop\_unsupported}
  \begin{itemize}
    \item $\ve$ is a binary operation expression for an operation that is not one of $\PLUS$, $\MINUS$, or $\MUL$;
    \item define $\vd$ as $\FromSyntax([\ConstraintExact(\ve)])$
  \end{itemize}

  \item \AllApplyCase{unsupported}
  \begin{itemize}
    \item $\ve$ is not one of the following expression types a literal expression, a variable expression, a unary operation
          expression, or a binary operation expression;
    \item define $\vd$ as $\FromSyntax([\ConstraintExact(\ve)])$
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[e\_literal]{
  \symdomofliteral(\vv) \typearrow \vd
}{
  \symdomofexpr(\tenv, \overname{\ELiteral(\vv)}{\ve}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_var\_constant]{
  \lookupconstant(\tenv, \vx) \typearrow \vv\\
  \symdomofliteral(\vv) \typearrow \vd
}{
  \symdomofexpr(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_var\_type]{
  \lookupconstant(\tenv, \vx) \typearrow \bot\\
  \typeof(\tenv, \vx) \typearrow \vtone\\
  \symdomoftype(\vtone) \typearrow \vd
}{
  \symdomofexpr(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop\_minus]{
  \symdomofexpr(\EBinop(\MINUS, \ELiteral(\lint(0)), \veone)) \typearrow \vd
}{
  \symdomofexpr(\tenv, \overname{\EUnop(\MINUS, \veone)}{\ve}) \typearrow \vd
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop\_unknown]{
  \op \neq \MINUS
}{
  \symdomofexpr(\tenv, \overname{\EUnop(\op, \veone)}{\ve}) \typearrow \overname{\FromSyntax([\ConstraintExact(\ve)])}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop\_supported]{
  \op \in \{\PLUS, \MINUS, \MUL\}\\
  \symdomofexpr(\tenv, \veone) \typearrow \visone\\
  \symdomofexpr(\tenv, \vetwo) \typearrow \vistwo\\
  \intsetop(\op, \visone, \vistwo) \typearrow \vis
}{
  \symdomofexpr(\tenv, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow \overname{\vis}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop\_unsupported]{
  \op \not\in \{\PLUS, \MINUS, \MUL\}\\
}{
  \symdomofexpr(\tenv, \overname{\EBinop(\op, \Ignore, \Ignore)}{\ve}) \typearrow \overname{\FromSyntax([\ConstraintExact(\ve)])}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unsupported]{
  \astlabel(\ve) \not\in \{\ELiteral, \EVar, \EUnop, \EBinop\}
}{
  \symdomofexpr(\tenv, \ve) \typearrow \overname{\FromSyntax([\ConstraintExact(\ve)])}{\vd}
}
\end{mathpar}

\TypingRuleDef{SymDomOfWidth}
\hypertarget{def-symdomofwidth}{}
The function
\[
\symdomofwidth(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\expr}{\ve}
) \aslto
\overname{\symdom}{\vd}
\]
assigns a symbolic domain $\vd$ to an \underline{integer typed} expression $\ve$ in the static environment $\tenv$.
In contrast to $\symdomofexpr$, $\symdomofwidth$ should be applied to expressions that represent a bitvector width.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{finite\_one\_width}
  \begin{itemize}
    \item applying $\symdomofexpr$ to $\ve$ in $\tenv$ yields $\vdone$;
    \item $\vdone$ is a set of integers, that is, $\Finite(s)$;
    \item the cardinality of $s$ is one;
    \item $\vd$ is $\vdone$.
  \end{itemize}

  \item \AllApplyCase{finite\_multiple\_widths}
  \begin{itemize}
    \item applying $\symdomofexpr$ to $\ve$ in $\tenv$ yields $\vdone$;
    \item $\vdone$ is a set of integers, that is, $\Finite(s)$;
    \item the cardinality of $s$ is \emph{not} one;
    \item define $\vd$ as $\FromSyntax([\ConstraintExact(\ve)])$.
  \end{itemize}

  \item \AllApplyCase{non\_finite}
  \begin{itemize}
    \item applying $\symdomofexpr$ to $\ve$ in $\tenv$ yields $\vdone$;
    \item $\vdone$ is not a set of integers, that is, $\astlabel(\vdone)$ is not $\Finite$;
    \item define $\vd$ as $\FromSyntax([\ConstraintExact(\ve)])$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[finite\_one\_width]{
  \symdomofexpr(\tenv, \ve) \typearrow \vdone \\
  \vdone = \Finite(s) \\
  \cardinality{s} = 1
}{
  \symdomofwidth(\tenv, \ve) \typearrow \overname{\vdone}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[finite\_multiple\_widths]{
  \symdomofexpr(\tenv, \ve) \typearrow \vdone \\
  \vdone = \Finite(s) \\
  \cardinality{s} \neq 1
}{
  \symdomofwidth(\tenv, \ve) \typearrow \overname{\FromSyntax([\ConstraintExact(\ve)])}{\vd}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_finite]{
  \symdomofexpr(\tenv, \ve) \typearrow \vdone \\
  \astlabel(\vdone) \neq \Finite
}{
  \symdomofwidth(\tenv, \ve) \typearrow \overname{\FromSyntax([\ConstraintExact(\ve)])}{\vd}
}
\end{mathpar}

\TypingRuleDef{IntSetOp}
\hypertarget{def-intsetop}{}
The function
\[
\intsetop(\overname{\binop}{\op} \aslsep \overname{\symdom}{\visone} \aslsep \overname{\symdom}{\vistwo})
\aslto \overname{\symdom}{\vis}
\]
applies the binary operation $\op$ to the symbolic domains $\visone$ and $\vistwo$,
yielding the symbolic domain $\vis$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{top}
  \begin{itemize}
    \item at least one of $\visone$ and $\vistwo$ is $\Top$;
    \item define $\vis$ as $\Top$.
  \end{itemize}

  \item \AllApplyCase{finite\_finite}
  \begin{itemize}
    \item $\visone$ is the symbolic finite set integer domain for $\vsone$;
    \item $\vistwo$ is the symbolic finite set integer domain for $\vstwo$;
    \item define $\vis$ as the symbolic finite set domain for the set obtained
          by applying $\op$ to each element of $\vsone$ and each element of $\vstwo$.
  \end{itemize}

  \item \AllApplyCase{finite\_syntax}
  \begin{itemize}
    \item $\visone$ is the symbolic finite set integer domain for $\vsone$;
    \item $\vistwo$ is the symbolic constrained integer domain for $\vstwo$;
    \item applying $\intsettointconstraints$ to $\vsone$ yields the list of constraints $\csone$;
    \item applying $\intsetop$ to $\op$, the symbolic constrained integer domain for $\csone$,
          and $\vistwo$ yields $\vis$.
  \end{itemize}

  \item \AllApplyCase{syntax\_finite}
  \begin{itemize}
    \item $\visone$ is the symbolic constrained integer domain for $\csone$;
    \item $\vistwo$ is the symbolic finite set integer domain for $\vstwo$;
    \item applying $\intsettointconstraints$ to $\vstwo$ yields the list of constraints $\cstwo$;
    \item applying $\intsetop$ to $\op$, $\visone$, and the symbolic constrained integer domain
          for $\cstwo$, yields $\vis$.
  \end{itemize}

  \item \AllApplyCase{syntax\_syntax\_well\_constrained}
  \begin{itemize}
    \item $\visone$ is the symbolic constrained integer domain for $\csone$;
    \item $\vistwo$ is the symbolic constrained integer domain for $\cstwo$;
    \item applying $\constraintbinop$ to $\op$, $\csone$, and $\cstwo$ yields
          a list of constraints $\vcs$;
    \item define $\vis$ as the symbolic constrained integer domain for $\vcs$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[top]{
  \visone = \Top \lor \vistwo = \Top
}{
  \intsetop(\op, \visone, \vistwo) \typearrow \overname{\Top}{\vis}
}
\and
\inferrule[finite\_finite]{
  \vis \eqdef \Finite(\{ \op(a, b) \;|\; a \in \vsone, b \in \vstwo \})
}{
  \intsetop(\op, \overname{\Finite(\vsone)}{\visone}, \overname{\Finite(\vstwo)}{\vistwo}) \typearrow \vis
}
\end{mathpar}

\begin{mathpar}
\inferrule[finite\_syntax]{
  \intsettointconstraints(\vsone) \typearrow \vcsone\\
  \intsetop(\op, \FromSyntax(\vcsone), \FromSyntax(\vcstwo)) \typearrow \vis
}{
  \intsetop(\op, \overname{\Finite(\vsone)}{\visone}, \overname{\FromSyntax(\vcstwo)}{\vistwo}) \typearrow \vis
}
\end{mathpar}

\begin{mathpar}
\inferrule[syntax\_finite]{
  \intsettointconstraints(\vstwo) \typearrow \vcstwo\\
  \intsetop(\op, \FromSyntax(\vcsone), \FromSyntax(\vcstwo)) \typearrow \vis
}{
  \intsetop(\op, \overname{\FromSyntax(\vcsone)}{\visone}, \overname{\Finite(\vstwo)}{\vistwo}) \typearrow \vis
}
\end{mathpar}

\begin{mathpar}
\inferrule[syntax\_syntax\_well\_constrained]{
  \constraintbinop(\op, \vcsone, \vcstwo) \typearrow \wellconstrained(\vcs)
}{
  \intsetop(\op, \overname{\FromSyntax(\vcsone)}{\visone}, \overname{\FromSyntax(\vcstwo)}{\vistwo}) \typearrow \overname{\FromSyntax(\vcs)}{\vis}
}
\end{mathpar}

\TypingRuleDef{IntSetToIntConstraints}
\hypertarget{def-intsettointconstraints}{}
The function
\[
\intsettointconstraints(\overname{\powfin{\Z}}{\vs})
\aslto \overname{\intconstraint^*}{\cs}
\]
transforms a finite set of integers into the equivalent list of integer constraints.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vs$ is the empty set;
    \item define $\cs$ as the empty list.
  \end{itemize}

  \item \AllApplyCase{singleton}
  \begin{itemize}
    \item $\vs$ is the singleton set for $a$;
    \item define $\cs$ as the list containing the single range constraint for the interval starting from $a$
          and ending at $a$, that is, $\ConstraintRange(\ELInt{a}, \ELInt{a})$.
  \end{itemize}

  \item \AllApplyCase{new\_interval}
  \begin{itemize}
    \item define $a$ as the minimal element of $\vs$;
    \item define $\vsone$ as the set $\vs$ with $a$ removed from it;
    \item applying $\intsettointconstraints$ to $\vsone$ yields the list of constraints $\csone$;
    \item $\csone$ is a list where its \head\ is a range constraint for the interval starting from $b$ and ending at $c$
          and \tail\ $\cstwo$;
    \item $b$ is greater than $a+1$;
    \item define $\cs$ as the list with first element a range constraint for the interval from $a$ to $a$,
          second element a range constraint for the interval from $b$ to $c$, and remaining elements given by $\cstwo$.
  \end{itemize}

  \item \AllApplyCase{merge\_interval}
  \begin{itemize}
    \item define $a$ as the minimal element of $\vs$;
    \item define $\vsone$ as the set $\vs$ with $a$ removed from it;
    \item applying $\intsettointconstraints$ to $\vsone$ yields the list of constraints $\csone$;
    \item $\csone$ is a list where its \head\ is a range constraint for the interval starting from $b$ and ending at $c$
          and \tail\ $\cstwo$;
    \item $b$ is equal to $a+1$;
    \item define $\cs$ as the list with \head\  a range constraint for the interval from $a$ to $c$
          and \tail\ $\cstwo$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \intsettointconstraints(\overname{\emptyset}{\vs}) \typearrow \overname{\emptylist}{\cs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[singleton]{}{
  \intsettointconstraints(\overname{\{a\}}{\vs}) \typearrow \overname{[\ConstraintRange(\ELInt{a}, \ELInt{a})]}{\cs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[new\_interval]{
  a = \min(\vs)\\
  \vsone \eqdef \vs \setminus \{a\}\\
  \intsettointconstraints(\vsone) \typearrow \csone\\
  \csone = [\ConstraintRange(\ELInt{b}, \ELInt{c})] \concat \cstwo\\
  b > a + 1\\\\
  {
    \begin{array}{rcl}
  \cs  &\eqdef & [\ConstraintRange(\ELInt{a}, \ELInt{a})]\ \concat\\
        &       & [\ConstraintRange(\ELInt{b}, \ELInt{c})]\ \concat \\
        &       & \cstwo
    \end{array}
  }
}{
  \intsettointconstraints(\vs) \typearrow \cs
}
\end{mathpar}

\begin{mathpar}
\inferrule[merge\_interval]{
  a = \min(\vs)\\
  \vsone \eqdef \vs \setminus \{a\}\\
  \intsettointconstraints(\vsone) \typearrow \csone\\
  \csone = [\ConstraintRange(\ELInt{b}, \ELInt{c})] \concat \cstwo\\
  b = a + 1\\
  \cs \eqdef [\ConstraintRange(\ELInt{a}, \ELInt{c})] \concat \cstwo
}{
  \intsettointconstraints(\vs) \typearrow \cs
}
\end{mathpar}

\TypingRuleDef{SymDomOfLiteral}
\hypertarget{def-symdomofliteral}{}
The function
\[
\symdomofliteral(\overname{\literal}{\vv}) \typearrow \overname{\symdom}{\vd}
\]
returns the symbolic domain $\vd$ that corresponds to the literal $\vv$.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vv$ is an integer literal for $n$;
  \item define $\vd$ as the symbolic finite set integer domain for the singleton set for $n$, that is, $\Finite(\{n\})$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \symdomofliteral(\overname{\lint(n)}{\vv}) \typearrow \overname{\Finite(\{n\})}{\vd}
}
\end{mathpar}

\TypingRuleDef{SymIntSetOfConstraints}
\hypertarget{def-intsetofintconstraintse}{}
The function
\[
  \intsetofintconstraints(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\constraints}{\vcs}
  ) \aslto
  \overname{\symdom}{\vis}
\]
returns the symbolic domain $\vis$ for the list of constraints $\vcs$
in the static environment $\tenv$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{finite}
  \begin{itemize}
    \item applying $\constrainttointset$ to every constraint $\vcs[\vi]$ in $\tenv$, for $\vi$ in \\ $\listrange(\vcs)$,
          yields a finite set of integers $C_\vi$, that is, $\Finite(C_\vi)$;
    \item define $\vis$ as the union of $C_\vi$ for all $\vi$ in $\listrange(\vcs)$.
  \end{itemize}

  \item \AllApplyCase{symbolic}
  \begin{itemize}
    \item there exists a constraint $\vc$ in $\vcs$ such that applying $\constrainttointset$ to $\vc$
          in $\tenv$ does not yield a finite set of integers;
    \item define $\vis$ as the symbolic constrained integer domain for $\vcs$, that is, \\
          $\FromSyntax(\vcs)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[finite]{
  \vi\in\listrange(\vcs): \constrainttointset(\tenv, \vcs[\vi]) \typearrow \Finite(C_\vi)\\
  C \eqdef \bigcup_{\vi\in\listrange(\vcs)} C_\vi
}{
  \intsetofintconstraints(\tenv, \vcs) \typearrow \overname{\Finite(C)}{\vis}
}
\end{mathpar}

\begin{mathpar}
\inferrule[symbolic]{
  {
    \begin{array}{r}
  \exists \vi\in\listrange(\vcs): \constrainttointset(\tenv, \vcs[\vi]) \typearrow \\
     \visone \land \astlabel(\visone) \neq \Finite
    \end{array}
  }
}{
  \intsetofintconstraints(\tenv, \vcs) \typearrow \overname{\FromSyntax(\vcs)}{\vis}
}
\end{mathpar}

\TypingRuleDef{ConstraintToIntSet}
\hypertarget{def-constrainttointset}{}
The function
\[
  \constrainttointset(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\intconstraint}{\vc}
  ) \aslto
  \overname{\symdom}{\vis}
\]
transforms an integer constraint $\vc$ into a symbolic domain $\vis$.
It produces $\Top$ when the expressions involved in the integer constraints cannot be simplified
to integers.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is a single expression constraint for $\ve$, that is, $\ConstraintExact(\ve)$;
    \item applying $\normalizetoint$ to $\ve$ in $\tenv$ yields the integer $n$\ProseTerminateAs{\Top};
    \item define $\vis$ as the singleton set for $n$, that is, $\Finite(\{n\})$.
  \end{itemize}

  \item \AllApplyCase{range}
  \begin{itemize}
    \item $\vc$ is a range constraint for $\veone$ and $\vetwo$, that is, $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\normalizetoint$ to $\veone$ in $\tenv$ yields the integer $b$\ProseTerminateAs{\Top};
    \item applying $\normalizetoint$ to $\vetwo$ in $\tenv$ yields the integer $t$\ProseTerminateAs{\Top};
    \item define $\vis$ as the set integers that are both greater or equal to $b$ and less than or equal to $t$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \normalizetoint(\tenv, \ve) \typearrow n \terminateas \Top
}{
  \constrainttointset(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \overname{\Finite(\{n\})}{\vis}
}
\and
\inferrule[range]{
  \normalizetoint(\tenv, \veone) \typearrow b \terminateas \Top\\\\
  \normalizetoint(\tenv, \vetwo) \typearrow t \terminateas \Top\\\\
  \vis \eqdef \Finite(\{ n \;|\; b \leq n \leq t\})
}{
  \constrainttointset(\tenv, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \vis
}
\end{mathpar}

\TypingRuleDef{NormalizeToInt}
\hypertarget{def-normalizetoint}{}
The function
\[
\normalizetoint(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\expr}{\ve}
) \aslto \overname{\Z}{n} \cup \{\Top\}
\]
\symbolicallysimplifies\ the \underline{integer-typed} expression $\ve$ and returns the resulting integer or $\Top$ if
the result of the simplification is not an integer.

We assume that $\ve$ has been annotated as it is part of the constraint for an integer type,
and therefore applying $\normalize$ to it does not yield a type error.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{integer}
  \begin{itemize}
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields the expression $\veone$;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields the integer literal for $n$.
  \end{itemize}

  \item \AllApplyCase{top}
  \begin{itemize}
    \item applying $\normalize$ to $\ve$ in $\tenv$ yields the expression $\veone$;
    \item applying $\staticeval$ to $\veone$ in $\tenv$ yields $\top$.
    \item the result is $\Top$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[integer]{
  \normalize(\tenv, \ve) \typearrow \veone\\
  \staticeval(\tenv, \veone) \typearrow \lint(n)
}{
  \normalizetoint(\tenv, \ve) \typearrow n
}
\and
\inferrule[top]{
  \normalize(\tenv, \ve) \typearrow \veone\\
  \staticeval(\tenv, \veone) \typearrow \top
}{
  \normalizetoint(\tenv, \ve) \typearrow \Top
}
\end{mathpar}

\TypingRuleDef{SymDomIsSubset}
\hypertarget{def-symdomissubset}{}
The function
\[
  \symdomissubset(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\symdom}{\vdone} \aslsep
    \overname{\symdom}{\vdtwo}
  ) \aslto
  \overname{\Bool}{\vb}
\]
conservatively tests whether the values represented by the \symbolicdomain\ $\visone$
is a subset of the values represented by the \symbolicdomain\ $\vistwo$ in any environment
consisting of the static environment $\tenv$
(see \secref{subsumptiontesting} for a precise definition).

The test first \emph{overapproximates} $\visone$ by a set of integers $\vsone$.
That is, $\vsone$ represents a superset of the set of numbers represented by $\visone$.
Notice that this can always be done as $\N$ overapproximates any set of integers.
%
Second, the test \emph{underapproximates} $\vistwo$ by a set of integers $\vstwo$.
That is, $\vstwo$ represents a superset of the set of numbers represented by $\visone$.
Notice that this can always be done as the empty set underapproximates any set of integers.
%
The test concludes by checking whether $\vsone$ is a subset of $\vstwo$,
which if true implies that the set of numbers represented by $\visone$ is a subset of the
set of numbers represented by $\vstwo$ (in any environment).
A negative answer on the other hand means that the
test is unable to conclude subsumption.

\hypertarget{def-Under}{}
\hypertarget{def-Over}{}
\hypertarget{def-approximationdirectionterm}{}
In the following, we use the symbol $\Over$ to stand for \emph{overapproximation}
and the symbol $\Under$ to stand for \emph{underapproximation}.
We refer such a symbol as an \approximationdirectionterm.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{right\_top}
  \begin{itemize}
    \item $\vistwo$ is $\Top$;
    \item define $\vb$ as $\True$.
  \end{itemize}

  \item \AllApplyCase{left\_top\_right\_not\_top}
  \begin{itemize}
    \item $\visone$ is $\Top$;
    \item $\vistwo$ is not $\Top$;
    \item define $\vb$ as $\False$.
  \end{itemize}

  \item \AllApplyCase{finite\_finite}
  \begin{itemize}
    \item $\visone$ is a finite set of integers for $\vsone$, that is, $\Finite(\vsone)$;
    \item $\vistwo$ is a finite set of integers for $\vstwo$, that is, $\Finite(\vstwo)$;
    \item define $\vb$ as $\True$ if and only if $\vsone$ is a subset of $\vstwo$ or both sets are equal.
  \end{itemize}

  \item \AllApplyCase{syntax\_syntax}
  \begin{itemize}
    \item $\visone$ is a list of constraints $\csone$, that is, $\FromSyntax(\vsone)$;
    \item $\vistwo$ is a list of constraints $\cstwo$, that is, $\FromSyntax(\vstwo)$;
    \item \ProseapproxconstraintsOver{$\tenv$}{$\csone$}{$\vsone$};
    \item \ProseapproxconstraintsUnder{$\tenv$}{$\cstwo$}{$\vstwo$};
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $\vsone$ is a subset of $\vstwo$}.
  \end{itemize}

  \item \AllApplyCase{finite\_syntax}
  \begin{itemize}
    \item $\visone$ is a finite set of integers for $\vsone$, that is, $\Finite(\vsone)$;
    \item $\vistwo$ is a list of constraints $\cstwo$, that is, $\FromSyntax(\vstwo)$;
    \item \ProseapproxconstraintsUnder{$\tenv$}{$\cstwo$}{$\vstwo$};
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $\vsone$ is a subset of $\vstwo$}.
  \end{itemize}

  \item \AllApplyCase{syntax\_finite}
  \begin{itemize}
    \item $\visone$ is a list of constraints $\csone$, that is, $\FromSyntax(\vsone)$;
    \item $\vistwo$ is a finite set of integers for $\vstwo$, that is, $\Finite(\vstwo)$;
    \item \ProseapproxconstraintsOver{$\tenv$}{$\csone$}{$\vsone$};
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $\vsone$ is a subset of $\vstwo$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[right\_top]{}{
  \symdomissubset(\tenv, \visone, \overname{\Top}{\vistwo}) \typearrow
  \overname{\True}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[left\_top\_right\_not\_top]{
  \vistwo \neq \Top
}{
  \symdomissubset(\tenv, \overname{\Top}{\visone}, \vistwo) \typearrow
  \overname{\False}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[finite\_finite]{}{
  \symdomissubset(\tenv, \overname{\Finite(\vsone)}{\visone}, \overname{\Finite(\vstwo)}{\vistwo}) \typearrow
  \overname{\vsone \subseteq \vstwo}{\vb}
}
\end{mathpar}

% Transliteration comment: instead of the symbol CannotOverApproximate, we use the set of all integers.
% Transliteration comment: the use of constraints_equal is an optimization and is thus not reflected here.
\begin{mathpar}
\inferrule[syntax\_syntax]{
  \approxconstraints(\tenv, \Over, \csone) \typearrow \vsone\\
  \approxconstraints(\tenv, \Under, \cstwo) \typearrow \vstwo
}{
  \symdomissubset(\tenv, \overname{\FromSyntax(\csone)}{\visone}, \overname{\FromSyntax(\cstwo)}{\vistwo}) \typearrow
  \overname{\vsone \subseteq \vstwo}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[finite\_syntax]{
  \approxconstraints(\tenv, \Under, \cstwo) \typearrow \vstwo
}{
  \symdomissubset(\tenv, \overname{\Finite(\vsone)}{\visone}, \overname{\FromSyntax(\cstwo)}{\vistwo}) \typearrow
  \overname{\vsone \subseteq \vstwo}{\vb}
}
\end{mathpar}

\begin{mathpar}
\inferrule[syntax\_finite]{
  \approxconstraints(\tenv, \Over, \csone) \typearrow \vsone
}{
  \symdomissubset(\tenv, \overname{\FromSyntax(\csone)}{\visone}, \overname{\Finite(\vstwo)}{\vistwo}) \typearrow
  \overname{\vsone \subseteq \vstwo}{\vb}
}
\end{mathpar}

\TypingRuleDef{ApproxConstraints}
\hypertarget{def-approxconstraints}{}
The function
\[
\approxconstraints(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\{\Over, \Under\}}{\vapprox} \aslsep
  \overname{\intconstraint^+}{\cs}) \aslto
  \overname{\pow{\Z}}{\vs}
\]
conservatively approximates the non-empty list of constraints $\cs$ by a set of integers $\vs$.
The approximation is over all environments consisting of the static environment $\tenv$.
The approximation is either overapproximation or underapproximation,
based on the \approximationdirectionterm\ $\vapprox$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{over}
  \begin{itemize}
    \item $\vapprox$ is $\Over$;
    \item \Proseapproxconstraint{$\tenv$}{$\vc$}{$\Over$}{$\vs_\vc$}, for every constraint $\vc$ in $\cs$;
    \item \Proseeqdef{$\vs$}{the union of all sets $\vs_\vc$, for every constraint $\vc$ in $\cs$}.
  \end{itemize}

  \item \AllApplyCase{under}
  \begin{itemize}
    \item $\vapprox$ is $\Under$;
    \item \Proseapproxconstraint{$\tenv$}{$\vc$}{$\Under$}{$\vs_\vc$}, for every constraint $\vc$ in $\cs$;
    \item \Proseeqdef{$\vs$}{the union of all sets $\vs_\vc$, for every constraint $\vc$ in $\cs$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[over]{
  \vc \in \cs: \approxconstraint(\tenv, \Over, \vc) \typearrow \vs_\vc
}{
  \approxconstraints(\tenv, \overname{\Over}{\vapprox}, \cs) \typearrow
  \overname{\bigcup_{\vc \in \cs} \vs_\vc}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[under]{
  \vc \in \cs: \approxconstraint(\tenv, \Over, \vc) \typearrow \vs_\vc
}{
  \approxconstraints(\tenv, \overname{\Under}{\vapprox}, \cs) \typearrow
  \overname{\bigcap_{\vc \in \cs} \vs_\vc}{\vs}
}
\end{mathpar}
\CodeSubsection{\ApproxConstraintsBinopBegin}{\ApproxConstraintsBinopEnd}{../Typing.ml}

\TypingRuleDef{ApproxConstraint}
\hypertarget{def-approxconstraint}{}
The function
\[
\approxconstraint(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\{\Over, \Under\}}{\vapprox} \aslsep
  \overname{\intconstraint}{\vc}) \aslto
  \overname{\pow{\Z}}{\vs}
\]
conservatively approximates the constraint $\vc$ by a set of integers $\vs$.
The approximation is over all environments that consist of the static environment $\tenv$.
The approximation is either overapproximation or underapproximation,
based on the \approximationdirectionterm\ $\vapprox$.

In the following inference rules, we use $\leq$ to compare both integers to integers
and integers to infinity symbols. Specifically, the following hold:
$\forall z\in\Z.\ -\infty < z$ and $\forall z\in\Z.\ z < +\infty$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact}
  \begin{itemize}
    \item $\vc$ is an \Proseexactconstraint{\ve};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\ve$}{$\vs$}.
  \end{itemize}

  \item \AllApplyCase{range\_over}
  \begin{itemize}
    \item $\vc$ is a \Proserangeconstraint{\veone}{\vetwo};
    \item \Proseapproxexprmin{$\tenv$}{$\veone$}{$\vzone$};
    \item \Proseapproxexprmax{$\tenv$}{$\vetwo$}{$\vztwo$};
    \item \Proseeqdef{$\vsinterval$}{the set of integers greater or equal to $\vzone$ and
          less than or equal to $\vztwo$};
    \item applying $\approxbottomtop$ to $\vapprox$ yields $\vsbottomtop$;
    \item \Proseeqdef{$\vs$}{$\vsinterval$ if $\vzone$ is less than or equal to $\vztwo$ and $\vsbottomtop$, otherwise}.
  \end{itemize}

  \item \AllApplyCase{range\_under}
  \begin{itemize}
    \item $\vc$ is a \Proserangeconstraint{\veone}{\vetwo};
    \item \Proseapproxexprmax{$\tenv$}{$\veone$}{$\vzone$};
    \item \Proseapproxexprmin{$\tenv$}{$\vetwo$}{$\vztwo$};
    \item \Proseeqdef{$\vsinterval$}{the set of integers greater or equal to $\vzone$ and
          less than or equal to $\vztwo$};
    \item applying $\approxbottomtop$ to $\vapprox$ yields $\vsbottomtop$;
    \item \Proseeqdef{$\vs$}{$\vsinterval$ if $\vzone$ is less than or equal to $\vztwo$ and $\vsbottomtop$, otherwise}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \approxexpr(\tenv, \vapprox, \ve) \typearrow
}{
  \approxconstraint(\tenv, \vapprox, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow \vs
}
\end{mathpar}

% Transliteration note: splitting the case of ranges based on 'approx' to avoid excessive
% use of conditionals in rules (i.e., choice functions).
\begin{mathpar}
\inferrule[range\_over]{
  \approxexprmin(\tenv, \veone) \typearrow \vzone\\
  \approxexprmax(\tenv, \vetwo) \typearrow \vztwo\\
  \vsinterval \eqdef \{ \vz \;|\; \vzone \leq \vz \leq \vztwo \}\\
  \approxbottomtop(\vapprox) \typearrow \vsbottomtop\\
  \vs \eqdef \choice{\vzone \leq \vztwo}{\vsinterval}{\vsbottomtop}
}{
  \approxconstraint(\tenv, \overname{\Over}{\vapprox}, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_under]{
  \approxexprmax(\tenv, \veone) \typearrow \vzone\\
  \approxexprmin(\tenv, \vetwo) \typearrow \vztwo\\
  \vsinterval \eqdef \{ \vz \;|\; \vzone \leq \vz \leq \vztwo \}\\
  \approxbottomtop(\vapprox) \typearrow \vsbottomtop\\
  \vs \eqdef \choice{\vzone \leq \vztwo}{\vsinterval}{\vsbottomtop}
}{
  \approxconstraint(\tenv, \overname{\Under}{\vapprox}, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \vs
}
\end{mathpar}

\TypingRuleDef{ApproxExprMin}
\hypertarget{def-approxexprmin}{}
% Transliteration note: instead of exceptions, I'm using infinity symbols.
The function
\[
\approxexprmin(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  \overname{\Z \cup \{-\infty\}}{\vz}
\]
approximates the minimal integer represented by the expression $\ve$
in any environment consisting of the static environment
$\tenv$. The result, yielded in $\vz$ is either an integer or $-\infty$.

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseapproxexpr{$\tenv$}{$\Over$}{$\ve$}{$\vs$};
  \item \Proseeqdef{$\vz$}{the minimal integer in $\vz$ or $-\infty$ if there is no such integer}.
\end{itemize}

\FormallyParagraph
\hypertarget{def-mininfty}{}
In the following rule, the helper function
\[
\mininfty : \pow{\Z} \aslto \Z \cup \{-\infty\}
\]
returns the minimal integer
for a given set of integers, if there is one, and $-\infty$, otherwise.

\begin{mathpar}
\inferrule{
  \approxexpr(\tenv, \Over, \ve) \typearrow \vs
}{
  \approxexprmin(\tenv, \ve) \typearrow \overname{\mininfty(\vs)}{\vz}
}
\end{mathpar}

\TypingRuleDef{ApproxExprMax}
\hypertarget{def-approxexprmax}{}
The function
\[
\approxexprmax(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  \overname{\Z \cup \{+\infty\}}{\vz}
\]
approximates the maximal integer represented by the expression $\ve$
in any environment consisting of the static environment
$\tenv$. The result, yielded in $\vz$ is either an integer or $+\infty$.

\hypertarget{def-maxinfty}{}
In the following rule, the helper function
\[
\maxinfty : \pow{\Z} \aslto \Z \cup \{+\infty\}
\]
returns the maximal integer
for a given set of integers, if there is one, and $+\infty$, otherwise.

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseapproxexpr{$\tenv$}{$\Over$}{$\ve$}{$\vs$};
  \item \Proseeqdef{$\vz$}{the maximal integer in $\vz$ or $+\infty$ if there is no such integer}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \approxexpr(\tenv, \Over, \ve) \typearrow \vs
}{
  \approxexprmax(\tenv, \ve) \typearrow \overname{\maxinfty(\vs)}{\vz}
}
\end{mathpar}

\TypingRuleDef{ApproxBottomTop}
\hypertarget{def-approxbottomtop}{}
The function
\[
\approxbottomtop(\overname{\{\Under, \Over\}}{\vapprox}) \aslto
  \overname{\pow{\Z}}{\vs}
\]
returns in $\vs$ either the empty set or the set of all integers,
depending on the \approximationdirectionterm\ $\vapprox$.

\ProseParagraph
\ProseEqdef{$\vs$}{the empty set if $\vapprox$ is $\Under$ and the set of all integers
if $\vapprox$ is $\Over$.}

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \approxbottomtop(\vapprox) \typearrow \overname{\choice{\vapprox = \Under}{\emptyset}{\Z}}{\vs}
}
\end{mathpar}

\TypingRuleDef{ApproxExpr}
\hypertarget{def-approxexpr}{}
The function
\[
\approxexpr(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\{\Over, \Under\}}{\vapprox} \aslsep
  \overname{\expr}{\ve}) \aslto
  \overname{\pow{\Z}}{\vs}
\]
conservatively approximates the expression $\ve$ by a set of integers $\vs$
in the static environment $\tenv$.
The approximation is either overapproximation or underapproximation,
based on the \approximationdirectionterm\ $\vapprox$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{literal\_int}
  \begin{itemize}
    \item $\ve$ is a literal expression for the integer $\vz$;
    \item \Proseeqdef{$\vs$}{the singleton set for $\vz$}.
  \end{itemize}

  \item \AllApplyCase{literal\_non\_int}
  \begin{itemize}
    \item $\ve$ is a literal expression for a non-integer value;
    \item applying $\approxbottomtop$ to $\vapprox$ yields $\vs$.
  \end{itemize}

  \item \AllApplyCase{var\_over}
  \begin{itemize}
    \item $\ve$ is a \variableexpression{$\vx$};
    \item $\vapprox$ is $\Over$;
    \item \Prosetypeof{$\tenv$}{$\vx$}{$\vt$};
    \item \Proseapproxtype{$\tenv$}{$\Over$}{$\vt$}{$\vs$}.
  \end{itemize}

  \item \AllApplyCase{var\_under}
  \begin{itemize}
    \item $\ve$ is a \variableexpression{$\vx$};
    \item $\vapprox$ is $\Under$;
    \item \Proseeqdef{$\vs$}{the empty set}.
  \end{itemize}

  \item \AllApplyCase{unop}
  \begin{itemize}
    \item $\ve$ is a \unopexpression{$\op$}{$\vep$};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\vep$}{$\vsp$};
    \item \Proseeqdef{$\vs$}{the set obtained by applying $\unopliterals$ to $\op$ and
      the integer literal for every integer in $\vsp$}.
  \end{itemize}

  \item \AllApplyCase{binop}
  \begin{itemize}
    \item $\ve$ is a \binopexpression{$\op$}{$\veone$}{$\vetwo$};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\veone$}{$\vsone$};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\vetwo$}{$\vstwo$};
    \item \Proseeqdef{$\vs$}{the set obtained by applying $\binopliterals$ to $\op$ and
      every pair of integers from the $\vsone$ and $\vstwo$, respectively,
      and maintaining only the values for which $\binopliterals$ does not produce a type error}.
  \end{itemize}

  \item \AllApplyCase{cond}
  \begin{itemize}
    \item $\ve$ is a \condexpression{any}{$\vetwo$}{$\vethree$};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\vetwo$}{$\vstwo$};
    \item \Proseapproxexpr{$\tenv$}{$\vapprox$}{$\vethree$}{$\vsthree$};
    \item \Proseeqdef{$\vs$}{the union of $\vstwo$ and $\vsthree$ if $\vapprox$ is $\Over$
    and the intersection of $\vstwo$ and $\vsthree$ if $\vapprox$ is $\Under$}.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\ve$ is an expression that is neither of the following types of expressions:
          \literalexpressionterm, \variableexpressionterm, \unopexpressionterm, \binopexpressionterm,
          or a \condexpressionterm;
    \item applying $\approxbottomtop$ to $\vapprox$ yields $\vs$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[literal\_int]{}{
  \approxexpr(\tenv, \vapprox, \overname{\ELInt{\vz}}{\ve}) \typearrow \overname{\{\vz\}}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[literal\_non\_int]{
  \astlabel(\vl) \neq \lint\\
  \approxbottomtop(\vapprox) \typearrow \vs
}{
  \approxexpr(\tenv, \vapprox, \overname{\ELiteral(\vl)}{\ve}) \typearrow \vs
}
\end{mathpar}

In the following inference rule, the application of $\typeof$ is guaranteed not
to result in a type error, since $\symsubsumes$ is only applied to annotated
types.
\begin{mathpar}
\inferrule[var\_over]{
  \typeof(\tenv, \vx) \typearrow \vt\\
  \approxtype(\tenv, \Over, \vt) \typearrow \vs
}{
  \approxexpr(\tenv, \overname{\Over}{\vapprox}, \overname{\EVar(\vx)}{\ve}) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[var\_under]{}{
  \approxexpr(\tenv, \overname{\Under}{\vapprox}, \overname{\EVar(\vx)}{\ve}) \typearrow \overname{\emptyset}{\vs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[unop]{
  \approxexpr(\tenv, \vapprox, \vep) \typearrow \vsp\\
  \vs \eqdef \{ \unopliterals(\op, \lint(\vz)) \;|\; \vz \in \vsp\}
}{
  \approxexpr(\tenv, \overname{\Under}{\vapprox}, \overname{\EUnop(\op, \vep)}{\ve}) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[binop]{
  \approxexpr(\tenv, \vapprox, \veone) \typearrow \vsone\\
  \approxexpr(\tenv, \vapprox, \vetwo) \typearrow \vstwo\\
  {
    \begin{array}{rl}
  \vs \eqdef \{ \vz \not\in \TTypeError \;|\; & \vzone\in\vsone, \vztwo\in\vstwo, \\
    & \binopliterals(\op, \lint(\vzone), \lint(\vztwo)) \typearrow \vz\}
    \end{array}
  }
}{
  \approxexpr(\tenv, \overname{\Under}{\vapprox}, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[cond]{
  \approxexpr(\tenv, \vapprox, \vetwo) \typearrow \vstwo\\
  \approxexpr(\tenv, \vapprox, \vethree) \typearrow \vsthree\\
  \vs \eqdef \choice{\vapprox = \Over}{\vstwo \cup \vsthree}{\vstwo \cap \vsthree}
}{
  \approxexpr(\tenv, \overname{\Under}{\vapprox}, \overname{\ECond(\Ignore, \vetwo, \vethree)}{\ve}) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\ve) \not\in \{\ELiteral, \EVar, \EUnop, \EBinop, \ECond\}\\
  \approxbottomtop(\vapprox) \typearrow \vs
}{
  \approxexpr(\tenv, \overname{\Under}{\vapprox}, \ve) \typearrow \vs
}
\end{mathpar}

\TypingRuleDef{ApproxType}
\hypertarget{def-approxtype}{}
The function
\[
\approxtype(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\{\Over, \Under\}}{\vapprox} \aslsep
  \overname{\ty}{\vt}) \aslto
\overname{\pow{\Z}}{\vs}
\]
conservatively approximates the type $\vt$ by a set of integers $\vs$
in the static environment $\tenv$.
The approximation is either overapproximation or underapproximation,
based on the \approximationdirectionterm\ $\vapprox$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{named}
  \begin{itemize}
    \item $\vt$ is a \namedtype;
    \item \Prosemakeanonymous{$\tenv$}{$\vt$}{$\vtp$};
    \item \Proseapproxtype{$\tenv$}{$\vapprox$}{$\vtp$}{$\vs$}.
  \end{itemize}

  \item \AllApplyCase{int\_wellconstrained}
  \begin{itemize}
    \item $\vt$ is a \wellconstrainedintegertype\ with the list of integer constraints $\cs$;
    \item \Proseapproxconstraints{$\tenv$}{$\vapprox$}{$\cs$}{$\vs$}.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\vt$ is neither a \namedtypeterm\ nor a \wellconstrainedintegertype;
    \item applying $\approxbottomtop$ to $\vapprox$ yields $\vs$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[named]{
  \isnamed(\vt)\\
  \makeanonymous(\tenv, \vt) \typearrow \vtp\\
  \approxtype(\tenv, \vapprox, \vtp) \typearrow \vs
}{
  \approxtype(\tenv, \vapprox, \vt) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_wellconstrained]{
  \vt = \TInt(\wellconstrained(\cs))\\
  \approxconstraints(\tenv, \vapprox, \cs) \typearrow \vs
}{
  \approxtype(\tenv, \vapprox, \vt) \typearrow \vs
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \neg\isnamed(\vt) \land \neg\iswellconstrainedinteger(\vt)\\
  \approxbottomtop(\vapprox) \typearrow \vs
}{
  \approxtype(\tenv, \vapprox, \vt) \typearrow \vs
}
\end{mathpar}

\TypingRuleDef{ConstraintBinop}
\hypertarget{def-constraintbinop}{}
The function
\[
\constraintbinop(
  \overname{\binop}{\op} \aslsep
  \overname{\intconstraint^*}{\csone} \aslsep
  \overname{\intconstraint^*}{\cstwo}
)
\aslto \overname{\constraintkind}{\newcs}
\]
symbolically applies the binary operation $\op$ to the lists of integer constraints $\csone$ and $\cstwo$,
yielding the integer constraints $\vics$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{extremities}
  \begin{itemize}
    \item $\op$ is either $\DIV$, $\DIVRM$, $\MUL$, $\PLUS$, $\MINUS$, $\SHR$, or $\SHL$;
    \item applying $\applybinopextremities$ to every pair of constraints $\csone[\vi]$ and $\cstwo[\vj]$
          where $\vi\in\listrange(\csone)$ and $\vj\in\listrange(\cstwo)$, yields $\vc_{\vi,\vj}$;
    \item define $\newcs$ as the list of constraints $\vc_{\vi,\vj}$, for every
          $\vi\in\listrange(\csone)$ and $\vj\in\listrange(\cstwo)$.
  \end{itemize}

  \item \AllApplyCase{mod}
  \begin{itemize}
    \item $\op$ is $\MOD$;
    \item applying $\constraintmod$ to $\cstwo[\vj]$, for every $\vj\in\listrange(\cstwo)$, yields $\vc_\vj$;
    \item define $\newcs$ as $\vc_\vj$, for every $\vj\in\listrange(\cstwo)$.
  \end{itemize}

  \item \AllApplyCase{pow}
  \begin{itemize}
    \item $\op$ is $\POW$;
    \item applying $\constraintpow$ to every pair of constraints $\csone[\vi]$ and $\cstwo[\vj]$
          where $\vi\in\listrange(\csone)$ and $\vj\in\listrange(\cstwo)$, yields $\vc_{\vi,\vj}$;
    \item define $\newcs$ as the list of constraints $\vc_{\vi,\vj}$, for every
          $\vi\in\listrange(\csone)$ and $\vj\in\listrange(\cstwo)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[extremities]{
  \op \in \{\DIV, \DIVRM, \MUL, \PLUS, \MINUS, \SHR, \SHL\}\\
  {
    \begin{array}{r}
      \vi\in\listrange(\csone): \vj\in\listrange(\cstwo): \\
      \applybinopextremities(\csone[\vi], \cstwo[\vj]) \typearrow \vc_{\vi,\vj}
    \end{array}
  }\\
  \newcs \eqdef [\vi\in\listrange(\csone): \vj\in\listrange(\cstwo): \vc_{\vi,\vj}]
}{
  \constraintbinop(\op, \csone, \cstwo) \typearrow \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[mod]{
  \op = \MOD\\
  \vj\in\listrange(\cstwo): \constraintmod(\cstwo[\vj]) \typearrow \vc_\vj\\
  \newcs = [\vj\in\listrange(\cstwo): \vc_\vj]
}{
  \constraintbinop(\op, \csone, \cstwo) \typearrow \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[pow]{
  \op = \POW\\
  {
    \begin{array}{r}
      \vi\in\listrange(\csone): \vj\in\listrange(\cstwo): \\
      \constraintpow(\csone[\vi], \cstwo[\vj]) \typearrow \vc_{\vi,\vj}
    \end{array}
  }\\
  \newcs \eqdef [\vi\in\listrange(\csone): \vj\in\listrange(\cstwo): \vc_{\vi,\vj}]
}{
  \constraintbinop(\op, \csone, \cstwo) \typearrow \newcs
}
\end{mathpar}
\CodeSubsection{\ConstraintBinopBegin}{\ConstraintBinopEnd}{../Typing.ml}

\TypingRuleDef{ApplyBinopExtremities}
\hypertarget{def-applybinopextremities}{}
The function
\[
\applybinopextremities(
  \overname{\binop}{\op} \aslsep
  \overname{\intconstraint}{\vcone} \aslsep \overname{\intconstraint}{\vctwo}
) \aslto \overname{\intconstraint^*}{\newcs}
\]
yields a list of constraints $\newcs$ for the constraints $\vcone$ and $\vctwo$, which are needed to include
range constraints for cases where the binary operation $\op$ yields a dynamic error.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact\_exact}
  \begin{itemize}
    \item $\vcone$ is a constraint for the expression $\va$;
    \item $\vctwo$ is a constraint for the expression $\vc$;
    \item define $\newcs$ as the list containing the constraint for the binary expression $\AbbrevEBinop{\op}{\va}{\vc}$.
  \end{itemize}

  \item \AllApplyCase{range\_exact}
  \begin{itemize}
    \item $\vcone$ is a range constraint for the expressions $\va$ and $\vb$;
    \item $\vctwo$ is a constraint for the expression $\vc$;
    \item applying $\possibleextremitiesleft$ to $\op$, $\va$, and $\vb$ yields $\extpairs$;
    \item define $\newcs$ as the list containing a constraint $\AbbrevConstraintRange{\AbbrevEBinop{\op}{\vap}{\vc}}{\AbbrevEBinop{\op}{\vbp}{\vc}}$
          for each pair of expressions $(\vap, \vbp)$ in $\extpairs$.
  \end{itemize}

  \item \AllApplyCase{exact\_range}
  \begin{itemize}
    \item $\vcone$ is a constraint for the expression $\va$;
    \item $\vctwo$ is a range constraint for the expressions $\vc$ and $\vd$;
    \item applying $\possibleextremitiesright$ to $\op$, $\vc$, and $\vd$ yields $\extpairs$;
    \item define $\newcs$ as the list containing a constraint $\AbbrevConstraintRange{\AbbrevEBinop{\op}{\va}{\vcp}}{\AbbrevEBinop{\op}{\va}{\vdp}}$
          for each pair of expressions $(\vcp, \vdp)$ in $\extpairs$.
  \end{itemize}

  \item \AllApplyCase{range\_range}
  \begin{itemize}
    \item $\vcone$ is a range constraint for the expressions $\va$ and $\vb$;
    \item $\vctwo$ is a range constraint for the expressions $\vc$ and $\vd$;
    \item applying $\possibleextremitiesright$ to $\op$, $\va$, and $\vb$ yields $\extpairsab$;
    \item applying $\possibleextremitiesright$ to $\op$, $\vc$, and $\vd$ yields $\extpairscd$;
    \item define $\newcs$ as the list containing a constraint $\AbbrevConstraintRange{\AbbrevEBinop{\op}{\vap}{\vcp}}{\AbbrevEBinop{\op}{\vbp}{\vdp}}$
          for each pair of expressions
          $(\vap, \vbp)$ in $\extpairsab$
          and each pair of expressions
          $(\vcp, \vdp)$ in $\extpairscd$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact\_exact]{}{
  {
    \begin{array}{r}
  \applybinopextremities(\op, \overname{\ConstraintExact(\va)}{\vcone}, \overname{\ConstraintExact(\vc)}{\vctwo}) \typearrow \\
  \overname{[ \ConstraintExact(\AbbrevEBinop{\op}{\va}{\vc}) ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_exact]{
  \possibleextremitiesleft(\op, \va, \vb) \typearrow \extpairs\\
  \newcs \eqdef [(\vap, \vbp) \in \extpairs: \AbbrevConstraintRange{\AbbrevEBinop{\op}{\vap}{\vc}}{\AbbrevEBinop{\op}{\vbp}{\vc}}]
}{
  \applybinopextremities(\op, \overname{\ConstraintRange(\va, \vb)}{\vcone}, \overname{\ConstraintExact(\vc)}{\vctwo}) \typearrow
  \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[exact\_range]{
  \possibleextremitiesright(\op, \vc, \vd) \typearrow \extpairs\\
  \newcs \eqdef [(\vcp, \vdp) \in \extpairs: \AbbrevConstraintRange{\AbbrevEBinop{\op}{\va}{\vcp}}{\AbbrevEBinop{\op}{\va}{\vdp}}]
}{
  \applybinopextremities(\op, \overname{\ConstraintExact(\va)}{\vcone}, \overname{\ConstraintRange(\vc, \vd)}{\vctwo}) \typearrow
  \newcs
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_range]{
  \possibleextremitiesleft(\op, \va, \vb) \typearrow \extpairsab\\
  \possibleextremitiesright(\op, \vc, \vd) \typearrow \extpairscd\\
  \newcs \eqdef [(\vap, \vbp) \in \extpairsab, (\vcp, \vdp) \in \extpairscd:
  \AbbrevConstraintRange{\AbbrevEBinop{\op}{\vap}{\vcp}}{\AbbrevEBinop{\op}{\vbp}{\vdp}}]
}{
  \applybinopextremities(\op, \overname{\ConstraintRange(\va, \vb)}{\vcone}, \overname{\ConstraintRange(\vc, \vd)}{\vctwo}) \typearrow
  \newcs
}
\end{mathpar}

\TypingRuleDef{PossibleExtremitiesLeft}
\hypertarget{def-possibleextremitiesleft}{}
The function
\[
\possibleextremitiesleft(
  \overname{\binop}{\op} \aslsep
  \overname{\expr}{\va} \aslsep \overname{\expr}{\vb}
) \aslto \overname{(\expr\times\expr)^*}{\extpairs}
\]
yields a list of pairs of expressions $\extpairs$ given the binary operation $\op$
and pair of expressions $\va$ and $\vb$, which are needed to form constraints
for cases where applying $\op$ to $\va$ and $\vb$ would lead to a dynamic error.

\ProseParagraph
\begin{itemize}
  \item \AllApplyCase{mul}
  \begin{itemize}
    \item $\op$ is $\MUL$;
    \item define $\extpairs$ as the list consisting of $(\va, \va)$, $(\va, \vb)$, $(\vb, \va)$, and $(\vb, \vb)$.
  \end{itemize}

  \item \AllApplyCase{other}
  \begin{itemize}
    \item $\op$ is either $\DIV$, $\DIVRM$, $\SHR$, $\SHL$, $\PLUS$, or $\MINUS$;
    \item define $\extpairs$ as the list consisting of $(\va, \vb)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[mul]{}{
  \possibleextremitiesleft(\overname{\MUL}{\op}, \va, \vb) \typearrow \overname{[(\va, \va), (\va, \vb), (\vb, \va), (\vb, \vb)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \op \in \{\DIV, \DIVRM, \SHR, \SHL, \PLUS, \MINUS\}
}{
  \possibleextremitiesleft(\op, \va, \vb) \typearrow \overname{[(\va, \vb)]}{\extpairs}
}
\end{mathpar}

\TypingRuleDef{PossibleExtremitiesRight}
\hypertarget{def-possibleextremitiesright}{}
The function
\[
\possibleextremitiesright(
  \overname{\binop}{\op} \aslsep
  \overname{\expr}{\vc} \aslsep \overname{\expr}{\vd}
) \aslto \overname{(\expr\times\expr)^*}{\extpairs}
\]
yields a list of pairs of expressions $\extpairs$ given the binary operation $\op$
and pair of expressions $\vc$ and $\vd$, which are needed to form constraints
for cases where applying $\op$ to $\vc$ and $\vd$ would lead to a dynamic error.

\ProseParagraph
\begin{itemize}
  \item \AllApplyCase{plus}
  \begin{itemize}
    \item $\op$ is $\PLUS$;
    \item define $\extpairs$ as the list consisting of $(\vc, \vd)$.
  \end{itemize}

  \item \AllApplyCase{minus}
  \begin{itemize}
    \item $\op$ is $\MINUS$;
    \item define $\extpairs$ as the list consisting of $(\vd, \vc)$.
  \end{itemize}

  \item \AllApplyCase{mul}
  \begin{itemize}
    \item $\op$ is $\MUL$;
    \item define $\extpairs$ as the list consisting of $(\vc, \vc)$, $(\vc, \vd)$, $(\vd, \vc)$, and $(\vd, \vd)$.
  \end{itemize}

  \item \AllApplyCase{shl\_shr}
  \begin{itemize}
    \item $\op$ is either $\SHL$ or $\SHR$;
    \item define $\extpairs$ as the list consisting of $(\vd, \ELInt{0})$ and $(\ELInt{0}, \vd)$.
  \end{itemize}

  \item \AllApplyCase{div\_divrm}
  \begin{itemize}
    \item $\op$ is either $\DIV$ or $\DIVRM$;
    \item define $\extpairs$ as the list consisting of $(\vd, \ELInt{1})$ and $(\ELInt{1}, \vd)$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[plus]{}{
  \possibleextremitiesright(\overname{\PLUS}{\op}, \vc, \vd) \typearrow \overname{[(\vc, \vd)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[minus]{}{
  \possibleextremitiesright(\overname{\MINUS}{\op}, \vc, \vd) \typearrow \overname{[(\vd, \vc)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[mul]{}{
  \possibleextremitiesright(\overname{\MUL}{\op}, \vc, \vd) \typearrow \overname{[(\vc, \vc), (\vc, \vd), (\vd, \vc), (\vd, \vd)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[shl\_shr]{
  \op \in \{\SHL, \SHR\}
}{
  \possibleextremitiesright(\op, \vc, \vd) \typearrow \overname{[(\vd, \ELInt{0}), (\ELInt{0}, \vd)]}{\extpairs}
}
\end{mathpar}

\begin{mathpar}
\inferrule[div\_divrm]{
  \op \in \{\DIV, \DIVRM\}
}{
  \possibleextremitiesright(\op, \vc, \vd) \typearrow \overname{[(\vd, \ELInt{1}), (\ELInt{1}, \vd)]}{\extpairs}
}
\end{mathpar}

\TypingRuleDef{ConstraintMod}
\hypertarget{def-constraintmod}{}
The function
\[
\constraintmod(\overname{\intconstraint}{\vc}) \aslto \overname{\intconstraint}{\newc}
\]
yields a range constraint $\newc$ from $0$ to the expression in $\vc$ that is maximal.
This is needed to apply the modulus operation to a pair of constraints.

\ExampleDef{Ill-typed Modulus Constraint Assignment}
In \listingref{typing-constraintmod}, the assignment to \texttt{z} is illegal, since the type
inferred for \texttt{z} is\\
\verb|integer{0..2}|.

\ASLListing{An ill-typed modulus constraint assignment}{typing-constraintmod}{\typingtests/TypingRule.ConstraintMod.bad.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseeqdef{$\veupper$}{
    $\ve$ if $\vc$ is a single constraint for $\ve$,
    and $\vb$ if $\vc$ is a range constraint for a pair of expressions, the second of which is $\vb$.
  };
  \item \Proseeqdef{$\veminusone$}{the binary expression subtracting $1$ from $\veupper$};
  \item \Proseeqdef{$\newc$}{a range constraint for the literal expression for $0$ for $\veminusone$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
    \veupper \eqdef \begin{cases}
      \ve & \vc = \ConstraintExact(\ve)\\
      \vb & \vc = \ConstraintRange(\Ignore, \vb)
    \end{cases}
  }\\
  \veminusone \eqdef \EBinop(\MINUS, \veupper, \ELInt{1})
}{
  \constraintmod(\vc) \typearrow \overname{\ConstraintRange(\ELInt{0}, \veminusone)}{\newc}
}
\end{mathpar}
\CodeSubsection{\ConstraintModBegin}{\ConstraintModEnd}{../Typing.ml}

\TypingRuleDef{ConstraintPow}
\hypertarget{def-constraintpow}{}
The function
\[
\constraintpow(\overname{\intconstraint}{\vcone} \aslsep \overname{\intconstraint}{\vctwo}) \aslto \overname{\intconstraint^+}{\newcs}
\]
yields a list of range constraints $\newcs$ that are needed to calculate the result of
applying a $\POW$ operation to the constraints $\vcone$ and $\vctwo$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{exact\_exact}
  \begin{itemize}
    \item $\vcone$ is the constraint for the expression $\va$;
    \item $\vcone$ is the constraint for the expression $\vc$;
    \item define $\newcs$ as the list containing the constraint
    for the expression \\ $\EBinop(\POW, \va, \vc)$.
  \end{itemize}

  \item \AllApplyCase{range\_exact}
  \begin{itemize}
    \item $\vcone$ is the range constraint for the expressions $\va$ and $\vb$;
    \item $\vctwo$ is the constraint for the expression $\vc$;
    \item define $\vmac$ as the expression $\EBinop(\POW, \EUnop(\NEG, \va), \vc)$;
    \item define $\newcs$ as the list of the following constraints:
    \begin{itemize}
      \item the range constraint for the literal integer expression for $0$ and the expression
            $\EBinop(\POW, \vb, \vc)$;
      \item the range constraint for the expression $\EUnop(\NEG, \vmac)$ and $\vmac$;
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{exact\_range}
  \begin{itemize}
    \item $\vcone$ is the constraint for the expression $\va$;
    \item $\vctwo$ is the range constraint for the expressions $\Ignore$ and $\vd$;
    \item define $\vmad$ as the expression $\EBinop(\POW, \EUnop(\NEG, \va), \vd)$;
    \item define $\newcs$ as the list of the following constraints:
    \begin{itemize}
      \item the range constraint for the literal integer expression for $0$ and the expression
            $\EBinop(\POW, \va, \vd)$;
      \item the range constraint for the expression $\EUnop(\NEG, \vmad)$ and $\vmad$;
      \item the constraint for the literal integer expression for $1$.
    \end{itemize}
  \end{itemize}

  \item \AllApplyCase{range\_range}
  \begin{itemize}
    \item $\vcone$ is the range constraint for the expressions $\va$ and $\vb$;
    \item $\vctwo$ is the range constraint for the expressions $\Ignore$ and $\vd$;
    \item define $\vmad$ as the expression $\EBinop(\POW, \EUnop(\NEG, \va), \vd)$;
    \item define $\newcs$ as the list of the following constraints:
    \begin{itemize}
      \item the range constraint for the literal integer expression for $0$ and the expression
            $\EBinop(\POW, \vb, \vd)$;
      \item the range constraint for the expression $\EUnop(\NEG, \vmad)$ and $\vmad$;
      \item the constraint for the literal integer expression for $1$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact\_exact]{}{
  {
    \begin{array}{r}
  \constraintpow(\overname{\ConstraintExact(\va)}{\vcone}, \overname{\ConstraintExact(\vc)}{\vctwo}) \typearrow \\
  \overname{[\ \ConstraintExact(\EBinop(\POW, \va, \vc))\ ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_exact]{
  \vmac \eqdef \EBinop(\POW, \EUnop(\NEG, \va), \vc)
}{
  {
    \begin{array}{r}
  \constraintpow(\overname{\ConstraintRange(\va, \vb)}{\vcone}, \overname{\ConstraintExact(\vc)}{\vctwo}) \typearrow \\
  \overname{[
  \AbbrevConstraintRange{\ELInt{0}}{\AbbrevEBinop{\POW}{\vb}{\vc}},\
  \AbbrevConstraintRange{\EUnop(\NEG, \vmac)}{\vmac}
  ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[exact\_range]{
  \vmad \eqdef \EBinop(\POW, \EUnop(\NEG, \va), \vd)
}{
  {
    \begin{array}{r}
  \constraintpow(\overname{\ConstraintExact(\va)}{\vcone}, \overname{\ConstraintRange(\Ignore, \vd)}{\vctwo}) \typearrow \\
  \overname{[
  \AbbrevConstraintRange{\ELInt{0}}{\AbbrevEBinop{\POW}{\va}{\vd}},\
  \AbbrevConstraintRange{\EUnop(\NEG, \vmad)}{\vmad},\
  \AbbrevConstraintExact{\ELInt{1}}
  ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[range\_range]{
  \vmad \eqdef \EBinop(\POW, \EUnop(\NEG, \va), \vd)
}{
  {
    \begin{array}{r}
  \constraintpow(\overname{\ConstraintRange(\va, \vb)}{\vcone}, \overname{\ConstraintRange(\Ignore, \vd)}{\vctwo}) \typearrow \\
  \overname{[
  \AbbrevConstraintRange{\ELInt{0}}{\AbbrevEBinop{\POW}{\vb}{\vd}},\
  \AbbrevConstraintRange{\EUnop(\NEG, \vmad)}{\vmad},\
  \AbbrevConstraintExact{\ELInt{1}}
  ]}{\newcs}
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\ConstraintPowBegin}{\ConstraintPowEnd}{../Typing.ml}
