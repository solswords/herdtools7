\chapter{Expressions\label{chap:Expressions}}

\hypertarget{def-rhsexpression}{}
Expressions calculate values.
Expressions can have side effects and can raise exceptions and, therefore, there are constraints on the evaluation
order and on the side-effects/exceptions to avoid surprising or unpredictable behavior (see \secref{PriorityAndAssociativity}).

Expressions are grammatically derived from $\Nexpr$ and represented as ASTs by $\expr$.
We will often refer to expressions defined in this chapter as \rhsexpressions\ to distinguish them
from \assignableexpressions, which are defined in \chapref{AssignableExpressions}.

\hypertarget{build-expr}{}
The function
\[
  \buildexpr(\overname{\parsenode{\Nexpr}}{\vparsednode}) \;\aslto\; \overname{\expr}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms an expression parse node $\vparsednode$ into an expression AST node $\vastnode$.
\ProseOtherwiseBuildError

All expressions have a unique type (which can be a \tupletypeterm{}).
\hypertarget{def-annotateexpr}{}
The function
\[
  \annotateexpr{\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}}
  \aslto (\overname{\ty}{\vt} \times \overname{\expr}{\newe} \times \overname{\TSideEffectSet}{\vses})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
specifies how to annotate an expression $\ve$ in
an environment \tenv.  The result of annotating the expression
$\ve$ in \tenv\ is the tuple $(\vt, \newe, \vses)$, where $\vt$ is the type inferred
for $\ve$,
$\newe$ is the \typedast\ for $\ve$, also known as the \emph{annotated expression}, and
$\vses$ is the \sideeffectsetterm\ inferred for $\ve$.
\ProseOtherwiseTypeError

The annotation rewrites the input expression in the following case, making the annotation of statements simpler:
variables with constant values are substituted by their constant values.

The relation
\hypertarget{def-evalexpr}{}
\[
  \evalexpr{\overname{\envs}{\env} \aslsep \overname{\expr}{\ve}} \;\aslrel\;
            \Normal((\overname{\vals}{\vv} \times \overname{\XGraphs}{\vg}) \aslsep \overname{\envs}{\newenv}) \cup
            \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TDynError}{\DynErrorConfig}
\]
evaluates the expression $\ve$ in an environment $\env$ and terminates normally with
a \nativevalue{} $\vv$, an \executiongraph{} $\vg$, and a modified environment $\newenv$.
Otherwise, the evaluation terminates abnormally.

\section{Evaluation Order}
It is an error for an expressionâ€™s meaning to rely on evaluation order except that conditional expressions, and uses
of the boolean operators $\Tband$, $\Tbor$, $\Timpl$, are guaranteed to evaluate from left to right.
\identr{XKGC}

An implementation could enforce this rule by performing a global analysis of all functions to determine whether a
function can throw an exception and the set of global variables read and written by a function.
\identi{YMRT}

For any function call $F(e_1,\ldots,e_m)$, tuple $(e_1,\ldots, e_m)$, or operation $e_1 \op e_2$
(with the exception of $\Tband$, $\Tbor$, and$\Timpl$),
it is an error if the subexpressions conflict with each other by:
\begin{itemize}
  \item both writing to the same variable.
  \item one writing to a variable and the other reading from that same variable.
  \item one writing to a variable and the other throwing an exception.
  \item both throwing exceptions.
\end{itemize}
\identi{QJTN}

These conditions are sufficient but not necessary to ensure that evaluation order does not affect the result of an
expression, including any side-effects.
\identi{GFZT}

Conditional expressions and the operations $\Tband$, $\Tbor$, and$\Timpl$ have short-circuit evaluation.
\identi{QRXP}

We now define the syntax, abstract syntax, typing, and semantics of the following kinds of expressions:
\begin{itemize}
  \item Literal expressions (see \secref{LiteralExpressions})
  \item Variable expressions (see \secref{VariablExpressions})
  \item Binary expressions (see \secref{BinaryExpressions})
  \item Unary expressions (see \secref{UnaryExpressions})
  \item Conditional expressions (see \secref{ConditionalExpressions})
  \item Call expressions (see \secref{CallExpressions})
  \item Slicing expressions (see \secref{SlicingExpressions})
  \item Array access expressions (see \secref{ArrayAccessExpressions})
  \item Field reading expressions (see \secref{FieldReadingExpressions})
  \item Multi-field reading expressions (see \secref{MultiFieldReadingExpressions})
  \item Asserting type conversion expressions (see \secref{AssertingTypeConversionExpressions})
  \item Pattern matching expressions (see \secref{PatternMatchingExpressions})
  \item Arbitrary value expressions (see \secref{ArbitraryValueExpressions})
  \item Structured type construction expressions (see \secref{StructuredTypeConstructionExpressions})
  \item Tuple expressions (see \secref{TupleExpressions})
  \item Parenthesized expressions (see \secref{ParenthesizedExpressions})
  \item Array construction expressions (see \secref{ArrayConstructionExpressions})
\end{itemize}

Finally, we define side-effect-free expressions (see \secref{SideEffectFreeExpressions})
and define how to evaluate a list of expressions (see \secref{ExprList}).

\hypertarget{def-literalexpressionterm}{}
\section{Literal Expressions\label{sec:LiteralExpressions}}
A literal expression represents a literal as an expression.

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nvalue &\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ELiteral(\literal) &
\end{flalign*}

\ASTRuleDef{ELit}
\begin{mathpar}
\inferrule{}{
  \buildexpr(\overname{\Nexpr(\punnode{\Nvalue})}{\vparsednode}) \astarrow
  \overname{\ELiteral(\astof{\vvalue})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ELit}
\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ is the literal expression $\vv$;
\item $\vt$ is the type of the literal $\vv$;
\item define $\newe$ as $\ve$;
\item define $\vses$ as the empty set.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateliteral{\tenv, \vv} \typearrow \vt
}{
  \annotateexpr{\tenv, \overname{\ELiteral(\vv)}{\ve}} \typearrow (\vt, \overname{\ELiteral(\vv)}{\newe}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\ELitBegin}{\ELitEnd}{../Typing.ml}

\subsection{Semantics}
\ExampleDef{Evaluation of Literal Expressions}
In \listingref{literalssemantics}, each of the expressions \texttt{3} evaluates to the \nativevalue\ $\nvint(3)$.
\ASLListing{Semantics of literals}{literalssemantics}{\semanticstests/SemanticsRule.Lit.asl}

\SemanticsRuleDef{ELit}
\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ is the literal expression for $\vl$, that is, $\ELiteral(\vl)$
\item $\vv$ is the \nativevalue\ corresponding to $\vl$;
\item $\vg$ is the empty graph, as literals do not yield any Read and Write Effects;
\item $\newenv$ is $\env$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \evalexpr{\env, \overname{\ELiteral(\vl)}{\ve}} \evalarrow \Normal((\overname{\nvliteral{\vl}}{\vv},\overname{\emptygraph}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}
\CodeSubsection{\EvalELitBegin}{\EvalELitEnd}{../Interpreter.ml}

\hypertarget{def-variableexpressionterm}{}
\section{Variable Expressions\label{sec:VariablExpressions}}
A variable expression consists of an identifier for a storage element.

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\ & \Tidentifier &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EVar(\overtext{\identifier}{variable name}) &
\end{flalign*}

\ASTRuleDef{EVAR}
\begin{mathpar}
  \inferrule{}{
  \buildexpr(\overname{\Nexpr(\Tidentifier(\id))}{\vparsednode}) \astarrow
  \overname{\EVar(\id)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EVar}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{local\_constant}
    \begin{itemize}
    \item $\vx$ is bound to the type $\vt$ and local declaration keyword $\LDKConstant$
          via the $\localstoragetypes$ map of the local environment component of $\tenv$;
    \item $\vx$ is bound to the literal $\vv$ via the $\constantvalues$ map of the local environment of $\tenv$;
    \item define $\newe$ as the literal expression for $\vv$, that is $\eliteral{\vv}$;
    \item define $\vses$ as the empty set.
    \end{itemize}

    \item \AllApplyCase{local\_non\_constant}
    \begin{itemize}
    \item $\vx$ is bound to the type $\vt$ and local declaration keyword $k$
          via the \\
          $\localstoragetypes$ map of the local environment component of $\tenv$;
    \item either $k$ is different from $\LDKConstant$ or
          $\vx$ is not bound in the \\
          $\constantvalues$ map of the local environment of $\tenv$;
    \item define $\newe$ as $\ve$;
    \item define $\vses$ as the singleton set for the \ReadLocalTerm\ for $\vx$ the \timeframeterm\ of
          $k$ ($\timeframeofldk$) and the immutability status of $k$ ($\ldkisimmutable$).
    \end{itemize}

    \item \AllApplyCase{global\_constant}
    \begin{itemize}
    \item $\vx$ is not bound via the $\localstoragetypes$ map of the local component of $\tenv$;
    \item $\vx$ is bound to $(\tty, \GDKConstant)$ via the $\globalstoragetypes$ map of the global component of $\tenv$;
    \item $\vx$ is bound to $\vv$ via the $\constantvalues$ map of the global component of $\tenv$;
    \item define $newe$ as the literal expression for $\vv$;
    \item define $\vses$ as the empty set.
    \end{itemize}

    \item \AllApplyCase{global\_non\_constant}
    \begin{itemize}
      \item $\vx$ is not bound via the $\localstoragetypes$ map of the local component of $\tenv$;
      \item $\vx$ is bound to $(\tty, k)$ via the $\globalstoragetypes$ map of the global component of $\tenv$;
      \item either $\vx$ is not bound in the $\constantvalues$ map of the global component of $\tenv$ or $k$ is not $\GDKConstant$;
      \item define $newe$ as $\ve$;
      \item define $\vses$ as the singleton set for the \ReadGlobalTerm\ for $\vx$ the \timeframeterm\ of
            $k$ ($\timeframeofgdk$) and the immutability status of $k$ ($\gdkisimmutable$).
    \end{itemize}

    \item \AllApplyCase{error\_undefined}
    \begin{itemize}
      \item $\vx$ is not bound via the $\localstoragetypes$ map of the local component of $\tenv$;
      \item $\vx$ is not bound via the $\globalstoragetypes$ map of the local component of $\tenv$;
      \item the result is a type error indicating that $\vx$ is an undefined identifier ($\UndefinedIdentifier$).
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[local\_constant]{
  L^\tenv.\localstoragetypes(\vx) = (\vt, \LDKConstant)\\
  L^\tenv.\constantvalues(\vx) = \vv
}{
  \annotateexpr{\tenv, \overname{\EVar(\vx)}{\ve}} \typearrow (\vt, \overname{\eliteral{\vv}}{\newe}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[local\_non\_constant]{
  L^\tenv.\localstoragetypes(\vx) =  (\vt, k) \\
  L^\tenv.\constantvalues(\vx) = \bot \lor k \neq \LDKConstant\\
  \vses \eqdef \{\ \ReadLocal(\vx, \timeframeofldk(k), \ldkisimmutable(k))\  \}
}{
  \annotateexpr{\tenv, \overname{\EVar(\vx)}{\ve}} \typearrow (\vt, \overname{\EVar(\vx)}{\newe}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[global\_constant]{
  L^\tenv.\localstoragetypes(\vx) = \bot \\
  G^\tenv.\globalstoragetypes(\vx) = (\tty, \GDKConstant)\\
  G^\tenv.\constantvalues(\vx) = \vv
}{
  \annotateexpr{\tenv, \overname{\EVar(\vx)}{\ve}} \typearrow (\tty, \overname{\eliteral{\vv}}{\newe}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[global\_non\_constant]{
  L^\tenv.\localstoragetypes(\vx) = \bot \\
  G^\tenv.\globalstoragetypes(\vx) = (\tty, k)\\
  G^\tenv.\constantvalues(\vx) = \bot \lor k \neq \GDKConstant\\
  \vses \eqdef \{\ \ReadGlobal(\vx, \timeframeofgdk(k), \gdkisimmutable(k))\  \}
}{
  \annotateexpr{\tenv, \overname{\EVar(\vx)}{\ve}} \typearrow (\tty, \overname{\EVar(\vx)}{\newe}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[error\_undefined]{
  L^\tenv.\localstoragetypes(\vx) = \bot \\
  G^\tenv.\globalstoragetypes(\vx) = \bot
}{
  \annotateexpr{\tenv,\overname{\EVar(\vx)}{\ve}} \typearrow \TypeErrorVal{\UndefinedIdentifier}
}
\end{mathpar}

\subsubsection{Comments}
Our type system does not currently address assignments of non-constant expressions (for example,
function calls) to global constant variables.
\CodeSubsection{\EUndefIdentBegin}{\EUndefIdentEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{EVar}

\ExampleDef{Evaluation of a Local Variable Expression}
In \listingref{localvarsemantics}, the evaluation of \texttt{x} within \texttt{assert x == 3;}
uses \\ \SemanticsRuleRef{EVar}.LOCAL.
\ASLListing{Semantics of local variables}{localvarsemantics}{\semanticstests/SemanticsRule.ELocalVar.asl}

\ExampleDef{Evaluation of a Global Variable Expression}
In \listingref{globalvarsemantics}, the evaluation of~\texttt{global\_x} within~\texttt{assert global\_x == 3;}
uses the rule \SemanticsRuleRef{EVar}.GLOBAL.
\ASLListing{Semantics of global variables}{globalvarsemantics}{\semanticstests/SemanticsRule.EGlobalVar.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a variable expression, that is, $\EVar(\vx)$;
  \item view $\env$ as an environment where $\denv$ is the dynamic environment;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{local}
    \begin{itemize}
      \item $\vx$ is bound locally in $\env$;
      \item $\vv$ is the value of $\vx$ in the local component of $\env$;
    \end{itemize}

    \item \AllApplyCase{global}
    \begin{itemize}
      \item $\vx$ is bound in the storage map of $\denv$;
      \item $\vv$ is the value of $\vx$ in the global component of $\env$;
    \end{itemize}
  \end{itemize}
  \item $\newenv$ is $\env$;
  \item $\vg$ is the graph containing a single Read Effect for $\vx$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[local]{
  \env \eqname (\Ignore, \denv)\\
  \vx \in \dom(L^\denv)
}{
  \evalexpr{\env, \EVar(\vx)} \evalarrow \Normal((\overname{L^\denv(\vx)}{\vv}, \overname{\ReadEffect(\vx)}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}

\begin{mathpar}
\inferrule[global]{
  \env \eqname (\Ignore, \denv)\\
  \vx \in \dom(G^\denv.\storage)
}{
  \evalexpr{\env, \EVar(\vx)} \evalarrow \Normal((\overname{G^\denv.\storage(\vx)}{\vv}, \overname{\ReadEffect(\vx)}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}
\CodeSubsection{\EvalEVarBegin}{\EvalEVarEnd}{../Interpreter.ml}

\subsubsection{Comments}
When there exists a global variable $\vx$, the type system
forbids having $\vx$ as a local variable.
This is enforced by \TypingRuleRef{LDVar} in the Chapter ``Typing of Local Declarations'',
and
\TypingRuleRef{DeclareGlobalStorage} and \TypingRuleRef{DeclareOneFunc},
both in the Chapter ``Typing of Global Declarations''.

\section{Binary Expressions\label{sec:BinaryExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Nbinop \parsesep \Nexpr &\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EBinop(\binop, \expr, \expr) &
\end{flalign*}

\ASTRuleDef{EBinop}
The following rule constructs a binary expression AST
and checks that a requirement on \emph{associative operators} holds (see \ASTRuleRef{CheckNotSamePrec}).

\begin{mathpar}
  \inferrule{
    \buildexpr(\veone) \astarrow \astversion{\veone} \OrBuildError\\\\
    \buildexpr(\vetwo) \astarrow \astversion{\vetwo} \OrBuildError\\\\
    \checknotsameprec(\astof{\vbinop}, \astversion{\veone}) \astarrow \True \OrBuildError\\\\
    \checknotsameprec(\astof{\vbinop}, \astversion{\vetwo}) \astarrow \True \OrBuildError
  }{
    {
      \begin{array}{r}
  \buildexpr(\overname{\Nexpr(\namednode{\veone}{\Nexpr}, \punnode{\Nbinop}, \namednode{\vetwo}{\Nexpr})}{\vparsednode}) \astarrow\\
  \overname{\EBinop(\astversion{\veone}, \astof{\vbinop}, \astversion{\vetwo})}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\ASTRuleDef{CheckNotSamePrec}
The set of \emph{associative binary operators} consists of the following:
$\BOR$,
$\BAND$,
$\IMPL$,
$\BEQ$,
$\EQOP$,
$\NEQ$,
$\PLUS$,
$\MINUS$,
$\OR$,
$\XOR$,
$\AND$,
$\MUL$,
$\DIV$,
$\DIVRM$,
$\RDIV$,
$\MOD$,
$\SHL$,
$\SHR$,
$\POW$.

\hypertarget{build-binopprec}{}
We define the helper function
\[
  \binopprec(\overname{\binop}{\op}) \aslto \N
\]
which assigns a precedence level to each binary operator $\op$, as defined below:
\begin{mathpar}
\inferrule{}{
  {
  \binopprec(\op) \astarrow
  \begin{cases}
    0 & \text{if }\op \in \{\GT, \GEQ, \LT, \LEQ\}\\
    1 & \text{if }\op \in \{\BOR, \BAND, \IMPL, \BEQ \}\\
    2 & \text{if }\op \in \{\EQOP, \NEQ\}\\
    3 & \text{if }\op \in \{\PLUS, \MINUS, \OR, \XOR, \AND\}\\
    4 & \text{if }\op \in \{\MUL, \DIV, \DIVRM, \RDIV, \MOD, \SHL, \SHR\}\\
    5 & \text{if }\op = \POW\\
  \end{cases}
  }
}
\end{mathpar}

\hypertarget{build-checknotsameprec}{}
The function
\[
\checknotsameprec(\overname{\binop}{\op} \aslsep \overname{\expr}{\ve})
\aslto \{\True\} \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
checks whether the expression AST node $\ve$ is a binary operator of the same
\emph{precedence} as that of the binary operator $\op$. If so, it is considered
an error. Surrounding $\ve$ by parenthesis fixes the error.

For example, \texttt{a + b + c} is considered legal, since the same binary operator (\texttt{+})
is used, whereas \texttt{a + b - c} is considered illegal, since $\PLUS$ and $\MINUS$ have the
same precedence ($3$). To fix this, we can surround one of the subexpressions with parenthesis,
for example: \texttt{(a + b) - c}.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{not\_binop}
  \begin{itemize}
    \item $\ve$ is not a binary operation expression;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{binop}
  \begin{itemize}
    \item $\ve$ is a binary operation expression for the operator $\opp$;
    \item checking whether $\op$ is different from $\opp$ implies that $\op$ and $\opp$ have different precedence levels
          yields $\True$\ProseTerminateAs{\BinopPrecedence}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[not\_binop]{
  \astlabel(\ve) \neq \EBinop
}{
  \checknotsameprec(\op, \ve) \astarrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[binop]{
  \checktrans{\op \neq \opp \Longrightarrow \binopprec(\op) \neq \binopprec(\opp)}{\BinopPrecedence} \checktransarrow \True \OrBuildError
}{
  \checknotsameprec(\op, \overname{\EBinop(\opp, \Ignore, \Ignore)}{\ve}) \astarrow \True
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EBinop}
\ExampleDef{Typing of Binary Expressions}
In \listingref{typing-binoperror},
the expression \texttt{3 DIV 0} results in a type error.
\ASLListing{Evaluating a binary expression resulting in a type error}{typing-binoperror}
{\semanticstests/SemanticsRule.EBinopDIVBackendDefinedError.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a binary operation $\op$ over two expressions $\veone$ and $\vetwo$, that is, \\ $\EBinop(\op, \veone, \vetwo)$;
  \item \Proseannotateexpr{$\tenv$}{$\veone$}{\\ $(\vtone, \veonep, \vsesone)$\ProseOrTypeError};
  \item \Proseannotateexpr{$\tenv$}{$\vetwo$}{\\ $(\vttwo, \vetwop, \vsestwo)$\ProseOrTypeError};
  \item \Proseapplybinoptypes{$\tenv$}{\op}{\vtone}{\vttwo}{$\vt$\ProseOrTypeError};
  \item define $\newe$ as the binary expression $\op$ over $\veonep$ and $\vetwop$;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{ordered}
    \begin{itemize}
      \item $\op$ is one of $\BAND$, $\BOR$, or $\IMPL$;
      \item define $\vses$ as the union of $\vsesone$ and $\vsestwo$.
    \end{itemize}

    \item \AllApplyCase{unordered}
    \begin{itemize}
      \item $\op$ is not one of $\BAND$, $\BOR$, or $\IMPL$;
      \item \Prosenonconflictingunion{consisting of $\vsesone$ and $\vsestwo$}{$\vses$}.
    \end{itemize}
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[ordered]{
  \annotateexpr{\tenv, \veone} \typearrow (\vtone, \veonep, \vsesone) \OrTypeError\\\\
  \annotateexpr{\tenv, \vetwo} \typearrow (\vttwo, \vetwop, \vsestwo) \OrTypeError\\\\
  \applybinoptypes(\tenv, \op, \vtone, \vttwo) \typearrow \vt \OrTypeError\\\\
  \op \in \{\BAND, \BOR, \IMPL\}\\\\
  \commonprefixline\\\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  \annotateexpr{\tenv, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}} \typearrow (\vt, \overname{\EBinop(\op, \veone', \vetwo')}{\newe}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[unordered]{
  \annotateexpr{\tenv, \veone} \typearrow (\vtone, \veonep, \vsesone) \OrTypeError\\\\
  \annotateexpr{\tenv, \vetwo} \typearrow (\vttwo, \vetwop, \vsestwo) \OrTypeError\\\\
  \applybinoptypes(\tenv, \op, \vtone, \vttwo) \typearrow \vt \OrTypeError\\\\
  \op \not\in \{\BAND, \BOR, \IMPL\}\\\\
  \commonprefixline\\\\
  \nonconflictingunion([\vsesone, \vsestwo]) \typearrow \vses \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\EBinop(\op, \veone, \vetwo)}{\ve}} \typearrow (\vt, \overname{\EBinop(\op, \veone', \vetwo')}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\BinopBegin}{\BinopEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{BinopAnd}
\ExampleDef{Evaluation of Binary And Expressions}
In \listingref{andsemantics},
the expression \texttt{FALSE \&\& fail()} evaluates to the value \texttt{FALSE}. Notice that the function \texttt{fail} is never called.
\ASLListing{Semantics of conjunction}{andsemantics}{\semanticstests/SemanticsRule.EBinopAndFalse.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a conjunction over two expressions,
      $\EBinop(\BAND, \veone, \vetwo)$;
\item $C$ is the result of the evaluation of the expression
      \texttt{if e1 then e2 else false} (see \SemanticsRuleRef{ECond}).
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \falsep \eqdef \ELiteral(\lbool(\False))\\
  \evalexpr{\env, \ECond(\veone, \vetwo, \falsep)} \evalarrow C
}{
\evalexpr{\env, \EBinop(\BAND, \veone, \vetwo)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalBinopAndBegin}{\EvalBinopAndEnd}{../Interpreter.ml}

\subsubsection{Comments}
The evaluation via the rule above ensures that $\veone$ is evaluated first and
only if it evaluates to $\True$ is $\vetwo$ evaluated.

\identr{BKNT} % TODO: add table
\identr{XKGC}

It is an error for an expressionâ€™s meaning to rely on evaluation order except
that conditional expressions, and uses of the boolean operators \texttt{\&\&},
\texttt{||},\texttt{-->}, are guaranteed to evaluate from left to right.

\identi{YMRT}

An implementation could enforce this rule by performing a global analysis of
all functions to determine whether a function can throw an exception and the
set of global variables read and written by a function.

\identi{QRXP}
Conditional expressions and the operations \texttt{\&\&}, \texttt{||},
\texttt{-->} provide a short-circuit evaluation mechanism:

% This is related to the note under \identr{LRHD}
\begin{itemize}
\item the first operand of \texttt{if} is always evaluated but only one of the
remaining operands is evaluated;
\item if the first operand of \texttt{and\_bool} is $\False$, then the second operand is not evaluated;
\item if the first operand of \texttt{or\_bool} is $\True$, then the second operand is not evaluated; and,
\item if the first operand of \texttt{implies\_bool} is $\False$, then the
second operand is not evaluated.
\end{itemize}

However, note that relying on this short-circuit evaluation can be confusing
for readers of ASL specifications and as a consequence it is recommended that
an if-statement is used to achieve the same effect.

\SemanticsRuleDef{BinopOr}
\ExampleDef{Evaluation of Binary Or Expressions}
In \listingref{semantics-binopor}, the expression \texttt{(0 == 1) || (1 == 1)} evaluates to the value \True.
\ASLListing{Evaluating a disjunction expression}{semantics-binopor}{\semanticstests/SemanticsRule.EBinopOrTrue.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a disjunction of two expressions, $\EBinop(\BOR, \veone, \vetwo)$;
\item $C$ is the result of the evaluation of
      \texttt{if e1 then true else e2} (see \SemanticsRuleRef{ECond}).
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \truep \eqdef \ELiteral(\lbool(\True))\\
  \evalexpr{\env, \ECond(\veone, \truep, \vetwo)} \evalarrow C
}{
\evalexpr{\env, \EBinop(\BOR, \veone, \vetwo)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalBinopOrBegin}{\EvalBinopOrEnd}{../Interpreter.ml}

The evaluation via the rule above ensures that $\veone$ is evaluated first and only if
it evaluates to $\False$, is $\vetwo$ evaluated.

\subsubsection{Comments}
\identr{BKNT} % TODO: add table
\identr{XKGC}
It is an error for an expressionâ€™s meaning to rely on
evaluation order except that conditional expressions, and uses of the boolean
operators \texttt{\&\&}, \texttt{||}, \texttt{-->}, are guaranteed to evaluate
from left to right.

\identi{YMRT}

An implementation could enforce this rule by performing a global analysis of
all functions to determine whether a function can throw an exception and the
set of global variables read and written by a function.

\identi{QRXP}
Conditional expressions and the operations \texttt{\&\&}, \texttt{||},
\texttt{-->} provide a short-circuit evaluation mechanism:

% This is related to the note under \identr{LRHD}
\begin{itemize}
\item the first operand of \texttt{if} is always evaluated but only one of the
remaining operands is evaluated;
\item if the first operand of \texttt{and\_bool} is $\False$, then the second operand is not evaluated;
\item if the first operand of \texttt{or\_bool} is $\True$, then the second operand is not evaluated; and,
\item if the first operand of \texttt{implies\_bool} is $\False$, then the
second operand is not evaluated.
\end{itemize}

However, note that relying on this short-circuit evaluation can be confusing
for readers of ASL specifications and as a consequence it is recommended that
an if-statement is used to achieve the same effect.

\SemanticsRuleDef{BinopImpl}
\ExampleDef{Evaluation of Implication Expressions}
In \listingref{semantics-binopimpl},
the expression \texttt{(0 == 1) --> (1 == 0)} evaluates to the value \True, according to the definition of implication.
\ASLListing{Evaluating an implication expression}{semantics-binopimpl}{\semanticstests/SemanticsRule.EBinopImplExFalso.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes an implication over two expressions, $\EBinop(\IMPL, \veone, \vetwo)$;
  \item $\ve$ is evaluated as \texttt{if e1 then e2 else true}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \truep \eqdef \ELiteral(\lbool(\True))\\
  \evalexpr{\env, \ECond(\veone, \vetwo, \truep)} \evalarrow C
}{
\evalexpr{\env, \EBinop(\IMPL, \veone, \vetwo)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalBinopImplBegin}{\EvalBinopImplEnd}{../Interpreter.ml}
The evaluation via the rule above ensures that $\veone$ is evaluated first and only if
it evaluates to \True, is $\vetwo$ evaluated.

\lrmcomment{This is related to \identr{BKNT}: add table}

\identi{QRXP}
Conditional expressions and the operations \texttt{\&\&}, \texttt{||},
\texttt{-->} provide a short-circuit evaluation mechanism:

\lrmcomment{This is related to the note under \identr{LRHD}:}
\begin{itemize}
\item the first operand of \texttt{if} is always evaluated but only one of the
remaining operands is evaluated;
\item if the first operand of \texttt{and\_bool} is $\False$, then the second operand is not evaluated;
\item if the first operand of \texttt{or\_bool} is $\True$, then the second operand is not evaluated; and,
\item if the first operand of \texttt{implies\_bool} is $\False$, then the
second operand is not evaluated.
\end{itemize}

However, note that relying on this short-circuit evaluation can be confusing
for readers of ASL specifications and as a consequence it is recommended that
an if-statement is used to achieve the same effect.

\hypertarget{def-binopexpressionterm}{}
\SemanticsRuleDef{Binop}
\ExampleDef{Evaluation of Binary Expressions}
In \listingref{semantics-binopassert},
the expression \texttt{3 + 2} evaluates to the value \texttt{5}.
\ASLListing{Evaluating a binary expression}{semantics-binopassert}{\semanticstests/SemanticsRule.EBinopPlusAssert.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a Binary Operator $\op$ over two expressions, $\EBinop(\op, \veone, \vetwo)$;
  \item the operator $\op$ is not one of $\BAND$, $\BOR$, or $\IMPL$.
        These operators are handled by rules
        \SemanticsRuleRef{BinopAnd},
        \SemanticsRuleRef{BinopOr}, and
        \SemanticsRuleRef{BinopImpl};
  \item the evaluation of the expression $\veone$ in $\env$ is the configuration \\
        $\Normal(\vmone, \envone)$\ProseOrAbnormal;
  \item the evaluation of the expression $\vetwo$ in $\envone$ is the configuration \\
        $\Normal(\vmtwo, \newenv)$\ProseOrAbnormal;
  \item $\vmone$ consists of the value $\vvone$ and the execution graph $\vgone$;
  \item $\vmtwo$ consists of the value $\vvtwo$ and the execution graph $\vgtwo$;
  \item applying the Binary Operator $\op$ to $\vvone$ and $\vvtwo$ results in $\vv$\ProseOrError;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{\op \not\in \{\BAND, \BOR, \IMPL\}\\
  \evalexpr{ \env, \veone} \evalarrow \Normal(\vmone, \envone) \OrAbnormal \\\\
  \evalexpr{ \envone, \vetwo } \evalarrow \Normal(\vmtwo, \newenv) \OrAbnormal \\\\
  \vmone \eqname (\vvone, \vgone) \\
  \vmtwo \eqname (\vvtwo, \vgtwo) \\
  \binoprel(\op, \vvone, \vvtwo) \evalarrow \vv \OrDynError\\\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  \evalexpr{ \env, \overname{\EBinop(\op, \veone, \vetwo)}{\ve} } \evalarrow
  \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalBinopBegin}{\EvalBinopEnd}{../Interpreter.ml}

The rule above applies to many binary operators, including $\EQOP$ (which is used for \texttt{<->}
as well as \texttt{==}).

\subsubsection{Comments}
\lrmcomment{This is related to \identr{BKNT}: add table}

\identr{XKGC}

The semantics takes a semantic transition over the left subexpression before
the right subexpression.

This is an arbitrary choice as the typechecker must ensure that either order
of evaluation of the operands yields the same result.

In other words, it is an error for an expressionâ€™s meaning to rely on
evaluation order except that conditional expressions, and uses of the boolean
operators \texttt{\&\&}, \texttt{||}, \texttt{-->}, are guaranteed to evaluate
from left to right.

\identi{YMRT}

An implementation could enforce this rule by performing a global analysis of
all functions to determine whether a function can throw an exception and the
set of global variables read and written by a function.

\identi{QJTN}

Notice that when one of the subexpressions terminates exceptionally,
the other expression must be side effect-free and non-throwing.

In other words, for any function call \texttt{F (e1, ..., em)}, tuple
\texttt{(e1, ..., em)}, or operation \texttt{e1 op e2} (with the exception of
\texttt{\&\&}, \texttt{||} and \texttt{-->}), it is an error if the
subexpressions conflict with each other by:
\begin{itemize}
\item both writing to the same variable.
\item one writing to a variable and the other reading from that same variable
\item one writing to a variable and the other throwing an exception
\item both throwing exceptions
\end{itemize}

\identi{GFZT}
These conditions are sufficient but not necessary to ensure that evaluation
order does not affect the result of an expression, including any side-effects.

\hypertarget{def-unopexpressionterm}{}
\section{Unary Expressions\label{sec:UnaryExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nunop \parsesep \Nexpr &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EUnop(\unop, \expr) &
\end{flalign*}

\ASTRuleDef{EUnop}
\begin{mathpar}
  \inferrule{
    \buildexpr(\vexpr) \astarrow \astversion{\vexpr} \OrBuildError
  }{
  \buildexpr(\overname{\Nexpr(\punnode{\Nunop}, \vexpr : \Nexpr)}{\vparsednode}) \astarrow
  \overname{\EUnop(\astof{\vunop}, \astversion{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{Unop}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a unary operation $\op$ over an expression $\vep$, that is $\EUnop(\op, \vep)$;
  \item annotating $\vep$ in $\tenv$ yields $(\vtpp, \vepp, \vses)$\ProseOrTypeError;
  \item checking compatibility of $\op$ with $\vtpp$ as per \TypingRuleRef{ApplyUnopType} yields $\vt$\ProseOrTypeError;
  \item define $\newe$ as $\op$ over $\vepp$, that is, $\EUnop(\op, \vepp)$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\vtpp, \vepp, \vses) \OrTypeError\\\\
  \applyunoptype(\tenv, \op, \vtpp) \typearrow \vt \OrTypeError
}{
  \annotateexpr{\tenv, \EUnop(\op, \vep)} \typearrow (\vt, \EUnop(\op, \vepp), \vses)
}
\end{mathpar}
\CodeSubsection{\UnopBegin}{\UnopEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{Unop}
\ExampleDef{Evaluation of a Unary Operation Expression}
In \listingref{semantics-unopassert},
the expression \texttt{NOT '1010'} evaluates to the value \texttt{'0101'}.
\ASLListing{Evaluating a unary operation expression}{semantics-unopassert}{\semanticstests/SemanticsRule.EUnopAssert.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a unary operator $\op$ over an expression, $\EUnop(\op, \veone)$;
\item the evaluation of the expression $\veone$ in $\env$ yields \\ $\Normal((\vvone, \vg), \newenv)$\ProseOrAbnormal;
\item applying the unary operator $\op$ to $\vvone$ is $\vv$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{ \env, \veone} \evalarrow \Normal((\vvone,\vg), \newenv) \OrAbnormal\\\\
  \unoprel(\op, \vvone) \evalarrow \vv
}
{
  \evalexpr{ \env, \EUnop(\op, \veone) } \evalarrow
  \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalUnopBegin}{\EvalUnopEnd}{../Interpreter.ml}

\hypertarget{def-conditionexpressionterm}{}
\section{Conditional Expressions\label{sec:ConditionalExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Tif \parsesep \Nexpr \parsesep \Tthen \parsesep \Nexpr \parsesep \Neelse &\\
\Neelse \derives\ & \Telse \parsesep \Nexpr &\\
|\ & \Telseif \parsesep \Nexpr \parsesep \Tthen \parsesep \Nexpr \parsesep \Neelse &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ECond(\overtext{\expr}{condition}, \overtext{\expr}{then}, \overtext{\expr}{else})
\end{flalign*}

\ASTRuleDef{ECond}
\begin{mathpar}
  \inferrule{
    \buildexpr(\vcondexpr) \astarrow \astversion{\vcondexpr} \OrBuildError\\\\
    \buildexpr(\vthenexpr) \astarrow \astversion{\vthenexpr} \OrBuildError\\\\
    \buildeelse(\veelse) \astarrow \astversion{\veelse} \OrBuildError\\\\
  }{
    {
      \begin{array}{r}
  \buildexpr\left(\overname{\Nexpr\left(
    \begin{array}{l}
    \Tif, \namednode{\vcondexpr}{\Nexpr}, \Tthen, \\
    \wrappedline\ \namednode{\vthenexpr}{\Nexpr}, \veelse: \Neelse
    \end{array}
    \right)}{\vparsednode}\right) \astarrow\\
  \overname{\ECond(\astversion{\vcondexpr}, \astversion{\vthenexpr}, \astversion{\veelse})}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\ASTRuleDef{EElse}
\hypertarget{build-eelse}{}
The function
\[
  \buildeelse(\overname{\parsenode{\Nfieldassign}}{\vparsednode}) \;\aslto\; \overname{\expr}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[else]{}{
  \buildeelse(\Neelse(\Telse, \punnode{\Nexpr})) \astarrow
  \overname{\astof{\vexpr}}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[else\_if]{
  \buildexpr(\vcondexpr) \astarrow \astversion{\vcondexpr} \OrBuildError\\\\
  \buildexpr(\vthenexpr) \astarrow \astversion{\vthenexpr} \OrBuildError
}{
  {
    \begin{array}{r}
  \buildeelse\left(\Neelse\left(
    \begin{array}{l}
    \Telseif, \namednode{\vcondexpr}{\Nexpr},  \\
    \wrappedline\ \Tthen, \namednode{\vthenexpr}{\Nexpr}, \punnode{\Neelse}
  \end{array}
    \right)\right) \astarrow\\
  \overname{\ECond(\astversion{\vcondexpr}, \astversion{\vthenexpr}, \astof{\veelse})}{\vastnode}
\end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ECond}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a conditional expression with condition $\econd$ with two options $\etrue$ and $\efalse$;
  \item annotating $\econd$ in $\tenv$ results in $(\tcond, \econdp, \vsescond)$\ProseOrTypeError;
  \item annotating $\etrue$ in $\tenv$ results in $(\ttrue, \etruep, \vsestrue)$\ProseOrTypeError;
  \item annotating $\efalse$ in $\tenv$ results in $(\tfalse, \efalsep, \vsesfalse)$;
  \item obtaining the lowest common ancestor of $\ttrue$ and $\tfalse$ results in $\vt$\ProseOrTypeError;
  \item $\newe$ is the condition $\econdp$ with two options $\etruep$ and $\efalsep$, that is, $\ECond(\econdp, \etruep, \efalsep)$;
  \item define $\vses$ as the union of $\vsescond$, $\vsestrue$, and $\vsesfalse$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \econd} \typearrow (\tcond, \econd', \vsescond) \OrTypeError\\\\
  \annotateexpr{\tenv, \etrue} \typearrow (\ttrue, \etrue', \vsestrue) \OrTypeError\\\\
  \annotateexpr{\tenv, \efalse} \typearrow (\tfalse, \efalse', \vsesfalse) \OrTypeError\\\\
  \lca(\ttrue, \tfalse) \typearrow \vt \OrTypeError\\\\
  \vses \eqdef \vsescond \cup \vsestrue \cup \vsesfalse
}{
  {
    \begin{array}{r}
  \annotateexpr{\ECond(\econd, \etrue, \efalse)} \typearrow \\
  (\vt, \ECond(\econdp, \etruep, \efalsep), \vses)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\ECondBegin}{\ECondEnd}{../Typing.ml}
\identr{XZVT}

\subsection{Semantics}
\SemanticsRuleDef{ECond}
\ExampleDef{Evaluation of Conditional Expressions}
In \listingref{semantics-econdfalse},
the expression \texttt{if FALSE then Return42() else 3} evaluates to the value \texttt{3}.
\ASLListing{Evaluating a conditional expression yielding the result of the \texttt{else} subexpression}
{semantics-econdfalse}{\semanticstests/SemanticsRule.ECondFalse.asl}

\ExampleDef{Evaluation of a Non-deterministic Conditional Expression}
In \listingref{semantics-econdarbitrary},
the expression \texttt{if ARBITRARY: boolean then 3 else Return42()} will
evaluate to either \texttt{3} or \texttt{Return42()}, depending on the
(non-deterministic) result of \\
\texttt{ARBITRARY: boolean}.
\ASLListing{Evaluating a conditional expression with non-determinic choice}{semantics-econdarbitrary}
{\semanticstests/SemanticsRule.ECondARBITRARY3or42.asl}

% Transliteration note: the code uses an optimized semantics for the case where
% true and false sub-expressions do not contain function calls. Since this is an
% optimization, we do not document it.
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a conditional expression $\econd$ with two options $\veone$ and $\vetwo$,
        that is, $\ECond(\econd, \veone, \vetwo)$;
  \item the evaluation of the conditional expression $\econd$ in $\env$ yields \\
        $\Normal(\mcond, \envone)$\ProseOrAbnormal;
  \item $\mcond$ consists of a native Boolean for $\vb$ and execution graph $\vgone$;
  \item $\vep$ is $\veone$ if $\vb$ is $\True$ and $\vetwo$ otherwise;
  \item the evaluation of $\vep$ in $\envone$ yields $\Normal((\vvtwo, \vgtwo), \newenv)$\ProseOrAbnormal;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \econd} \evalarrow \Normal(\mcond, \envone) \OrAbnormal\\\\
  \mcond \eqname (\nvbool(\vb), \vgone)\\
  \vep \eqdef \choice{\vb}{\veone}{\vetwo}\\\\
  \evalexpr{\envone, \vep} \evalarrow \Normal((\vv, \vgtwo), \newenv)  \OrAbnormal\\\\
  \vg \eqdef \ordered{\vgone}{\aslctrl}{\vgtwo}
}{
  \evalexpr{\env, \overname{\ECond(\econd, \veone, \vetwo)}{\ve}} \evalarrow
  \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalECondBegin}{\EvalECondEnd}{../Interpreter.ml}

\subsubsection{Comments}
\identr{YCDB}

A conditional expression evaluates to its \texttt{then} expression if the
condition expression evaluates to $\True$. If the condition expression
evaluates to $\False$ each \texttt{elsif} condition expression is evaluated
sequentially until an \texttt{elsif} condition expression evaluates to $\True$;
the conditional expression evaluates to the corresponding \texttt{elsif}
expression. If no \texttt{elsif} expression evaluates to $\True$ the
conditional expression evaluates to the \texttt{else} expression.

\hypertarget{def-callexpressionterm}{}
\section{Call Expressions\label{sec:CallExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Ncall &
\end{flalign*}

\begin{flalign*}
\Ncall \derives \
     & \Tidentifier \parsesep \PlistZero{\Nexpr} &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \ClistOne{\Nexpr} \parsesep \Trbrace &\\
  |\ & \Tidentifier \parsesep \Tlbrace \parsesep \ClistOne{\Nexpr} \parsesep \Trbrace \parsesep \PlistZero{\Nexpr} &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ECall(\call) &
\end{flalign*}

\begin{flalign*}
\call \derives\ &
{
\left\{
  \begin{array}{rcl}
 \callname &:& \Strings, \\
 \callparams &:& \expr, \\
 \callargs &:& \expr, \\
 \callcalltype &:& \subprogramtype
\end{array}
\right\}
} &
\end{flalign*}

\ASTRuleDef{Call}
\hypertarget{build-call}{}
\begin{mathpar}
\inferrule{
  \buildplist[\buildexpr](\vargs) \astarrow \vargasts
}{
  \buildcall(\overname{\Ncall(\Tidentifier(\id), \namednode{\vargs}{\PlistZero{\Nexpr}})}{\vparsednode}) \astarrow \\
  { \overname{\left\{
      \begin{array}{rcl}
        \callname &:& \id,\\
        \callparams &:& \emptylist,\\
        \callargs &:& \vargasts,\\
        \callcalltype &:& \STFunction
      \end{array}
    \right\}}{\vastnode} }
}
\and
\inferrule{
  \buildlist[\buildexpr](\vparams) \astarrow \astversion{\vparams} \\
}{
  \buildcall(\overname{\Ncall(\Tidentifier(\id), \Tlbrace, \namednode{\vparams}{\ClistOne{\Nexpr}}, \Trbrace)}{\vparsednode}) \astarrow \\
  { \overname{\left\{
      \begin{array}{rcl}
              \callname &:& \id,\\
              \callparams &:& \astversion{\vparams},\\
              \callargs &:& \emptylist,\\
              \callcalltype &:& \STFunction
      \end{array}
    \right\}}{\vastnode} }
}
\and
\inferrule{
  \buildplist[\buildexpr](\vargs) \astarrow \vargasts \\
  \buildlist[\buildexpr](\vparams) \astarrow \astversion{\vparams} \\
}{
  \buildcall(\overname{\Ncall(\Tidentifier(\id), \Tlbrace, \namednode{\vparams}{\ClistOne{\Nexpr}}, \Trbrace, \namednode{\vargs}{\PlistZero{\Nexpr}})}{\vparsednode}) \astarrow \\
  { \overname{\left\{
      \begin{array}{rcl}
              \callname &:& \id,\\
              \callparams &:& \astversion{\vparams},\\
              \callargs &:& \vargasts,\\
              \callcalltype &:& \STFunction
      \end{array}
    \right\}}{\vastnode} }
}
\end{mathpar}

\ASTRuleDef{SetCallType}
\hypertarget{def-setcalltype}{}
Above, $\STFunction$ is inserted as a default call type for any parsed $\call$.
The helper function
\[
  \setcalltype(\overname{\call}{\vcall} \aslsep \overname{\subprogramtype}{\calltype}) \aslto \overname{\call}{\vcallp}
\]
changes the call type of $\vcall$ to $\calltype$.

\begin{mathpar}
\inferrule{}{
  \setcalltype(\vcall, \calltype) \aslto
  \overname{\vcall[\callcalltype\mapsto\calltype]}{\vcallp}
}
\end{mathpar}

\ASTRuleDef{ECall}
\begin{mathpar}
\inferrule{}{
  \buildexpr(\overname{\Nexpr(\punnode{\Ncall})}{\vparsednode}) \astarrow
  \overname{\ECall(\astof{\vcall})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ECall}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a call to a subprogram, that is, $\ECall(\vcall)$;
  \item applying $\annotatecall$ to $\vcall$ and in $\tenv$
        annotates the call of the subprogram in $\tenv$ as a function (see Chapter~\ref{chap:SubprogramCalls})
        and yields $(\vcallp, \langle \vt \rangle, \vses)$\ProseOrTypeError.
  \item $\newe$ is the call using $\vcallp$, that is, $\ECall(\vcallp)$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatecall(\vcall) \typearrow (\vcallp, \langle \vt \rangle, \vses) \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\ECall(\vcall)}{\ve}} \typearrow (\vt, \overname{\ECall(\vcallp)}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\ECallBegin}{\ECallEnd}{../Typing.ml}
\identd{CFYP} \identr{BQJG}

\subsection{Semantics}
\SemanticsRuleDef{ECall}
\ExampleDef{Evaluation of Call Expressions}
In \listingref{semantics-ecall},
the expression \texttt{Return42()} evaluates to the value \texttt{42} because the
subprogram \texttt{Return42()} is implemented to return the value \texttt{42}.
\ASLListing{Evaluating a call expression}{semantics-ecall}{\semanticstests/SemanticsRule.ECall.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a subprogram call, $\ECall(\vcall)$;
  \item the evaluation of that subprogram call in $\env$ is either
  $\Normal(\vms, \newenv)$\ProseOrAbnormal;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{single\_returned\_value}
    \begin{itemize}
      \item $\vms$ consists of a single returned value $(\vv,\vg)$,
      which goes into the output configuration $\Normal((\vv, \vg), \newenv)$.
    \end{itemize}

    \item \AllApplyCase{multiple\_returned\_values}
    \begin{itemize}
      \item $\vms$ consists of a list of returned value $(\vv_i,\vg_i)$, for $i=1..k$;
      \item $\vg$ is the parallel composition of $\vg_i$, for $i=1..k$;
      \item $\vv$ is the \nativevalue\  vector of values $\vv_i$, for $i=1..k$;
      \item the resulting configuration is $\Normal((\vv, \vg), \newenv)$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[single\_returned\_value]{
  \evalcall{\env, \vcall.\name, \vcall.\params, \vcall.\args} \evalarrow \Normal(\vms, \newenv) \OrAbnormal\\
  \vms \eqname [(\vv, \vg)]
}{
  \evalexpr{\env, \ECall(\vcall)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[multiple\_returned\_values]{
  \evalcall{\env, \vcall.\callname, \vcall.\callparams, \vcall.\callargs} \evalarrow \Normal(\vms, \newenv) \OrAbnormal\\
  \vms \eqname [i=1..k: (\vv_i, \vg_i)]\\
  \vg \eqdef \vg_1 \parallelcomp \ldots \parallelcomp \vg_k \\
  \vv \eqdef \nvvector{\vv_{1..k}}
}{
  \evalexpr{\env, \ECall(\vcall)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalECallBegin}{\EvalECallEnd}{../Interpreter.ml}

\hypertarget{def-sliceexpressionterm}{}
\section{Slicing Expressions\label{sec:SlicingExpressions}}
This section details the high-level form of the syntax and abstract syntax of slicing expressions,
and defines the semantics of bitvector slices.
The details of the various types of bitvector slices is deferred to \chapref{BitvectorSlicing}.

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\ & \Nexpr \parsesep \Nslices &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ESlice(\expr, \slice^{*}) &
\end{flalign*}

\ASTRuleDef{ESlice}
\begin{mathpar}
\inferrule{
  \buildexpr(\vexpr) \astarrow \astversion{\vexpr} \OrBuildError\\\\
  \buildslice(\vslice) \astarrow \astversion{\vslice} \OrBuildError
}{
  \buildexpr(\overname{\Nexpr(\vexpr: \Nexpr, \vslice: \Nslice)}{\vparsednode}) \astarrow
  \overname{\ESlice(\astversion{\vexpr}, \astversion{\vslice})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ESlice}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$, that is, \\
        $\ESlice(\vep, \slices)$;
  \item annotating the expression $\vep$ in $\tenv$ yields $(\tep,\vepp, \vsesone)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\tep$ in $\tenv$ yields $\structtep$\ProseOrTypeError;
  \item $\structtep$ is either a bitvector or an integer;
  \item checking that $\slices$ is not empty yields $\True$\ProseTerminateAs{\BadSlices};
  \item annotating $\slices$ in $\tenv$ yields $(\slicesp, \vsestwo)$\ProseOrTypeError;
  \item obtaining the width of $\slices$ in $\tenv$ via $\sliceswidth$ yields $\vw$\ProseOrTypeError;
  \item $\vt$ is the bitvector type of width $\vw$, that is, $\TBits(\vw, \emptylist)$;
  \item define $\newe$ as the slicing of expression $\vepp$ by the slices $\slicesp$, that is, \\
        $\ESlice(\vepp, \slicesp)$;
  \item define $\vses$ as the union of $\vsesone$ and $\vsestwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\tep, \vepp, \vsesone) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \structtep \OrTypeError\\\\
  \astlabel(\structtep) \in \{\TInt, \TBits\}\\
  \checktrans{\slices \neq \emptylist}{\BadSlices} \typearrow \True \OrTypeError\\\\
  \annotateslices(\tenv, \slices) \typearrow (\slicesp, \vsestwo) \OrTypeError\\\\
  \sliceswidth(\tenv, \slices) \typearrow \vw \OrTypeError\\\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  \annotateexpr{\tenv, \overname{\ESlice(\vep, \slices)}{\ve}} \typearrow
  (\overname{\TBits(\vw, \emptylist)}{\vt}, \overname{\ESlice(\vepp, \slicesp)}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\ESliceBegin}{\ESliceEnd}{../Typing.ml}
\subsubsection{Comments}
The width of \slices\ might be a symbolic expression if one of the
widths references a \texttt{let} identifier with a non-compile-time-constant
initializer expression.
\identi{MJWM}

\TypingRuleDef{ESliceError}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the slicing of expression $\vep$ by the slices $\slices$;
  \item $(\tep,\vepp)$ is the result of annotating the expression $\vep$ in $\tenv$;
  \item $\tep$ has the structure $\vtp$;
  \item $\vtp$ is neither an integer type or a bitvector type;
  \item the result is an error indicating that the type of $\vep$ is inappropriate for slicing.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\tep, \vepp) \OrTypeError\\\\
  \tstruct(\tenv, \tep) \typearrow \vtp\\
  \astlabel(\vtp) \not\in \{\TInt, \TBits\}
}{
  \annotateexpr{\tenv, \overname{\ESlice(\vep, \slices)}{\ve}} \typearrow \TypeErrorVal{\BadSlices}
}
\end{mathpar}
\CodeSubsection{\ESliceError}{\ESliceErrorEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{ESlice}
\subsubsection{Evaluation of Slicing Expressions}
In \listingref{semantics-eslice},
the expression \texttt{'11110000'[6:3]} evaluates to the value \texttt{'1110'}.
\ASLListing{Evaluating a slice expression}{semantics-eslice}{\semanticstests/SemanticsRule.ESlice.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a slicing expression, $\ESlice(\ebv, \slices)$;
\item the evaluation of $\ebv$ in $\env$ yields $\Normal(\mbv, \envone)$\ProseOrAbnormal;
\item the evaluation of $\slices$ in $\env$ yields $\Normal(\mpositions, \newenv)$\ProseOrAbnormal;
\item $\mpositions$ consists of $\positions$ --- all the indices that need to be added to the
resulting bitvector --- and the execution graph $\vgone$;
\item reading from $\vbv$ as a bitvector at the indices indicated by $\positions$
      (see \SemanticsRuleRef{ReadFromBitvector}) results in the bitvector $\vv$,
      which concatenates all of the values from the indicates indices\ProseOrError;
\item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \ebv} \evalarrow \Normal(\mbv, \envone)  \OrAbnormal\\\\
  \mbv \eqname (\vbv,\vgone) \\
  \evalslices(\envone, \slices) \evalarrow \Normal(\mpositions, \newenv)  \OrAbnormal \\
  \mpositions \eqname (\positions, \vgtwo) \\
  \readfrombitvector(\vbv, \positions) \evalarrow \vv \OrDynError\\\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  \evalexpr{\env, \ESlice(\ebv, \slices)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalESliceBegin}{\EvalESliceEnd}{../Interpreter.ml}

\hypertarget{def-getarrayexpressionterm}{}
\hypertarget{def-getenumarrayexpression}{}
\section{Array Access Expressions\label{sec:ArrayAccessExpressions}}
This section details the syntax, abstract syntax, semantics, and typing of array read expressions.
In the untyped AST, a read from either an integer-indexed array or an enumeration-indexed arrays is represented
the same way. They type system infers the kind of array and outputs a typed AST node differentiating
the two kinds of arrays, either a $\EGetArray$ or a $\EGetEnumArray$, via \TypingRuleRef{EGetArray}.
The semantics utilizes a rule matching the corresponding type of array ---
\SemanticsRuleRef{EGetArray} for integer-indexed arrays and
\SemanticsRuleRef{EGetEnumArray} for enumeration-indexed arrays.

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\ & \Nexpr \parsesep \Tllbracket \parsesep \Nexpr \parsesep \Trrbracket &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EGetArray(\expr, \expr) &
\end{flalign*}

\ASTRuleDef{EGetArray}
\begin{mathpar}
\inferrule{
  \buildexpr(\veone) \astarrow \astversion{\veone} \OrBuildError\\\\
  \buildexpr(\vetwo) \astarrow \astversion{\vetwo} \OrBuildError
}{
  \buildexpr(\overname{\Nexpr(\namednode{\veone}{\Nexpr}, \Tllbracket, \namednode{\vetwo}{\Nexpr}, \Trrbracket)}{\vparsednode}) \astarrow
  \overname{\EGetArray(\astversion{\veone}, \astversion{\vetwo})}{\vastnode}
}
\end{mathpar}

\TypingRuleDef{EGetArray}
\hypertarget{def-arrayaccess}{}
\begin{definition}[Array Access]
We refer to a right-hand-side expression of the form \texttt{b[[i]]},
where $b, i$ are subexpressions, as an \arrayaccess\ expression.
We refer to $b$ and $i$ as the \emph{base}
and the $\emph{index}$ subexpressions, respectively.
\end{definition}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the \arrayaccess{} expression with base $\ebase$ and index $\eindex$;
  \item \Proseannotateexpr{$\tenv$}{$\ebase$}{\\ $(\tbase,\ebasep, \vsesbase)$}\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\tbase$ in $\tenv$ yields $\tanonbase$\ProseOrTypeError;
  \item checking whether $\tanonbase$ is an array type yields $\True$\ProseOrTypeError;
  \item view $\tanonbase$ as the array type with size expression $\size$ and element type $\telem$,
        that is, $\TArray(\size, \telem)$;
  \item applying $\annotategetarray$ to $(\size, \telem)$ and \\
        $(\ebasep, \vsesbase, \eindex)$ yields
        $(\vt, \newe, \vses)$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ebase} \typearrow (\tbase, \ebasep, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbase) \typearrow \tanonbase \OrTypeError\\\\
  \checktrans{\astlabel(\tanonbase) = \TArray}{ExpectedArrayType} \typearrow \True \OrTypeError\\\\
  \tanonbase \eqname \TArray(\size, \telem)\\
  {
    \begin{array}{r}
  \annotategetarray(\tenv, (\size, \telem), (\ebasep, \vsesbase, \eindex)) \typearrow \\ (\vt, \newe, \vses)
    \end{array}
  }
}{
  \annotateexpr{\tenv, \overname{\EGetArray(\ebase, \eindex)}{\ve}} \typearrow (\vt, \newe, \vses)
}
\end{mathpar}
\CodeSubsection{\EGetArrayBegin}{\EGetArrayEnd}{../Typing.ml}

\TypingRuleDef{AnnotateGetArray}
\hypertarget{def-annotategetarray}{}
The helper function
\[
\begin{array}{r}
\annotategetarray(
  \overname{\staticenvs}{\tenv} \aslsep
  (\overname{\expr}{\size} \times \overname{\ty}{\telem}) \aslsep
  (\overname{\expr}{\ebase} \times \overname{\TSideEffectSet}{\vsesbase} \times \overname{\expr}{\eindex})
)
\aslto \\
(\overname{\ty}{\vt} \times \overname{\expr}{\newe} \times \overname{\TSideEffectSet}{\vses})
\end{array}
\]
annotates an array access expression with the following elements:
$\size$ is the expression representing the array size,
$\telem$ is the type of array elements,
$\ebase$ is the annotated expression for the array base,
$\eindex$ is the index expression.
The function returns the type of the annotated expression in $\vt$,
the annotated expression $\newe$, and the inferred \sideeffectdescriptorterm\ $\vses$.

\ProseParagraph
\AllApply
\begin{itemize}
  \item \Proseannotateexpr{$\tenv$}{$\eindex$}{(\tindexp, \eindexp, \vsesindex)}\ProseOrTypeError;
  \item applying $\typeofarraylength$ to $\size$, to obtain the type of the array length, yields
        $\wantedtindex$;
  \item checking that $\tindexp$ \typesatisfies\ $\wantedtindex$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item \Prosenonconflictingunion{$\vsesindex$ and $\vsesbase$}{$\vses$};
  \item \Proseeqdef{$\newe$}{
    an access to an integer-indexed array for $\ebase$ and $\eindexp$, that is, $\EGetArray(\ebase, \eindexp)$ if $\size$ is an integer-typed array index,
    and an access to an enumeration-indexed array for $\ebase$ and $\eindexp$, that is,\\
    $\EGetEnumArray(\ebase, \eindexp)$ if $\size$ is an enumeration-typed array index.
  }
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \eindex} \typearrow (\tindexp, \eindexp, \vsesindex) \OrTypeError\\\\
  \typeofarraylength(\size) \typearrow \wantedtindex\\
  \checktypesat(\tenv, \tindexp, \wantedtindex) \typearrow \True \OrTypeError\\\\
  \nonconflictingunion([\vsesindex, \vsesbase]) \typearrow \vses \OrTypeError\\\\
  {
    \newe \eqdef \begin{cases}
      \EGetArray(\ebase, \eindexp)     & \text{if }\astlabel(\size) = \ArrayLengthExpr\\
      \EGetEnumArray(\ebase, \eindexp) & \text{if }\astlabel(\size) = \ArrayLengthEnum
    \end{cases}
  }
}{
  {
  \begin{array}{r}
  \annotategetarray(\tenv, (\size, \telem), (\ebase, \vsesbase, \eindex)) \typearrow\\
  (\overname{\telem}{\vt}, \newe, \vses)
  \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\AnnotateGetArrayBegin}{\AnnotateGetArrayEnd}{../Typing.ml}

\SemanticsRuleDef{EGetArray}
\ExampleDef{Evaluation of Array Reading Expressions}
In \listingref{semantics-egetarray},
the expression \verb|my_array[[2]]| appearing in the assertion evaluates to the value \texttt{42} since the element
indexed by \texttt{2} in \texttt{my\_array} is \texttt{42}.
\ASLListing{Evaluating an array access expression}{semantics-egetarray}{\semanticstests/SemanticsRule.EGetArray.asl}

\ExampleDef{Evaluation of an Illegal Array Read}
In \listingref{semantics-egetarrayerror}.
evaluating the array access expression \verb|my_array[[3]]| results in a dynamic error,
since we are trying to access index \texttt{3} of an array
which has indexes \texttt{0}, \texttt{1} and \texttt{2} only.
\ASLListing{Evaluating an illegal array access}{semantics-egetarrayerror}{\semanticstests/SemanticsRule.EGetArrayTooSmall.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes an array access expression, $\EGetArray(\earray, \eindex)$;
  \item the evaluation of $\earray$ in $\env$ is $\Normal(\marray, \envone)$\ProseOrAbnormal;
  \item the evaluation of $\eindex$ in $\env$ is  $\Normal(\mindex, \newenv)$\ProseOrAbnormal
  \item $\marray$ consists of the native vector $\varray$ and execution graph $\vgone$;
  \item $\mindex$ consists of the native integer $\vindex$ and execution graph $\vgtwo$;
  \item $\vindex$ is the native integer for $\vi$;
  \item evaluating the value at index $\vi$ of $\varray$ is $\vv$;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \earray} \evalarrow \Normal(\marray, \envone)  \OrAbnormal\\
  \evalexpr{\envone, \eindex} \evalarrow \Normal(\mindex, \newenv)  \OrAbnormal\\
  \marray \eqname (\varray, \vgone)\\
  \mindex \eqname (\vindex, \vgtwo)\\
  \vindex \eqname \nvint(\vi)\\
  \getindex(\vi, \varray) \evalarrow \vv\\
  \vg \eqdef \vgone \parallelcomp \vgtwo\\
}{
  \evalexpr{\env, \EGetArray(\earray, \eindex)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetArrayBegin}{\EvalEGetArrayEnd}{../Interpreter.ml}

\SemanticsRuleDef{EGetEnumArray}
\ExampleDef{Evaluation of Reading from an Enumeration-indexed Array}
In \listingref{semantics-egetenumarray},
the enumeration-typed array \texttt{Arr} is accessed for reading and writing
with indices taken from the \enumerationtypeterm{} \texttt{Enum}.
\ASLListing{Evaluating an access to an enumeration-indexed array}{semantics-egetenumarray}
{\semanticstests/SemanticsRule.EGetEnumArray.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes an array access expression, $\EGetArray(\earray, \eindex)$;
  \item the evaluation of $\earray$ in $\env$ is $\Normal(\marray, \envone)$\ProseOrAbnormal;
  \item the evaluation of $\eindex$ in $\env$ is  $\Normal(\mindex, \newenv)$\ProseOrAbnormal
  \item $\marray$ consists of the native value $\varray$ and execution graph $\vgone$;
  \item $\mindex$ consists of the native value $\vindex$ and execution graph $\vgtwo$;
  \item $\vindex$ is the native literal for the label $\vl$;
  \item accessing the field $\vl$ of $\varray$, which is a native record value, yields $\vv$;
  \item $\vg$ is the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \earray} \evalarrow \Normal(\marray, \envone)  \OrAbnormal\\
  \evalexpr{\envone, \eindex} \evalarrow \Normal(\mindex, \newenv)  \OrAbnormal\\
  \marray \eqname (\varray, \vgone)\\
  \mindex \eqname (\vindex, \vgtwo)\\
  \vindex \eqname \nvlabel(\vl)\\
  \getfield(\vl, \varray) \evalarrow \vv\\
  \vg \eqdef \vgone \parallelcomp \vgtwo\\
}{
  \evalexpr{\env, \EGetEnumArray(\earray, \eindex)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetEnumArrayBegin}{\EvalEGetEnumArrayEnd}{../Interpreter.ml}

\hypertarget{def-getfieldexpressionterm}{}
\section{Field Reading Expressions\label{sec:FieldReadingExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Tdot \parsesep \Tidentifier&
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EGetField(\overtext{\expr}{record}, \overtext{\identifier}{field name}) &
\end{flalign*}

\ASTRuleDef{EGetField}
\begin{mathpar}
  \inferrule{
    \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError
  }{
  \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tdot, \Tidentifier(\id))}{\vparsednode}) \astarrow
  \overname{\EGetField(\astversion{\ve}, \id)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EGetRecordField}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a \structuredtype\ with fields $\fields$;
  \item the field $\fieldname$ is associated with the type $\vt$ in $\fields$
  \item define $\newe$ as the access of field $\fieldname$ on the record or exception object $\vetwo$, that is, $\EGetField(\vetwo, \fieldname)$;
  \item define $\vses$ as $\vsesone$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo \eqname L(\fields)\\
  L \in \{\TRecord, \TException\}\\
  \assocopt(\fields, \fieldname) \typearrow \langle \vt\rangle
}{
  {
    \begin{array}{r}
      \annotateexpr{\tenv, \EGetField(\veone, \fieldname)} \typearrow \\
      (\vt, \EGetField(\vetwo, \fieldname), \overname{\vsesone}{\vses})
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\EGetRecordFieldBegin}{\EGetRecordFieldEnd}{../Typing.ml}

\TypingRuleDef{EGetBadRecordField}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a \structuredtype\ with fields $\fields$;
  \item the field $\fieldname$ is not associated with any type in $\fields$
  \item the result is a type error indicating the missing field.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo \eqname L(\fields)\\
  L \in \{\TRecord, \TException\}\\
  \assocopt(\fields, \fieldname) \typearrow \None
}{
  \annotateexpr{\tenv, \EGetField(\veone, \fieldname)} \typearrow \TypeErrorVal{\BadField}
}
\end{mathpar}
\CodeSubsection{\EGetBadRecordFieldBegin}{\EGetBadRecordFieldEnd}{../Typing.ml}

\TypingRuleDef{EGetBadBitField}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item the field $\fieldname$ is not found in $\bitfields$
  \item the result is a type error indicating the missing field.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo \eqname \TBits(\Ignore, \bitfields)\\
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \None
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow \TypeErrorVal{\BadField}
}
\end{mathpar}
\CodeSubsection{\EGetBadBitFieldBegin}{\EGetBadBitFieldEnd}{../Typing.ml}

\TypingRuleDef{EGetBitField}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$, that is, \\ $\BitFieldSimple(\Ignore, \slices)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vt, \newe, \vses)$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo \eqname \TBits(\Ignore, \bitfields)\\
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \langle \BitFieldSimple(\Ignore, \slices)\rangle\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr{\tenv, \vethree} \typearrow (\vt, \newe, \vses) \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow (\vt, \newe, \vses)
}
\end{mathpar}
\CodeSubsection{\EGetBitFieldBegin}{\EGetBitFieldEnd}{../Typing.ml}

\TypingRuleDef{EGetBitFieldNested}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$ and nested bitfields $\bitfieldsp$, that is,
        $\BitFieldNested(\Ignore, \slices, \bitfieldsp)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vtefour, \newe, \vsesnew)$\ProseOrTypeError;
  \item $\vtefour$ is a bitvector type with length expression $\width$, that is, $\TBits(\width, \Ignore)$;
  \item define $\vt$ as a bitvector type with length expression $\width$ and bitfields $\bitfieldsp$;
  \item define $\vses$ as $\vsesnew$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo \eqname \TBits(\Ignore, \bitfields)\\\\
  {
    \begin{array}{r}
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \\ \langle \BitFieldNested(\Ignore, \slices, \bitfieldsp)\rangle
    \end{array}
  }\\\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr{\tenv, \vethree} \typearrow (\vtefour, \newe, \vsesnew) \OrTypeError\\\\
  \vtefour \eqname \TBits(\width, \Ignore)\\
  \vt \eqdef \TBits(\width, \bitfieldsp)
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow (\vt, \newe, \overname{\vses}{\vsesnew})
}
\end{mathpar}
\CodeSubsection{\EGetBitFieldNestedBegin}{\EGetBitFieldNestedEnd}{../Typing.ml}

\TypingRuleDef{EGetBitFieldTyped}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is a bitvector type with bit fields $\bitfields$;
  \item $\fieldname$ is declared in $\bitfields$ with a slice list $\slices$ and typed bitfield with type $\vt$ that is,
        $\BitFieldType(\Ignore, \slices, \vt)$;
  \item $\vethree$ denotes the slicing of the expression \vetwo\ by the slices $\slices$, that is, \\ $\ESlice(\vetwo, \slices)$;
  \item annotating $\vethree$ in $\tenv$ yields $(\vtefour, \newe, \vsesnew)$\ProseOrTypeError;
  \item determining whether $\vtefour$ \typesatisfies\ $\vt$ yields $\True$\ProseOrTypeError;
  \item define $\vses$ as $\vsesnew$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo \eqname \TBits(\Ignore, \bitfields)\\
  \findbitfieldopt(\bitfields, \fieldname) \typearrow \langle \BitFieldType(\Ignore, \slices, \vt)\rangle\\
  \vethree \eqdef \ESlice(\vetwo, \slices)\\
  \annotateexpr{\tenv, \vethree} \typearrow (\vtefour, \newe, \vsesnew) \OrTypeError\\\\
  \checktypesat(\tenv, \vtefour, \vt) \typearrow \True \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow (\vt, \newe, \overname{\vses}{\vsesnew})
}
\end{mathpar}
\CodeSubsection{\EGetBitFieldTypedBegin}{\EGetBitFieldTypedEnd}{../Typing.ml}

\TypingRuleDef{EGetTupleItem}
\newcommand\itemprefix[0]{\texttt{item}}
In the following rule definition, we use $\itemprefix$ to stand
for its verbatim string.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is \tupletypeterm{} with list of types $\tys$, that is, $\TTuple(\tys)$;
  \item $\fieldname$ is an identifier consisting of the prefix \itemprefix{} and the suffix $\num$;
  \item $\num$ is lexically an integer token with the integer value $\vindex$;
  \item determining whether $\vindex$ is between $0$ and the number of types in $\tys$, inclusive, yields $\True$\ProseOrTypeError;
  \item $\vt$ is the type at position $\vindex$ of $\tys$;
  \item $\newe$ is the expression for obtaining the item at index $\vindex$ from the expression $\vetwo$, that is, $\EGetItem(\vetwo, \vindex)$;
  \item define $\vses$ as $\vsesone$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \vtetwo \eqname \TTuple(\tys)\\
  \fieldname = \itemprefix \stringconcat \num\\
  \num \in \Lang(\REintlit)\\
  \decimaltolit(\num) = \Tintlit(\vindex)\\
  \checktrans{0 \leq \vindex \leq \listlen{\tys}}{\BadTupleIndex} \checktransarrow \True \OrTypeError\\\\
  \vt \eqdef \tys[\vindex]\\
  \newe \eqdef \EGetItem(\vetwo, \vindex)
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow (\vt, \newe, \overname{\vsesone}{\vses})
}
\end{mathpar}
\CodeSubsection{\EGetTupleItemBegin}{\EGetTupleItemEnd}{../Typing.ml}

\TypingRuleDef{EGetBadField}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the access of field $\fieldname$ in the value represented by the expression $\veone$, that is, $\EGetField(\veone, \fieldname)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vteone, \vetwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vteone$ yields $\vtetwo$\ProseOrTypeError;
  \item $\vtetwo$ is neither one of the following types: record, exception, bitvector, or tuple;
  \item the result is an error indicating that the type of $\veone$ is inappropriate for accessing the field $\fieldname$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vteone, \vetwo, \vsesone) \OrTypeError\\\\
  \makeanonymous(\tenv, \vteone) \typearrow \vtetwo \OrTypeError\\\\
  \astlabel(\vtetwo) \not\in \{\TRecord, \TException, \TBits, \TTuple\}
}{
  \annotateexpr{\tenv, \overname{\EGetField(\veone, \fieldname)}{\ve}} \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}
\CodeSubsection{\EGetBadFieldBegin}{\EGetBadFieldEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{EGetField}
\ExampleDef{Evaluation of a Field Read Expression}
In \listingref{semantics-egetfield},
the expression \verb|my_record.a| evaluates to the value \texttt{3}.
\ASLListing{Evaluating a field access expression}{semantics-egetfield}{\semanticstests/SemanticsRule.ERecord.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a field access expression, $\EGetField(\erecord, \fieldname)$;
\item the evaluation of $\erecord$ in $\env$ is $\Normal((\vrecord, \vg), \newenv)$\ProseOrAbnormal;
\item $\vv$ is the value mapped by $\fieldname$ in the native record $\vrecord$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \erecord} \evalarrow \Normal((\vrecord, \vg), \newenv)  \OrAbnormal\\
  \getfield(\fieldname, \vrecord) \evalarrow \vv
}{
  \evalexpr{\env, \EGetField(\erecord, \fieldname)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetFieldBegin}{\EvalEGetFieldEnd}{../Interpreter.ml}

\SemanticsRuleDef{EGetItem}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is an expression for accessing the component given by the index $\vindex$ of the tuple
        given by the expression $\etuple$, that is, $\EGetItem(\etuple, \vindex)$;
  \item evaluating the expression $\etuple$ yields $\Normal((\vvtuple, \vg), \newenv)$\ProseOrAbnormal;
  \item accessing the native tuple value $\vvtuple$ at index $\vindex$ via $\getindex$, yields
        the native value $\vv$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \etuple} \evalarrow \Normal((\vvtuple, \vg), \newenv) \OrAbnormal\\\\
  \getindex(\vvtuple, \vindex) \evalarrow \vv
}{
  \evalexpr{\env, \overname{\EGetItem(\etuple, \vindex)}{\ve}} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetTupleItemBegin}{\EvalEGetTupleItemEnd}{../Interpreter.ml}

\hypertarget{def-getfieldsexpressionterm}{}
\section{Multi-field Reading Expressions\label{sec:MultiFieldReadingExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Tdot \parsesep \Tlbracket \parsesep \ClistOne{\Tidentifier} \parsesep \Trbracket &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EGetFields(\overtext{\expr}{record}, \overtext{\identifier^{*}}{field names}) &
\end{flalign*}

\ASTRuleDef{EGetFields}
\begin{mathpar}
  \inferrule{
    \buildclist[\buildidentity](\vids) \astarrow \vidasts\\
    \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError
  }{
    {
      \begin{array}{r}
  \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tdot, \Tlbracket, \namednode{\vids}{\ClistOne{\Tidentifier}}, \Trbracket)}{\vparsednode}) \astarrow\\
  \overname{\EGetFields(\astversion{\ve}, \vidasts)}{\vastnode}
      \end{array}
    }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EGetFields}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is a multi-field access expression for the base expression $\ebase$ and list of fields $\vfields$,
        that is, $\EGetFields(\ebase, \vfields)$;
  \item \Proseannotateexpr{$\tenv$}{$\ebase$}{\\ $(\tbaseannot, \vetwo, \vsesbase)$}\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\tbaseannot$ in $\tenv$ yields \\
        $\tbaseannotanon$\ProseOrTypeError;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{bits}
    \begin{itemize}
      \item $\tbaseannotanon$ is a bitvector type with list of bitfields $\vbitfields$\ProseOrTypeError;
      \item applying $\findbitfieldsslices$ to each field name $\name$ and list of bitfields $\vbitfields$ in $\vfields$ yields \\
            $\vslices_\name$\ProseOrTypeError;
      \item define $\veslice$ as the slicing expression for $\ebase$ and lists of slices $\vslices_\name$, for each $\name$ in $\vfields$;
      \item \Proseannotateexpr{$\tenv$}{$\veslice$}{\\ $(\vt, \newe, \vses)$}\ProseOrTypeError.
    \end{itemize}

    \item \AllApplyCase{record}
    \begin{itemize}
      \item $\tbaseannotanon$ is a record type with list of fields $\vbasefields$\ProseOrTypeError;
      \item applying $\getbitfieldwidth$ to $\vf$ in $\vbasefields$ and $\vbasefields$, for each $\vf$ in $\vbasefields$, in $\tenv$ yields $\ewidth_\vf$\ProseOrTypeError;
      \item applying $\widthplus$ to the list of expressions $\ewidth_\vf$,
            for each $\vf$ in $\vbasefields$, yields $\veslicewidth$\ProseOrTypeError;
      \item define $\vt$ as the bitvector type with width $\veslicewidth$ and an empty list of bitfields;
      \item define $\ve$ as the multi-field access for $\ebaseannot$ and list of fields \\
            $\vbasefields$;
      \item define $\vses$ as $\vsesbase$.
    \end{itemize}

    \item \AllApplyCase{error}
    \begin{itemize}
      \item $\tbaseannotanon$ is neither a bitvector type nor a record type;
      \item the result is a type error indicating an unexpected type.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[bits]{
  \annotateexpr{\tenv, \ebase} \typearrow (\tbaseannot, \ebaseannot, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbaseannot) \typearrow \TBits(\Ignore, \vbitfields) \OrTypeError\\\\
  \name\in\vfields: \findbitfieldsslices(\name, \vbitfields) \typearrow \vslices_\name \OrTypeError\\\\
  \veslice \eqdef \ESlice(\ebase, [\name\in\vfields: \vslices_\name])\\
  \annotateexpr{\tenv, \veslice} \typearrow (\vt, \newe, \vses) \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\EGetFields(\ebase, \vfields)}{\ve}} \typearrow (\vt, \newe, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[record]{
  \annotateexpr{\tenv, \ebase} \typearrow (\tbaseannot, \ebaseannot, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbaseannot) \typearrow \TRecord(\vbasefields) \OrTypeError\\\\
  \vf \in \vbasefields: \getbitfieldwidth(\tenv, \vf, \tfields) \typearrow \ewidth_\vf \OrTypeError\\\\
  \widthplus(\tenv, [\vf \in \vbasefields: \ewidth_\vf]) \typearrow \veslicewidth\OrTypeError
}{
  {
  \begin{array}{r}
    \annotateexpr{\tenv, \overname{\EGetFields(\ebase, \vfields)}{\ve}} \typearrow \\
    (\overname{\TBits(\veslicewidth, \emptylist)}{\vt}, \overname{\EGetFields(\ebaseannot, \vfields)}{\newe}, \overname{\vsesbase}{\vses})
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \annotateexpr{\tenv, \veone} \typearrow (\tbaseannot, \ebaseannot, \Ignore) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbaseannot) \typearrow \tbaseannotanon \OrTypeError\\\\
  \astlabel(\tbaseannotanon) \not\in \{\TBits, \TRecord\}
}{
  \annotateexpr{\tenv, \overname{\EGetFields(\veone, \vfields)}{\ve}} \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}
\CodeSubsection{\EGetFieldsBegin}{\EGetFieldsEnd}{../Typing.ml}

\TypingRuleDef{FindBitFieldsSlices}
\hypertarget{def-findbitfieldsslices}{}
% Transliteration note: The implementation returns an optional, but all of its uses raise a type error if the result is None.
The helper function
\[
  \findbitfieldsslices(\overname{\identifier}{\name} \aslsep \overname{\bitfield^*}{\vbitfields})
  \aslto \overname{\slice^*}{\vslices} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the slices associated with the bitfield named $\name$ in the list of bitfields $\vbitfields$
in $\vslices$.
\ProseOtherwiseTypeError

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{found}
  \begin{itemize}
    \item $\vbitfields$ is a list with \head\ $\vfield$ and \tail\ $\vbitfieldsone$;
    \item applying $\bitfieldgetname$ to $\vfield$ yields $\name$;
    \item applying $\bitfieldgetslices$ to $\vfield$ yields $\vslices$.
  \end{itemize}

  \item \AllApplyCase{tail}
  \begin{itemize}
    \item $\vbitfields$ is a list with \head\ $\vfield$ and \tail\ $\vbitfieldsone$;
    \item applying $\bitfieldgetname$ to $\vfield$ yields $\namep$, which is different to $\name$;
    \item applying $\findbitfieldsslices$ to $\name$ and $vbitfieldsone$ yields $\vslices$\ProseOrTypeError.
  \end{itemize}

  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vbitfields$ is an empty list;
    \item the result is a type error indicating that a bitfield named $\name$ does not exist in $\vbitfields$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[found]{
  \bitfieldgetname(\vfield) \typearrow \name\\
  \bitfieldgetslices(\vfield) \typearrow \vslices
}{
  \findbitfieldsslices(\name, \overname{[\vfield] \concat \vbitfieldsone}{\vbitfields}) \typearrow \vslices
}
\end{mathpar}

\begin{mathpar}
\inferrule[tail]{
  \bitfieldgetname(\vfield) \typearrow \namep\\
  \namep \neq \name\\
  \findbitfieldsslices(\name, \vbitfieldsone) \typearrow \vslices \OrTypeError
}{
  \findbitfieldsslices(\name, \overname{[\vfield] \concat \vbitfieldsone}{\vbitfields}) \typearrow \vslices
}
\end{mathpar}

\begin{mathpar}
\inferrule[empty]{}{
  \findbitfieldsslices(\name, \overname{\emptylist}{\vbitfields}) \typearrow \TypeErrorVal{\BadField}
}
\end{mathpar}

\TypingRuleDef{GetBitfieldWidth}
\hypertarget{def-getbitfieldwidth}{}
The helper function
\[
  \getbitfieldwidth(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{\field^*}{\tfields})
  \aslto \overname{\expr}{\ewidth} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the expression $\ewidth$ that describes the width of the bitfield named $\name$
in the list of fields $\tfields$.
\ProseOtherwiseTypeError

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{okay}
  \begin{itemize}
    \item applying $\assocopt$ to find the type associated with $\name$ in $\tfields$ yields the type $\vt$;
    \item applying $\getbitvectorwidth$ to $\vt$ in $\tenv$ yields $\ewidth$.
  \end{itemize}

  \item \AllApplyCase{error}
  \begin{itemize}
    \item applying $\assocopt$ to find the type associated with $\name$ in $\tfields$ yields $\None$;
    \item the result is a type error indicating that $\name$ is not associated with any field in $\tfields$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \assocopt(\name, \tfields) \typearrow \langle\vt\rangle\\
  \getbitvectorwidth(\tenv, \vt) \typearrow \ewidth
}{
  \getbitfieldwidth(\tenv, \name, \tfields) \typearrow \ewidth
}
\end{mathpar}

\begin{mathpar}
\inferrule[error]{
  \assocopt(\name, \tfields) \typearrow \None
}{
  \getbitfieldwidth(\tenv, \name, \tfields) \typearrow \TypeErrorVal{\BadField}
}
\end{mathpar}

\TypingRuleDef{WidthPlus}
\hypertarget{def-widthplus}{}
% NOTE: the implementation handles just two expressions, here we fold over a list.
The helper function
\[
  \widthplus(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr^*}{\exprs}) \typearrow \overname{\expr}{\ewidth}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
generates the expression $\ewidth$, which represents the summation of all expressions in the list $\exprs$,
normalized in the static environment $\tenv$.
\ProseOrTypeError

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\exprs$ is an empty list;
    \item $\ewidth$ is the literal expression for $0$.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\exprs$ is the list with \head\ $\ve$ and \tail\ $\exprsone$;
    \item applying $\widthplus$ to $\exprsone$ yields $\ewidthone$;
    \item applying $\normalize$ to the binary operation for $\PLUS$ and $\ve$ and $\ewidthone$ yields $\ewidth$\ProseOrTypeError.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \widthplus(\tenv, \overname{\emptylist}{\exprs}) \typearrow \overname{\ELInt{0}}{\ewidth}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \widthplus(\exprsone) \typearrow \ewidthone\\
  \normalize(\tenv, \EBinop(\PLUS, \ve, \ewidthone)) \typearrow \ewidth \OrTypeError
}{
  \widthplus(\tenv, \overname{[\ve] \concat \exprsone}{\exprs}) \typearrow \ewidth
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{EGetfields}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is the multi-field access expression for the expression $\erecord$ and list of field names
        $\vfieldnames$;
  \item evaluating the expression $\erecord$ in $\env$ yields $((\vrecord, \vg), \newenv)$\ProseOrAbnormal;
  \item obtaining the value associated with the field $\fieldname$ in $\vv$, for each $\fieldname$ in $\vfieldnames$,
        yields $\vv_\fieldname$;
  \item define $\vv$ as the concatenation of $\vv_\fieldname$, for each $\fieldname$ in $\vfieldnames$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \erecord} \evalarrow ((\vrecord, \vg), \newenv) \OrAbnormal\\\\
  \fieldname\in\vfieldnames: \getfield(\fieldname, \vv) \evalarrow \vv_\fieldname\\
  \concatbitvectors([\fieldname\in\vfieldnames: \vv_\fieldname]) \typearrow \vv
}{
  \evalexpr{\env, \overname{\EGetFields(\erecord, \vfieldnames)}{\ve}} \evalarrow
  ((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEGetFieldsBegin}{\EvalEGetFieldsEnd}{../interpreter.ml}

\hypertarget{def-atceexpressionterm}{}
\section{Asserting Type Conversion Expressions\label{sec:AssertingTypeConversionExpressions}}
\identi{TCST}
The rule about domains in the definitions of subtype-satisfaction and
type-satisfaction means that it is illegal to use the unconstrained integer
where a constrained integer is expected. An asserting type conversion (ATC) can
be used to overcome this.

\identi{CGRH}
An ATC allows code to explicitly mark places where uses of constrained types
would otherwise be a static typechecking error. The intent is to reduce the
incidence of unintended errors by making such uses fail typechecking unless
the asserting type conversion is provided.

\identr{WZVX}
Note that ATCs are execution-time checks. An execution-time check is a
condition that is evaluated during the evaluation of an execution-time
initializer expression or subprogram. If the condition evaluates to $\False$ it
is a dynamic error.

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Tas \parsesep \Nty &\\
                    |\  & \Nexpr \parsesep \Tas \parsesep \Nconstraintkind &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \overtext{\EATC}{Type assertion}(\expr, \overtext{\ty}{asserted type}) &
\end{flalign*}

\ASTRuleDef{ATC}
\begin{mathpar}
\inferrule[type]{
  \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError\\\\
  \buildty(\vt) \astarrow \astversion{\vt} \OrBuildError
}{
  \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tas, \vt : \Nty)}{\vparsednode}) \astarrow
  \overname{\EATC(\astversion{\ve}, \astversion{\vt})}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_constraints]{
  \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError\\\\
  \buildconstraintkind(\vics) \astarrow \astversion{\vics} \OrBuildError
}{
  {
    \begin{array}{r}
      \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tas, \vics : \Nconstraintkind)}{\vparsednode}) \astarrow\\
      \overname{\EATC(\astversion{\ve}, \TInt(\astversion{\vics}))}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ATC}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes an asserting type conversion with expression $\vep$ and type $\tty$, that is $\EATC(\vep, \tty)$;
  \item annotating the expression $\vep$ in $\tenv$ yields $(\vt, \vepp, \\vsese)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\vt$ in $\tenv$ yields $\vtstruct$\ProseOrTypeError;
  \item annotating the type $\tty$ in $\tenv$ yields $(\ttyp, \vsesty)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\tty'$ in $\tenv$ yields $\vtystruct$\ProseOrTypeError;
  \item applying $\checkatc$ to $\vtstruct$ and $\vtystruct$ in $\tenv$ to check whether the type assertion
        will always fail yields $\True$\ProseOrTypeError;
  \item define $\vsesp$ as the union of $\vsesty$, $\vsese$, and the singleton set for \PerformsAssertions;
  \item checking whether $\vtstruct$ \subtypesatisfies\ $\vtystruct$ in $\tenv$ yields \\
        $\vallwayssucceeds$\ProseOrTypeError\
        (if $\vallwayssucceeds$ holds then the type assertion will always succeed dynamically, and therefore can be omitted);
  \item $\newe$ is $\vepp$ if $\vallwayssucceeds$ is $\True$ and $\EATC(\ttyp, \vepp)$ otherwise;
  \item $\vses$ is $\vsese$ if $\vallwayssucceeds$ is $\True$ and $\vses$ otherwise;
  \item $\vt$ is $\ttyp$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\vt, \vepp, \vsese) \OrTypeError\\\\
  \tstruct(\tenv, \vt) \typearrow \vtstruct \OrTypeError\\\\
  \annotatetype{\tenv, \tty} \typearrow (\ttyp, \vsesty) \OrTypeError\\\\
  \tstruct(\tenv, \ttyp) \typearrow \vtystruct \OrTypeError\\\\
  \checkatc(\tenv, \vtstruct, \vtystruct) \typearrow \True \OrTypeError\\\\
  \vsesp \eqdef \vsesty \cup \vsese \cup \{\PerformsAssertions\}\\
  \subtypesat(\tenv, \vtstruct, \vtystruct) \typearrow \vallwayssucceeds \OrTypeError\\\\
  (\newe, \vses) \eqdef \choice{\vallwayssucceeds}{(\vepp, \vsese)}{(\EATC(\vepp, \ttyp), \vsesp)}
}{
  \annotateexpr{\tenv, \overname{\EATC(\vep, \tty)}{\ve}} \typearrow (\overname{\ttyp}{\vt}, \newe, \vses)
}
\end{mathpar}
\CodeSubsection{\ATCBegin}{\ATCEnd}{../Typing.ml}
\lrmcomment{
  This is related to \identr{VBLL} \identi{KRLL} \identg{PFRQ} \identi{XVBG},
  \identr{GYJZ} \identi{SZVF} \identr{PZZJ} \identr{YCPX} \identi{ZLBW},
  \identi{TCST} \identi{CGRH} \identi{YJBB}.
}

\TypingRuleDef{CheckATC}
\hypertarget{def-checkatc}{}
The helper function
\[
  \checkatc(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vtone} \aslsep \overname{\ty}{\vttwo}) \aslto
  \{\True\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the types $\vtone$ and $\vttwo$, which are assumed to not be named types,
are compatible for a typing assertion in the static environment $\tenv$, yielding $\True$.
\ProseOtherwiseTypeError

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{equal}
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{different\_labels\_error}
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item the AST labels of $\vtone$ and $\vttwo$ are different;
    \item the result is a type error indicating that the type assertion will always fail.
  \end{itemize}

  \item \AllApplyCase{int\_bits}
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item the AST labels of $\vtone$ and $\vttwo$ are the same;
    \item the AST label of $\vtone$ is either $\TInt$ or $\TBits$;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{tuple}
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item $\vtone$ is a \tupletypeterm{} with list of tuples $\vlone$, that is, $\TTuple(\vlone)$;
    \item $\vtone$ is a \tupletypeterm{} with list of tuples $\vltwo$, that is, $\TTuple(\vltwo)$;
    \item checking whether $\vlone$ and $\vltwo$ have the same length yields $\True$\ProseTerminateAs{\TypeAssertionFailure};
    \item applying $\checkatc$ to $\vlone[\vi]$ and $\vltwo[\vi]$ in $\tenv$ for every $\vi\in\listrange(\vlone)$ yields $\True$\ProseOrTypeError;
    \item the result is $\True$;
  \end{itemize}

  \item \AllApplyCase{other\_error}
  \begin{itemize}
    \item determining whether $\vtone$ is \typeequivalent\ to $\vttwo$ in $\tenv$ yields $\False$;
    \item the AST labels of $\vtone$ and $\vttwo$ are the same;
    \item the AST label of $\vtone$ is neither $\TInt$, nor $\TBits$, nor $\TTuple$;
    \item the result is a type error indicating that the type assertion will always fail ($\TypeAssertionFailure$).
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[equal]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \True \OrTypeError
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[different\_labels\_error]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \astlabel(\vtone) \neq \astlabel(\vttwo)
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \TypeErrorVal{\TypeAssertionFailure}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_bits]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \astlabel(\vtone) = \astlabel(\vttwo)\\
  \astlabel(\vtone) \in \{\TInt, \TBits\}
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \vtone = \TTuple(\vlone)\\
  \vttwo = \TTuple(\vltwo)\\
  \checktrans{|\vlone|=|\vltwo|}{\TypeAssertionFailure} \typearrow \True\OrTypeError\\\\
  \vi\in\listrange(\vlone): \checkatc(\vlone[\vi], \vltwo[\vi]) \typearrow \True\OrTypeError
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[other\_error]{
  \typeequal(\tenv, \vtone, \vttwo) \typearrow \False\\\\
  \astlabel(\vtone) = \astlabel(\vttwo)\\
  \astlabel(\vtone) \not\in \{\TInt, \TBits, \TTuple\}
}{
  \checkatc(\tenv, \vtone, \vttwo) \typearrow \TypeErrorVal{\TypeAssertionFailure}
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{ATC}
\ExampleDef{Evaluation of an Asserting Type Conversion Expressions}
In \listingref{semantics-atcvalue}, both type assertions ---
\verb|3 as integer| and \verb|3 as integer{3..5}| --- succeed.
\ASLListing{Evaluating a successful type assertion expression}{semantics-atcvalue}{\semanticstests/SemanticsRule.ATCValue.asl}

\ExampleDef{An Unevaluated Asserting Type Conversion}
\identr{YCPX}
In \listingref{semantics-atcnotevaluated}, the asserting type conversion on \texttt{y}
does not yield a dynamic error, since the invocation of \texttt{f1} returns $\False$ when
evaluated:
\ASLListing{A asserting type conversion that is never evaluated}{semantics-atcnotevaluated}
{\semanticstests/SemanticsRule.ATCNotDynamicErrorIfFalse.asl}

\ExampleDef{Asserting Type Conversions with Typing Errors and Dynamic Errors}
\listingref{semantics-variousatcs} shows various type errors and dynamic errors:
\ASLListing{Various type errors and dynamic errors}{semantics-variousatcs}{\semanticstests/SemanticsRule.ATCVariousErrors.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes an asserted type conversion expression, $\EATC(\veone, \vt)$;
\item evaluating $\veone$ in $\env$ results in $\Normal((\vv, \vgone), \newenv)$\ProseOrAbnormal;
\item evaluating whether $\vv$ has type $\vt$ in $\env$ results in $(\vb, \vgtwo)$\ProseTerminateAs{\DynErrorConfig};
\item \OneApplies
      \begin{itemize}
      \item \AllApplyCase{okay}
            \begin{itemize}
            \item $\vb$ is the native Boolean for \True;
            \item $\vg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
            \end{itemize}
      \item \AllApplyCase{error}
            \begin{itemize}
            \item $\vb$ is the native Boolean for \False;
            \item the result is a dynamic error indicating that the type assertion failed
                  (\DynamicTypeAssertionFailure).
            \end{itemize}
      \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \evalexpr{\env, \veone} \evalarrow \Normal((\vv, \vgone), \newenv) \OrAbnormal\\\\
  \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \vgtwo) \OrDynError\\\\
  \vb \eqname \nvbool(\True)\\
  \vg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  \evalexpr{\env, \EATC(\veone, \vt)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\and
\inferrule[error]{
  \evalexpr{\env, \veone} \evalarrow \Normal((\vv, \Ignore), \Ignore)\\
  \isvaloftype(\env, \vv, \vt) \evalarrow (\vb, \Ignore)\\
  \vb \eqname \nvbool(\False)
}{
  \evalexpr{\env, \EATC(\veone, \vt)} \evalarrow \DynamicErrorVal{\DynamicTypeAssertionFailure}
}
\end{mathpar}
\CodeSubsection{\EvalATCBegin}{\EvalATCEnd}{../Interpreter.ml}

\SemanticsRuleDef{IsValOfType}
\ProseParagraph
\hypertarget{def-isvaloftype}{}
The relation
\[
  \isvaloftype(\overname{\envs}{\env} \aslsep \overname{\vals}{\vv} \aslsep \overname{\ty}{\vt}) \;\aslrel\;
  (\overname{\Bool}{\vb} \times \overname{\XGraphs}{\vg}) \cup \overname{\TDynError}{\DynErrorConfig}
\]
tests whether the value $\vv$ can be stored in a variable of type $\vt$ in the environment $\env$,
resulting in a Boolean value $\vb$ and execution graph $\vg$ or a dynamic error.

This relation is used in the context of a asserted type conversion,
which means the typechecker rule \TypingRuleRef{ATC} was already applied,
thus filtering cases where the type inferred for the converted expression
does not type-satisfy $\vt$. The semantics takes this into account and
only returns \False\ in cases where dynamic information is required.

Recall that the $\vt$ is the result of $\annotatetype$, which ensures that
all sub-expressions appearing in $\vt$ are side-effect-free.

\OneApplies
\begin{itemize}
  \item \AllApplyCase{type\_equal}
  \begin{itemize}
    \item the AST label of $\vt$ is not $\TInt$, $\TBits$, or $\TTuple$;
    \item $\vb$ is $\True$ (since \TypingRuleRef{ATC}
    succeeds in these cases only if the \structure\ of the type of the expression and the \structure\ of the type asserted against are \typeequivalent);
    \item $\vg$ is the empty graph.
  \end{itemize}

  \item \AllApplyCase{int\_unconstrained}
  \begin{itemize}
    \item $\vt$ has the structure of the unconstrained integer;
    \item $\vb$ is \True;
    \item $\vg$ is the empty graph.
  \end{itemize}

  \item \AllApplyCase{int\_wellconstrained}
  \begin{itemize}
    \item $\vt$ has the structure of a well-constrained integer with constraints $\vc_{1..k}$;
    \item $\vv$ is the \nativevalue\  integer for $n$;
    \item the evaluation of every constraint $\vc_i$ with $n$ in environment $\env$
    yields a Boolean value $\vb_i$ and an execution graph $\vg_i$\ProseOrError;
    \item $\vb$ is the Boolean disjunction of all Boolean values $\vb_i$, for $i=1..k$;
    \item $\vg$ is the parallel composition of all execution graphs $\vg_i$, for $i=1..k$;
  \end{itemize}

  \item \AllApplyCase{bits}
  \begin{itemize}
    \item $\vt$ is a bitvector type with expression $\ve$, that is, $\TBits(\ve, \Ignore)$;
    \item $\vv$ is a native bitvector value for the sequence of bits $\vbits$, that is, \\ $\nvbitvector(\vbits)$;
    \item evaluating the side-effect-free expression $\ve$ in $\env$ yields $\Normal(\vvp, \vg)$\ProseOrError;
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $\vvp$ is equal to the number of bits in $\vbits$}.
  \end{itemize}

  \item \AllApplyCase{tuple}
  \begin{itemize}
    \item $\vt$ is a tuple with types $\vt_i$, for $i=1..k$;
    \item the value at every index $i=1..k$ of $\vv$ is $\vu_i$, for $i=1..k$,
    \item the evaluation of $\isvaloftype$ for every value $\vu_i$
    and corresponding type $\vt_i$, for $i=1..k$,
    results in a Boolean $\vb_i$ and execution graph $\vg_i$\ProseOrError;
    \item $\vb$ is the Boolean conjunction of all Boolean values $\vb_i$, for $i=1..k$;
    \item $\vg$ is the parallel composition of all execution graphs $\vg_i$, for $i=1..k$;
    of the constraints.
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[type\_equal]{
  \astlabel(\vt) \not\in \{\TInt, \TBits\}
}{
  \isvaloftype(\env, \vv, \vt) \evalarrow (\overname{\True}{\vb}, \overname{\emptygraph}{\vg})
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_unconstrained]{}{
  \isvaloftype(\env, \vv, \overname{\TInt(\unconstrained)}{\vt}) \evalarrow (\overname{\True}{\vb}, \overname{\emptygraph}{\vg})
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_wellconstrained]{
  \vv \eqname \nvint(n)\\
  i=1..k: \isconstaintsat(\env, \vc_i, n) \evalarrow (\vb_i, \vg_i) \OrDynError\\\\
  \vb \eqdef \bigvee_{i=1}^k \vb_i\\
  \vg \eqdef \parallel_{i=1}^k \vg_i
}{
  \isvaloftype(\env, \vv, \overname{\TInt(\wellconstrained(\vc_{1..k}))}{\vt}) \evalarrow (\vb, \vg)
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits]{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\vvp, \vg) \OrDynError
}{
  \isvaloftype(\env, \overname{\nvbitvector(\vbits)}{\vv}, \overname{\TBits(\ve, \Ignore)}{\vt}) \evalarrow
  (\overname{\vvp = |\vbits|}{\vb}, \vg)
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{
  i=1..k: \getindex(i, \vv) \evalarrow \vu_i\\
  i=1..k: \isvaloftype(\env, \vu_i, \vt_i) \evalarrow (\vb_i, \vg_i) \OrDynError\\\\
  \vb \eqdef \bigwedge_{i=1}^k \vb_i \\
  \vg \eqdef\ \parallelcomp_{i=1}^k \vg_i
}{
  \isvaloftype(\env, \vv, \overname{\TTuple(i=1..k: \vt_i)}{\vt}) \evalarrow (\vb, \vg)
}
\end{mathpar}
\CodeSubsection{\EvalValOfTypeBegin}{\EvalValOfTypeEnd}{../Interpreter.ml}

Notice that these rules cover all types, including named types ($\TNamed$),
since the \typedast\ returned from \TypingRuleRef{ATC} is the \structure\ of the type
given in the specification.
%
Parameterized integers (integers with an empty set of constraints)
cannot appear as a type, since ASL syntax does not allow the following:
\begin{itemize}
\item Declaring an parameterized integer as a variable,
\item Declaring an alias to an parameterized integer type, and
\item Declaring an parameterized integer in a compound type.
\end{itemize}

\SemanticsRuleDef{IsConstraintSat}
\hypertarget{def-isconstraintsat}{}
The helper relation
\[
  \isconstaintsat(\overname{\envs}{\env} \aslsep \overname{\intconstraint}{\vc} \aslsep \overname{\Z}{n}) \;\aslrel\;
  (\overname{\Bool}{\vb} \times \overname{\XGraphs}{\vg})
\]
tests whether the integer value $n$ \emph{satisfies the constraint} $\vc$
(that is, whether $n$ is within the range of values defined by $\vc$) in the environment $\env$
and returns a Boolean answer $\vb$ and the execution graph $\vg$ resulting from evaluating
the expressions appearing in $\vc$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{Constraint\_Exact\_Sat}
  \begin{itemize}
    \item $\vc$ is a constraint for the expression $\ve$;
    \item evaluating the side-effect-free expression $\ve$ in $\env$ yields the \concurrentnativevalue\ given
          by the native integer value for $m$ and the \executiongraph\ $\vg$\ProseOrError.
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $m$ is equal to $n$}.
  \end{itemize}

  \item \AllApplyCase{Constraint\_Range\_Sat}
  \begin{itemize}
    \item $\vc$ is a constraint for the expressions $\veone$ and $\vetwo$;
    \item evaluating the side-effect-free expression $\veone$ in $\env$ yields the \concurrentnativevalue\ given
          by the native integer value for $a$ and the \executiongraph\ $\vgone$\ProseOrError.
    \item evaluating the side-effect-free expression $\vetwo$ in $\env$ yields the \concurrentnativevalue\ given
          by the native integer value for $b$ and the \executiongraph\ $\vgtwo$\ProseOrError.
    \item \Proseeqdef{$\vb$}{$\True$ if and only if $n$ is greater or equal to $a$ and less than or equal to $b$};
    \item \Proseeqdef{$\vg$}{the parallel composition of $\vgone$ and $\vgtwo$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
The use of $\evalexprsef$ is justified by checks in $\annotatetype$, verifying
that expressions appearing in types are all side-effect-free.

\begin{mathpar}
\inferrule[Constraint\_Exact\_Sat]{
  \evalexprsef{\env, \ve} \evalarrow (\nvint(m), \vg) \OrDynError
}{
  \isconstaintsat(\env, \overname{\constraintexact(\ve)}{\vc}, n) \evalarrow (\overname{m = n}{\vb}, \vg)
}
\end{mathpar}

\begin{mathpar}
\inferrule[Constraint\_Range\_Sat]{
  \evalexprsef{\env, \veone} \evalarrow (\nvint(a), \vgone) \OrDynError\\\\
  \evalexprsef{\env, \vetwo} \evalarrow (\nvint(b), \vgtwo) \OrDynError\\\\
  \vb \eqdef \choice{a \leq n \wedge n \leq b}{\True}{\False}\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  \isconstaintsat(\env, \overname{\constraintrange(\veone, \vetwo)}{\vc}, n) \evalarrow (\vb, \vg)
}
\end{mathpar}

\hypertarget{def-patternexpressionterm}{}
\section{Pattern Matching Expressions\label{sec:PatternMatchingExpressions}}
The binary operator $\Tin$ tests whether a value (referred to as the discriminant) matches any item from a $\Npatternset$.
Patterns can also be used to test whether an expression matches a bitmask (via $\Teq$) or does not match a bitmask (via $\Tneq$).
Lists of patterns are also used in case statements.
%
\chapref{PatternMatching} goes into the details of the various types of patterns that can be matched against.

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Nexpr \parsesep \Tin \parsesep \Npatternset &\\
              |\  & \Nexpr \parsesep \Teqop \parsesep \Tmasklit &\\
              |\  & \Nexpr \parsesep \Tneq \parsesep \Tmasklit &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EPattern(\expr, \pattern) &
\end{flalign*}

\ASTRuleDef{EPattern}
\begin{mathpar}
\inferrule{
  \buildexpr(\ve) \astarrow \astversion{\ve} \OrBuildError\\\\
  \buildpatternset(\vps) \astarrow \astversion{\vps} \OrBuildError
}{
  {
    \begin{array}{r}
      \buildexpr(\overname{\Nexpr(\ve : \Nexpr, \Tin, \vps : \Npatternset)}{\vparsednode}) \astarrow\\
      \overname{\EPattern(\astversion{\ve}, \astversion{\vps})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[eq]{}{
  \buildexpr(\overname{\Nexpr(\punnode{\Nexpr}, \Teq, \Tmasklit(\vm))}{\vparsednode}) \astarrow
  \overname{\EPattern(\astof{\vexpr}, \PatternMask(\vm))}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[neq]{}{
  {
    \begin{array}{r}
      \buildexpr(\overname{\Nexpr(\punnode{\Nexpr}, \Tneq, \Tmasklit(\vm))}{\vparsednode}) \astarrow\\
      \overname{\EPattern(\astof{\vexpr}, \PatternNot(\PatternMask(\vm)))}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EPattern}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a pattern expression to test whether $\veone$ matches the pattern $\vpat$, that is, \\ $\EPattern(\veone, \vpat)$;
  \item annotating the expression $\veone$ in $\tenv$ yields $(\vtetwo, \vetwo, \vsese)$\ProseOrTypeError;
  \item applying $\annotatepattern$ to $\vtetwo$ and $\vpat$ in $\tenv$ yields $(\vpatp, \vsespat)$\ProseOrTypeError;
  \item define $\vt$ as $\TBool$;
  \item define $\newe$ as the pattern expression for $\vetwo$ and the pattern $\vpatp$, that is, \\
        $\EPattern(\vetwo, \vpatp)$;
  \item define $\vses$ as the union of $\vsese$ and $\vsespat$ (there is no need to check for conflicts,
        since the $\veone$ is evaluated before $\vpat$, see \SemanticsRuleRef{EPattern}).
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \veone} \typearrow (\vtetwo, \vetwo, \vsese) \OrTypeError\\\\
  \annotatepattern(\tenv, \vtetwo, \vpat) \typearrow (\vpatp, \vsespat) \OrTypeError\\\\
  \vses \eqdef \vsese \cup \vsespat
}{
  \annotateexpr{\tenv, \overname{\EPattern(\veone, \vpat)}{\ve}} \typearrow (\overname{\TBool}{\vt}, \overname{\EPattern(\vetwo, \vpatp)}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\EPatternBegin}{\EPatternEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{EPattern}
\ExampleDef{Evaluation of Pattern Expressions}
In \listingref{semantics-epattern},
the expression \texttt{42 IN \{0..3, 42\}} evaluates to $\nvbool(\True)$
whereas the expression \texttt{42 IN \{0..3, -4\}} evaluates to $\nvbool(\False)$.
\ASLListing{Evaluating a pattern expression}{semantics-epattern}{\semanticstests/SemanticsRule.EPattern.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a pattern expression, $\EPattern(\ve, \vp)$;
  \item evaluating the expression $\ve$ in an environment $\env$ results in \\
  $\Normal((\vvone, \vgone), \newenv)$\ProseOrAbnormal;
  \item evaluating whether the pattern $\vp$ matches the value $\vvone$ in $\env$
  results in $\Normal(\vv, \vgtwo)$ where is a native Boolean that determines
  whether the is indeed a match;
  \item $\vg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\asldata$ edge.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vvone, \vgone), \newenv) \OrAbnormal\\
  \evalpattern{\env, \vvone, \vp} \evalarrow \Normal(\vv, \vgtwo)\\
  \vg \eqdef \ordered{\vgone}{\asldata}{\vgtwo}
}{
  \evalexpr{\env, \EPattern(\ve, \vp)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEPatternBegin}{\EvalEPatternEnd}{../Interpreter.ml}

\hypertarget{def-arbitraryexpressionterm}{}
\section{Arbitrary Value Expressions\label{sec:ArbitraryValueExpressions}}
An expression of the form \texttt{ARBITRARY: ty} evaluates to an arbitrary value in the
domain of \texttt{ty}.
Each evaluation can produce a different arbitrary value, but (as always) once a particular expression is evaluated, its arbitrary value cannot change.
This is because evaluation produces native values, and \ARBITRARY{} is not a valid native value---so once evaluated, it becomes an unchanging native value like any other.

Note that there are two important consequences of producing an arbitrary value when evaluating expressions of the form \texttt{ARBITRARY: ty}:
\begin{enumerate}
  \item The arbitrary value depends only on \texttt{ty}, and no other ASL storage elements.
  \item The only guarantee of the resulting value is that it is a valid member of \texttt{ty}.
    In particular, the language does not define which valid member it is, and ASL specifications must not rely on the value (for example, there is no way to test whether a value was produced by evaluating \ARBITRARY{}).
\end{enumerate}


\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Tarbitrary \parsesep \Tcolon \parsesep \Nty &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EArbitrary(\ty) &
\end{flalign*}

\ASTRuleDef{EArbitrary}
\begin{mathpar}
\inferrule{
  \buildty(\vt) \astarrow \astversion{\vt} \OrBuildError
}{
  \buildexpr(\overname{\Nexpr(\Tarbitrary, \Tcolon, \vt : \Nty)}{\vparsednode}) \astarrow
  \overname{\EArbitrary(\astversion{\vt})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{EArbitrary}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes an expression \ARBITRARY\ of type $\tty$, that is, $\EArbitrary(\tty)$;
  \item annotating the type $\tty$ in $\tenv$ yields $(\ttyone, \vsesty)$\ProseOrTypeError;
  \item obtaining the \structure\ of $\ttyone$ in $\tenv$ yields $\ttytwo$\ProseOrTypeError;
  \item $\vt$ is $\ttyone$;
  \item define $\newe$ as an expression \ARBITRARY\ of type $\ttytwo$, that is, $\EArbitrary(\ttytwo)$;
  \item define $\vses$ as the union of $\vsesty$ and the singleton set for the \NonDeterministicTerm.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatetype{\tenv, \tty} \typearrow (\ttyone, \vsesty) \OrTypeError\\\\
  \tstruct(\tenv, \ttyone) \typearrow \ttytwo \OrTypeError\\\\
  \vses \eqdef \vsesty \cup \{ \NonDeterministic \}
}{
  \annotateexpr{\tenv, \EArbitrary(\tty)} \typearrow (\ttyone, \EArbitrary(\ttytwo), \vses)
}
\end{mathpar}
\CodeSubsection{\EArbitraryBegin}{\EArbitraryEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{EArbitrary}
\ExampleDef{Evaluation of ARBITRARY for an Unconstrained Integer Type}
In \listingref{semantics-earbitraryunconstrained},
the expression \verb|ARBITRARY : integer| evaluates to an arbitrary integer value.
\ASLListing{Evaluating an \texttt{ARBITRARY} expression for an unconstrained integer}{semantics-earbitraryunconstrained}
{\semanticstests/SemanticsRule.EArbitraryInteger3.asl}

\subsubsection{Evaluation of ARBITRARY for a Costrained Integer Type}
In \listingref{semantics-earbitraryconstrained},
the expression \verb|ARBITRARY : integer {3, 42}| evaluates to either \\
$\nvint(3)$ or $\nvint(42)$.
\ASLListing{Evaluating an \texttt{ARBITRARY} expression for a constrained integer}{semantics-earbitraryconstrained}
{\semanticstests/SemanticsRule.EArbitraryIntegerRange3-42-3.asl}

\subsubsection{Evaluation of ARBITRARY for an Integer-indexed Array}
\listingref{semantics-earbitraryarray}
demonstrates how to obtain an arbitrary integer-indexed array, \texttt{int\_array},
and how to obtain an arbitrary enumeration-indexed array, \texttt{enum\_array}.
\ASLListing{Evaluating an \texttt{ARBITRARY} expression for array types}{semantics-earbitraryarray}
{\semanticstests/SemanticsRule.EArbitraryArray.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the \texttt{ARBITRARY} expression annotated with type $\vt$;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{okay}
    \begin{itemize}
      \item the domain of $\vt$ in $\env$ (see \secref{DynDomain}) is not empty;
      \item $\vv$ is an arbitrary value in the domain of $\vt$ in $\env$;
      \item $\newenv$ is $\env$.
      \item $\vg$ is the empty execution graph.
    \end{itemize}

    \item \AllApplyCase{error}
    \begin{itemize}
      \item the domain of $\vt$ in $\env$ is empty;
      \item the result is a dynamic error (\ArbitraryEmptyType) indicating that the type $\vt$ has an empty
            domain in $\env$ and therefore no value can be returned.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \dynamicdomain(\env, \vt) \neq \emptyset\\
  \vv \in \dynamicdomain(\env, \vt)
}{
  \evalexpr{\env, \overname{\EArbitrary (\vt)}{\ve}} \evalarrow \Normal((\vv, \overname{\emptygraph}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}

\begin{mathpar}
  \inferrule[error]{
  \dynamicdomain(\env, \vt) = \emptyset
}{
  \evalexpr{\env, \overname{\EArbitrary (\vt)}{\ve}} \evalarrow \DynamicErrorVal{\ArbitraryEmptyType}
}
\end{mathpar}
\CodeSubsection{\EvalEArbitraryBegin}{\EvalEArbitraryEnd}{../Interpreter.ml}

\subsubsection{Comments}
Notice that this rule introduces non-determinism.
\identr{WLCH}

\hypertarget{def-recordexpressionterm}{}
\section{Structured Type Construction Expressions\label{sec:StructuredTypeConstructionExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Tidentifier \parsesep \Tlbrace \parsesep \Trbrace &\\
	       |\ & \Tidentifier \parsesep \Tlbrace \parsesep \ClistOne{\Nfieldassign} \parsesep \Trbrace &\\
\Nfieldassign \derives \ & \Tidentifier \parsesep \Teq \parsesep \Nexpr &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ERecord(\overtext{\ty}{record type}, \overtext{(\identifier, \expr)^{*}}{field initializers}) &
\end{flalign*}

\ASTRuleDef{ERecord}
\begin{mathpar}
  \inferrule[empty]{}{
    {
      \begin{array}{r}
    \buildexpr(\overname{\Nexpr(
    \begin{array}{l}
    \Tidentifier(\vt), \Tlbrace, \Trbrace
    \end{array}
    )}{\vparsednode}) \\
    \astarrow\ \overname{\ERecord(\TNamed(\vt), \emptylist)}{\vastnode}
\end{array}
}
}
\end{mathpar}

\begin{mathpar}
  \inferrule[non\_empty]{
    \buildclist[\buildfieldassign](\vfieldassigns) \astarrow \vfieldassignasts
  }{
    {
      \begin{array}{r}
  \buildexpr\left(\overname{\Nexpr\left(
    \begin{array}{l}
    \Tidentifier(\vt), \Tlbrace, \\
    \wrappedline\ \namednode{\vfieldassigns}{\ClistOne{\Nfieldassign}}, \\
    \wrappedline\ \Trbrace
    \end{array}
    \right)}{\vparsednode}\right) \\
    \astarrow\ \overname{\ERecord(\TNamed(\vt), \vfieldassignasts)}{\vastnode}
\end{array}
}
}
\end{mathpar}

\ASTRuleDef{FieldAssign}
\hypertarget{build-fieldassign}{}
The function
\[
  \buildfieldassign(\overname{\parsenode{\Nfieldassign}}{\vparsednode}) \;\aslto\; \overname{(\identifier\times\expr)}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  \buildfieldassign(\Nfieldassign(\Tidentifier(\id), \Teq, \punnode{\Nexpr})) \astarrow
  \overname{(\id, \astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ERecord}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes the record construction expression (which is also used for creating exceptions) of type $\tty$ with fields $\fields$,
        that is, $\ERecord(\tty, \vfields)$;
  \item obtaining the \underlyingtype\ of $\tty$ in $\tenv$ yields $\ttyanon$\ProseOrTypeError;
  \item checking that $\ttyanon$ is a \structuredtype\ yields $\True$\ProseOrTypeError;% \ProseTerminateAs{\TypeErrorVal{\ExpectedStructuredType}};
  \item $\ttyanon$ is a \structuredtype\ with a list of $\field$ elements (consisting of a field name and a field type);
  \item obtaining the list of field names from $\vfields$ yields the list of identifiers \\
        $\initializedfields$;
  \item obtaining the list of field names from $\fieldtypes$ yields the list of identifiers $\names$;
  \item checking whether the set of identifiers in $\names$ is equal to the set of identifiers in $\initializedfields$
        yields $\True$\ProseOrTypeError;
  \item checking that the list $\initializedfields$ does not contain duplicates yields \\
        $\True$\ProseOrTypeError;
  \item applying $\annotatefieldinit$ to annotate each $\field$ element $(\name,\vep)$ of \\
        $\vfields$ in $\tenv$ yields $(\name,\ve_\name,\vxs_\name)$\ProseOrTypeError;
  \item define $\fieldsp$ as the list containing $(\name,\ve_\name)$ for each $\field$ element $(\name,\vep)$ of $\vfields$;
  \item $\vt$ is $\tty$;
  \item define $\newe$ as the record expression with type $\tty$ and field initializers $\fieldsp$, that is, $\ERecord(\tty, \fieldsp)$;
  \item define $\vsess$ as the list of \sideeffectdescriptorsetsterm\ given by $\vxs_\name$ for each $\field$ element $(\name,\Ignore)$ of $\vfields$;
  \item \Prosenonconflictingunion{$\vsess$}{$\vses$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \checktrans{\astlabel(\tty) = \TNamed}{NamedTypeExpected} \checktransarrow \True \OrTypeError\\\\
  \makeanonymous(\tenv, \tty) \typearrow \ttyanon \OrTypeError\\\\
  \checktrans{\astlabel(\ttyanon) \in \{\TRecord, \TException\}}{\UnexpectedType} \typearrow \True\OrTypeError\\\\
  \ttyanon \eqname L(\fieldtypes)\\
  \initializedfields \eqdef \{\name \;|\; (\name, \Ignore)\in\vfields\}\\
  \names \eqdef \fieldnames(\fieldtypes)\\
  \checktrans{\{\names\} = \{\initializedfields\}}{\BadField} \typearrow \True \OrTypeError\\\\
  \checknoduplicates(\initializedfields) \typearrow \True \OrTypeError\\\\
  {
    \begin{array}{r}
  (\name, \vep) \in \vfields: \annotatefieldinit(\tenv, (\name, \vep), \fieldtypes) \typearrow \\
  (\name, \ve_\name, \vxs_\name) \OrTypeError
    \end{array}
  }\\
  \fieldsp \eqdef [(\name, \vep) \in \fields : (\name, \ve_\name)]\\
  \vsess \eqdef [(\name, \Ignore) \in \fields : \vxs_\name]\\
  \nonconflictingunion(\vsess) \typearrow \vses \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\ERecord(\tty, \vfields)}{\ve}} \typearrow
  (\overname{\tty}{\vt}, \overname{\ERecord(\tty, \fieldsp)}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\ERecordBegin}{\ERecordEnd}{../Typing.ml}
\identr{WBCQ}

\hypertarget{def-annotatefieldinit}{}
\TypingRuleDef{AnnotateFieldInit}
The function
\[
\begin{array}{r}
  \annotatefieldinit(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{(\identifier\times\expr)}{(\name, \vep)} \aslsep
    \overname{\field^*}{\fieldtypes}
  ) \aslto \\
  (\overname{\identifier}{\name} \times \overname{\expr}{\vepp} \times \overname{\TSideEffectSet}{\vses})
\end{array}
\]
annotates a field initializers $(\name, \vep)$ in a record expression
with list of fields \\ $\fieldtypes$ and returns the annotated initializing expression $\vepp$
and its \sideeffectdescriptorterm\ $\vses$. \ProseOtherwiseTypeError

\ProseParagraph
\AllApply
\begin{itemize}
  \item annotating the expression $\vep$ in $\tenv$ yields $(\vtp, \vepp, \vses)$\ProseOrTypeError;
  \item checking whether there exists a type associated with $\name$ in $\fieldtypes$ yields $\True$\ProseOrTypeError;
  \item the unique type associated with $\name$ in $\fieldtypes$ is $\tspecp$;
  \item determining whether $\vtp$ \typesatisfies\ $\tspecp$ in $\tenv$ yields $\True$\ProseOrTypeError;
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \vep} \typearrow (\vtp, \vepp, \vses) \OrTypeError\\\\
  \checktrans{\fieldtype(\fieldtypes, \name) \neq \bot}{\BadField} \typearrow \True \OrTypeError\\\\
  \fieldtype(\fieldtypes, \name) = \tspecp\\
  \checktypesat(\tenv, \vtp, \tspecp) \typearrow \True \OrTypeError
}{
  \annotatefieldinit(\tenv, (\name, \vep), \fieldtypes) \typearrow (\name, \vepp, \vses)
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{ERecord}
\ExampleDef{Evaluation of Record Construction Expressions}
In \listingref{semantics-erecord},
the expression \verb|MyRecordType{a=3, b=42}| evaluates to the native record value \\
$\nvrecord{\va\mapsto\nvint(3), \vb\mapsto\nvint(42)}$.
\ASLListing{Evaluating a record construction expression}{semantics-erecord}{\semanticstests/SemanticsRule.ERecord.asl}

\ProseParagraph
\AllApply
\begin{itemize}
\item $\ve$ denotes a record creation expression, $\ERecord(\names, \efields)$;
\item the names of the fields are $\id_{1..k}$;
\item the expressions associated with the fields are $\ve_{1..k}$;
\item evaluating the expressions of $\fields$ in order yields \\
      $\Normal((\vvfields,\vg), \newenv)$\ProseOrAbnormal;
\item $\vvfields$ is a list of \nativevalues\ $\vv_{1..k}$;
\item $\vv$ is the native record that maps $\id_i$ to $\vv_i$, for $i=1..k$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \efields \eqname [i=1..k: (\id_i, \ve_i)]\\
  \names \eqdef \id_{1..k} \\
  \fields \eqdef \ve_{1..k} \\
  \evalexprlist{\env, \fields} \evalarrow \Normal((\vvfields,\vg), \newenv)  \OrAbnormal\\
  \vvfields \eqname \vv_{1..k}\\
  \vv \eqdef \nvrecord{\{i=1..k: \id_i\mapsto \vv_i\}}
}{
  \evalexpr{\env, \ERecord(\Ignore, \efields)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalERecordBegin}{\EvalERecordEnd}{../Interpreter.ml}

\hypertarget{def-tupleexpressionterm}{}
\section{Tuple Expressions\label{sec:TupleExpressions}}
\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Plisttwo{\Nexpr} &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \ETuple(\expr^{+}) &
\end{flalign*}

\ASTRuleDef{ETuple}
\begin{mathpar}
\inferrule[tuple]{
  \buildplist[\buildexpr](\vexprs) \astarrow \vexprasts
}{
  \buildexpr(\overname{\Nexpr(\namednode{\vexprs}{\Plisttwo{\Nexpr}})}{\vparsednode}) \astarrow
  \overname{\ETuple(\vexprasts)}{\vastnode}
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{ETuple}
\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{parenthesized}
  \begin{itemize}
    \item $\ve$ denotes a tuple expression with list of expressions consisting solely of $\vep$, that is, $\ETuple([\vep])$,
          meaning it represents a parenthesized expression (see \ASTRuleRef{ParenExpr});
    \item annotating $\vep$ in $\tenv$ yields $(\vt, \newe, \vses)$\ProseOrTypeError.
  \end{itemize}

  \item \AllApplyCase{list}
  \begin{itemize}
    \item $\ve$ denotes a tuple expression with list of expressions $\vli$, that is, $ \ETuple(\vli)$;
    \item $\vli$ consists of at least two expressions;
    \item annotating each expression $\vle[i]$ in $\tenv$, for $i=1..k$, yields $(\vt_i, \ve_i, \vxs_i$)\ProseOrTypeError;
    \item $\vt$ is the \tupletypeterm{} with list of types $\vt_i$, for $i=1..k$;
    \item $\newe$ is tuple expression over list of expressions $\ve_i$, for $i=1..k$;
    \item \Prosenonconflictingunion{consisting of $\vxs_i$, for $i=1..k$,}{$\vses$}\ProseOrTypeError.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[parenthesized]{
  \annotateexpr{\tenv, \vep} \typearrow (\vt, \newe, \vses) \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\ETuple(\vep)}{\ve}} \typearrow (\vt, \newe, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[list]{
  |\vli| > 1\\
  i=1..k: \annotateexpr{\tenv, \vle[i]} \typearrow (\vt_i, \ve_i, \vxs_i) \OrTypeError\\\\
  \nonconflictingunion(i=1..k: \vxs_i) \typearrow \vses \OrTypeError
}{
  \annotateexpr{\tenv, \overname{\ETuple(\vli)}{\ve}} \typearrow (\overname{\TTuple(\vt_{1..k})}{\vt}, \overname{\ETuple(\ve_{1..k})}{\newe}, \vses)
}
\end{mathpar}
\CodeSubsection{\ETupleBegin}{\ETupleEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{ETuple}
\ExampleDef{Evaluation of Tuple Expressions}
In \listingref{semantics-etuple},
the expression \texttt{(3, Return42())} evaluates to the value \texttt{(3, 42)}.
\ASLListing{Evaluating a tuple expression}{semantics-etuple}{\semanticstests/SemanticsRule.ETuple.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ denotes a tuple expression, $\ETuple(\elist)$;
  \item the evaluation of $\elist$ in $\env$ is $\Normal((\vlist, \vg), \newenv)$\ProseOrAbnormal;
  \item $\vv$ is the native vector constructed from the values in $\vlist$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexprlist{\env, \elist} \evalarrow \Normal((\vlist, \vg), \newenv) \OrAbnormal\\
  \vv \eqdef \nvvector{\vlist}
}{
  \evalexpr{\env, \ETuple(\elist)} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalETupleBegin}{\EvalETupleEnd}{../Interpreter.ml}

\section{Parenthesized Expressions\label{sec:ParenthesizedExpressions}}
A single expression inside parentheses is not considered to be a tuple, but rather the element
inside the parenthesis.
Parenthesizing an expression can be used to improve readability, enforce an order of evaluation,
and avoid binary operator precedence errors (see \ASTRuleRef{CheckNotSamePrec}).

\subsection{Syntax}
\begin{flalign*}
\Nexpr \derives\  & \Tlpar \parsesep \Nexpr \parsesep \Trpar &
\end{flalign*}

\subsection{Abstract Syntax}
We represent a parenthesized expression as a single element tuple for the technical
reason of enabling \ASTRuleRef{CheckNotSamePrec} by distinguishing parenthesized
expressions from non-parenthesized expressions. However, upon typing such expressions,
we ignore the parenthesis (see \TypingRuleRef{ETuple}.\textsc{PARENTHESIZED}).

\ASTRuleDef{ParenExpr}
\begin{mathpar}
  \inferrule[sub\_expr]{}{
  \buildexpr(\overname{\Nexpr(\Tlpar, \punnode{\Nexpr}, \Trpar)}{\vparsednode}) \astarrow
  \overname{\ETuple([\ \astof{\vexpr}\ ])}{\vastnode}
}
\end{mathpar}

\section{Array Construction Expressions\label{sec:ArrayConstructionExpressions}}
Array construction expression are used by the type system to express the initialization
of array-typed variables. Since there is no syntax to initialize arrays, there are also
no rules for building the AST for such expressions nor rules for typechecking them.

\subsection{Abstract Syntax}
\begin{flalign*}
\expr \derives\ & \EArray\{\EArrayLength: \expr, \EArrayValue: \expr\} &\\
             |\ & \EEnumArray \{\EArrayLabels: \identifier^+, \EArrayValue: \expr\}
\end{flalign*}

\subsection{Semantics}

The Semantic Rules use $\evalexprsef\empty$ because the typechecker in
$\annotatetype$ guarantees that expressions in types are side-effect-free.

\SemanticsRuleDef{EArray}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is an array construction expression with length expression $\elength$ and value expression $\evalue$,
        that is, $\EArray\{\EArrayLength: \elength, \EArrayValue: \evalue\}$;
  \item evaluating the expression $\evalue$ in $\env$ yields $\Normal((\vvalue, \vgone), \newenv)$\ProseOrAbnormal;
  \item evaluating the side-effect-free expression $\elength$ in $\env$ yields \\
        $\Normal((\vlength, \vgtwo))$\ProseOrError;
  \item $\vlength$ is a native integer value for $\nlength$;
  \item checking that $\nlength$ is non-negative yields $\True$\ProseTerminateAs{\NegativeArrayLength};
  \item define $\vv$ as the native vector of length $\nlength$ where each position has the value $\vvalue$;
  \item define $\vg$ as the parallel composition of $\vgone$ and $\vgtwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \evalue} \evalarrow \Normal((\vvalue, \vgone), \newenv) \OrAbnormal\\\\
  \evalexprsef{\env, \elength} \evalarrow \Normal((\vlength, \vgtwo)) \OrDynError\\\\
  \vlength \eqname \nvint(\nlength)\\
  \checktrans{\nlength \geq 0}{\NegativeArrayLength} \checktransarrow \True \OrDynError\\\\
  \vv \eqdef \nvvector{i=1..\nlength: \vvalue}\\
  \vg \eqdef \vgone \parallelcomp \vgtwo
}{
  \evalexpr{\env, \overname{\EArray\{\EArrayLength: \elength, \EArrayValue: \evalue\}}{\ve}} \evalarrow
  \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalEArrayBegin}{\EvalEArrayEnd}{../Typing.ml}

\SemanticsRuleDef{EEnumArray}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\ve$ is an array construction expression for an enumerated-index array with
        list of labels $\vlabels$ and value expression $\evalue$,
        that is, \\
        $\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \evalue\}$;
  \item evaluating the expression $\evalue$ in $\env$ yields $\Normal((\vvalue, \vg), \newenv)$\ProseOrAbnormal;
  \item \Proseeqdef{$\vv$}{the native record mapping each label $\vl\in\vlabels$ to $\vvalue$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \evalue} \evalarrow \Normal((\vvalue, \vg), \newenv) \OrAbnormal\\\\
  \vv \eqdef \nvrecord{\vl\in\vlabels: [\vl\mapsto \vvalue]}
}{
  {
  \begin{array}{r}
    \evalexpr{\env, \overname{\EEnumArray\{\EArrayLabels: \vlabels, \EArrayValue: \evalue\}}{\ve}} \evalarrow\\
    \Normal((\vv, \vg), \newenv)
  \end{array}
  }
}
\end{mathpar}

\CodeSubsection{\EvalEEnumArrayBegin}{\EvalEEnumArrayEnd}{../Typing.ml}

\section{Side-effect-free Expressions\label{sec:SideEffectFreeExpressions}}
\subsection{Typing}
An expression $\ve$ is considered to be side-effect-free in the static environment $\tenv$
if $\annotateexpr{\tenv, \ve} \typearrow (\Ignore, \Ignore, \vses)$
and $\vses$ only contains \sideeffectdescriptorsterm\ for reading storage (\ReadLocal\ and \ReadGlobal).

\subsection{Semantics}
\SemanticsRuleDef{ESideEffectFreeExpr}
\ProseParagraph
The helper relation
\hypertarget{def-evalexprsef}{}
\[
  \evalexprsef{\overname{\envs}{\env} \aslsep \overname{\expr}{\ve}} \;\aslrel\;
  \Normal(\overname{\vals}{\vv}\aslsep\overname{\XGraphs}{\vg}) \cup
  \overname{\TDynError}{\DynErrorConfig}
\]
specializes the expression evaluation relation for side-effect-free expressions
by omitting throwing configurations as possible output configurations.

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \ve} \evalarrow \Normal((\vv,\vg), \env) \OrDynError
}{
  \evalexprsef{\env, \ve} \evalarrow \Normal(\vv, \vg)
}
\end{mathpar}
Notice that the output configuration does not contain an environment,
since side-effect-free expressions do not modify the environment.

\section{Evaluating a List of Expressions\label{sec:ExprList}}
\SemanticsRuleDef{EExprList}
The relation
\hypertarget{def-evalexprlist}{}
\[
  \evalexprlist{\overname{\envs}{\env} \aslsep \overname{\expr^*}{\vle}} \;\aslrel\;
  \Normal((\overname{\vals^*}{\vv} \times \overname{\XGraphs}{\vg})\aslsep \overname{\envs}{\newenv}) \cup
  \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TDynError}{\DynErrorConfig}
\]
evaluates the list of expressions $\vle$ in left-to-right order in the initial environment $\env$
and returns the resulting value $\vv$, the parallel composition of the execution graphs
generated from evaluating each expression, and the new environment $\newenv$.
If the evaluation of any expression terminates abnormally then the abnormal configuration is returned.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item \Proseemptylist{$\vle$};
    \item \Proseemptylist{$\vv$};
    \item \Proseemptygraph{$\vg$};
    \item \Proseeqdef{$\newenv$}{$\env$}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vle$ is a \Proselist{$\ve$}{$\vle1$};
    \item \Proseevalexpr{$\env$}{$\ve$}{\\ $\Normal((\vvone, \vgone), \envone)$}\ProseOrAbnormal;
    \item \Proseeqdef{$\vg$}{the parallel composition of $\vgone$ and $\vgtwo$};
    \item \Proseeqdef{$\vv$}{the list with \head{} $\vvone$ and \tail{} $\vvs$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}
{
  \evalexprlist{\env, \overname{\emptylist}{\vle}} \evalarrow
  \Normal((\overname{\emptylist}{\vv}, \overname{\emptygraph}{\vg}), \overname{\env}{\newenv})
}
\end{mathpar}

\begin{mathpar}
\inferrule[nonempty]{
  \vle = [\ve] \concat \vle1\\
  \evalexpr{\env, \ve} \evalarrow \Normal((\vvone, \vgone), \envone) \OrAbnormal\\\\
  \evalexprlist{\envone, \vle1} \evalarrow \Normal((\vvs, \vgtwo), \newenv) \OrAbnormal\\\\
  \vg \eqdef \vgone \parallelcomp \vgtwo \\
  \vv \eqdef [\vvone] \concat \vvs
}{
  \evalexprlist{\env, \vle} \evalarrow \Normal((\vv, \vg), \newenv)
}
\end{mathpar}
