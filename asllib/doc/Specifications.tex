\chapter{Specifications\label{chap:Specifications}}
\hypertarget{def-specificationterm}{}
Specifications are grammatically derived from $\Nspec$ and represented as ASTs by \\
$\spec$.
%
Typing specifications is done by the relation $\typecheckast$, which is defined in
\TypingRuleRef{TypeCheckAST}.
%
The semantics of specifications in given by the relation $\evalspec$, which is defined in \SemanticsRuleRef{EvalSpec}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\Nspec   \derives\ & \maybeemptylist{\Ndecl} &
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Syntax}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\spec \derives\ & \decl^* &
\end{flalign*}

\ASTRuleDef{AST}
\hypertarget{build-ast}{}
The relation
\[
  \buildast : \overname{\parsenode{\Nspec}}{\vparsednode} \;\aslrel\; \overname{\spec}{\vastnode}
\]
transforms an $\Nspec$ node $\vparsednode$ into an AST specification node $\vastnode$.

We define this function for subprogram declarations, type declarations, and global storage declarations in the corresponding chapters.

\begin{mathpar}
\inferrule[ast]{
    \buildlist[\builddecl](\vdecls) \astarrow \vadecls
}{
    \buildast(\overname{\Nspec(\namednode{\vdecls}{\maybeemptylist{\Ndecl}})}{\vparsednode}) \astarrow \overname{\vadecls}{\vastnode}
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Typing Specifications\label{sec:TypingSpecifications}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The untyped AST of an ASL specification consists of a list of global declarations.
Typechecking the untyped AST succeeds if all declarations can be successfully annotated,
which is achieved via \TypingRuleRef{TypeCheckAST}. Otherwise, the result is a
type error.

We note that whether typechecking a specification succeeds or fails with a type
error, does not depend on the order in which the declarations appear in the specification.
That is, if typechecking a specification with one ordering of its declarations leads to
a type error, then typechecking that specification with any other ordering of its
declarations also leads to a type error, but the type errors may not be the same
(since there may be two erroneous declarations and the type error returned
depends on which declaration is processed first).

When typechecking declarations, it is important to process them in a certain order,
to avoid false type errors resulting from typechecking a declaration that uses an identifier
before a declaration that defines it.
This order relies on the notion of \defusedependencyterm, which we formally define in
\secref{Dependencies}.
\secref{TopologicalOrdering} formally defines how to use the inferred \defusedependenciesterm\ to
order the declarations such that false type errors are avoided.
\lrmcomment{This relates to \identi{LWQQ}.}

\TypingRuleDef{TypeCheckAST}
\hypertarget{def-typecheckast}{}
The relation
\[
\typecheckast(
  \overname{\globalstaticenvs}{\genv} \aslsep
  \overname{\decl^*}{\decls}
) \aslrel
(\overname{\decl^*}{\newdecls} \times \overname{\staticenvs}{\newtenv})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of declarations $\decls$ in an input global static environment $\genv$,
yielding an output static environment $\newtenv$ and annotated list of declarations $\newdecls$.
\ProseOtherwiseTypeError

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item splitting $\decls$ into two sublists by testing each declaration to check whether
        it is that of a pragma yields $\pragmas$ and $\others$, respectively;
  \item \Prosebuilddependencies{\others}{$(\defs, \dependencies)$};
  \item define $\reverseddependencies$ as the relation $\dependencies$ with its elements in reversed order.
        That is, if $(a,b)$ is in $\dependencies$ then $\reverseddependencies$ contains $(b, a)$.
        The reversal is necessary, since we want to check a declaration $b$ before any declaration $a$
        that depends on it;
  \item \ProseSCC{$\defs$}{$\reverseddependencies$}{$\comps$};
  \item \Prosetopologicalorderingcomps{$\comps$}{$\reverseddependencies$}{$\orderedcomps$};
  \item $\compdecls$ applies $\declsofcomp$ to each component $\vc$ in $\orderedcomps$ to transform it into a list,
        yielding a list of lists where each sublist corresponds to one strongly connected component;
  \item \Proseannotatedeclcomps{$\genv$}{$\compdecls$}{$\newdecls$}{$\newtenv$\ProseOrTypeError}.
  \item for each $\vd$ in $\pragmas$, \Prosecheckglobalpragma{$\newtenv$}{$\vd$}\ProseOrTypeError;
  \item $\pragmas$ is ignored;
\end{itemize}
\CodeSubsection{\TypeCheckASTBegin}{\TypeCheckASTEnd}{../Typing.ml}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \pragmas \eqdef [\ \vd \;|\; \vd \in \decls\ \land \astlabel(\vd) = \DPragma\ ]\\
  {
  \others \eqdef \left[ \begin{array}{r|l}
    \vd & \vd \in \decls\ \land \astlabel(\vd) \neq \DPragma
  \end{array}\right]
  }\\
  \builddependencies(\others) \typearrow (\defs, \dependencies)\\
  \reverseddependencies \eqdef [(a,b) \in \dependencies: (b,a)]\\
  \SCC(\defs, \reverseddependencies) = \comps\\
  \orderedcomps \in \topologicalorderingcomps(\comps, \reverseddependencies)\\
  \compdecls \eqdef [ \vc\in\orderedcomps: \declsofcomp(\vc, \decls) ]\\
  \annotatedeclcomps(\genv, \compdecls) \typearrow (\newdecls, \newtenv) \OrTypeError \\\\
  \vd\in\pragmas: \checkglobalpragma(\newtenv, \vd) \typearrow \True \OrTypeError
}{
  \typecheckast(\genv, \decls) \typearrow (\newdecls, \newtenv)
}
\end{mathpar}

\TypingRuleDef{AnnotateDeclComps}
\hypertarget{def-annotatedeclcomps}{}
The function
\[
\annotatedeclcomps(\overname{\globalstaticenvs}{\genv} \aslsep \overname{(\decl^*)^*}{\comps})
\aslto
(\overname{\globalstaticenvs}{\newgenv} \times \overname{\decl^*}{\newdecls})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of declaration components $\comps$
(a list of lists) in the global static environment $\genv$,
yielding the annotated list of declarations $\newdecls$ and modified global static environment $\newgenv$.
\ProseOtherwiseTypeError

We note that a strongly-connected component containing just a single declaration may contain
any kind of global declaration ---
a type declaration, a global storage declaration, or a subprogram declaration ---
whereas a strongly-connected component containing multiple declarations must be checked
to contain only subprograms. This is because the only type of mutually-recursive declarations
allows in ASL are between subprograms. The rules below handle these cases separately (\textsc{single}
for single declarations and \textsc{mutually\_recursive} for more than one declaration).

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\comps$ is the empty list;
    \item define $\newgenv$ as $\tenv$;
    \item define $\newdecls$ as the empty list.
  \end{itemize}

  \item All of the following apply (\textsc{single}):
  \begin{itemize}
    \item $\comps$ is a list with \head\ $\comp$ and \tail\ $\compsone$;
    \item $\comp$ is a single declaration $\vd$;
    \item applying $\typecheckdecl$ to $\vd$ in $\genv$ yields $(\vdone, \genvone)$\ProseOrTypeError;
    \item applying $\annotatedeclcomps$ to $\compsone$ in $\genvone$ yields \\ $(\newgenv, \declsone)$\ProseOrTypeError;
    \item define $\newdecls$ as the list with \head\ $\vdone$ and \tail\ $\declsone$.
  \end{itemize}

  \item All of the following apply (\textsc{mutually\_recursive}):
  \begin{itemize}
    \item $\comps$ is a list with \head\ $\comp$ and \tail\ $\compsone$;
    \item $\comp$ is a list with more than one declaration (that is, a list of mutually-recursive declarations);
    \item applying $\typecheckmutuallyrec$ to $\comp$ in $\genv$ yields \\ $(\declsone, \genvone)$\ProseOrTypeError;
    \item applying $\annotatedeclcomps$ to $\compsone$ in $\genvone$ yields \\ $(\newgenv, \declstwo)$\ProseOrTypeError;
    \item define $\newdecls$ as the concatenation of $\declsone$ and $\declstwo$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \annotatedeclcomps(\genv, \overname{\emptylist}{\comps}) \aslto (\overname{\genv}{\newgenv}, \overname{\emptylist}{\newdecls})
}
\end{mathpar}

\begin{mathpar}
\inferrule[single]{
  \comp = [\vd]\\
  \typecheckdecl(\genv, \vd) \typearrow (\vdone, \genvone) \OrTypeError\\\\
  \annotatedeclcomps(\genvone, \compsone) \typearrow (\newgenv, \declsone) \OrTypeError
}{
  \annotatedeclcomps(\genv, \overname{[\comp] \concat \compsone}{\comps}) \aslto
  (\newgenv, \overname{[\vdone] \concat \declsone}{\newdecls})
}
\end{mathpar}

\begin{mathpar}
\inferrule[mutually\_recursive]{
  |\comp| > 1\\
  \typecheckmutuallyrec(\genv, \comp) \typearrow (\declsone, \genvone) \OrTypeError\\\\
  \annotatedeclcomps(\genvone, \compsone) \typearrow (\newgenv, \declstwo) \OrTypeError
}{
  \annotatedeclcomps(\genv, \overname{[\comp] \concat \compsone}{\comps}) \aslto
  (\newgenv, \overname{\declsone \concat \declstwo}{\newdecls})
}
\end{mathpar}

\TypingRuleDef{TypeCheckMutuallyRec}
\hypertarget{def-typecheckmutuallyrec}{}
The function
\[
  \typecheckmutuallyrec(
    \overname{\globalstaticenvs}{\genv} \aslsep
    \overname{\decl^*}{\decls}
  )
  \aslto
  (
    \overname{\decl^*}{\newdecls} \times
    \overname{\globalstaticenvs}{\newgenv}
  )
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of mutually recursive declarations
$\decls$ in the global static environment $\genv$,
yielding the annotated list of subprogram declarations $\newdecls$
and modified global static environment $\newgenv$.

One of the requirements from an ASL specification is that each setter has a corresponding getter.
To facilitate checking this requirement, the type-system annotates the declarations of all subprograms
that are not setters before annotating the declarations of setters. This way, when annotating a setter,
the corresponding getter should have already been annotated and added to the environment, making it
easy to check this requirement.

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item checking that each declaration in $\vd$ is a subprogram declaration yields $\True$\ProseTerminateAs{\BadDeclaration};
  \item applying $\annotatefuncsig$ to each node $\vf$ in $\genv$, where $\DFunc(\vf)$ is a declaration in $\decls$,
        yields $(\tenv_\vf, \vd_\vf, \vses_\vf)$\ProseOrTypeError;
  \item define $\envandfs$ as the list of pairs, each consisting of the local environment component of $\tenv_\vf$
        the annotated subprogram $\vd_\vf$, and the \sideeffectsetterm\ $\vses_\vf$, for each subprogram declaration $\DFunc(\vf)$ in $\decls$;
  \item splitting $\envandfs$ into two sublists by testing each pair to check whether the subprogram declaration
        component is that of a setter yields $\setters$ and $\others$, respectively;
  \item define $\envandfsone$ as the concatenation of $\others$ and $\setters$;
  \item applying $\declaresubprograms$ to $\genv$ and $\envandfsone$ yields \\
        $(\genvtwo, \envandfstwo)$\ProseOrTypeError;
  \item for tuple in $\envandfstwo$ consisting of a local static environment, an element of $\func$,
        and a \sideeffectsetterm, $(\lenvtwo, \vf, \vses_\vf)$,
        applying $\annotatesubprogram$ to $\vf$ and $\vses_\vf$ in the static environment \\
        $(\genvtwo, \lenvtwo)$ yields $(\vnew_\vf, \vsesp_\vf)$\ProseOrTypeError;
  \item define $\newdecls$ as the list of $\DFunc(\vnew_\vf)$ for all $(\Ignore, \vf, \Ignore)$ in $\envandfstwo$;
  \item define $\vsess$ as the list of $(\vnew_\vf, \vsesp_\vf)$ for all $(\Ignore, \vf, \Ignore)$ in $\envandfstwo$;
  \item applying $\propagaterecursivecallssess$ on $\vsess$ yields $\vsessprop$;
  \item define $\tenvtwo$ as the environment with $\genvtwo$ as its static global environment
        and an empty static local environment;
  \item applying $\addsubprogramdecls$ to $\tenvtwo$ and $\vsessprop$ yields $\tenvthree$;
  \item define $\newtenv$ as the global static environment of $\tenvthree$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vd\in\decls: \checktrans{\astlabel(\vd) = \DFunc}{\BadDeclaration} \typearrow \True\OrTypeError\\\\
  \DFunc(\vf)\in\decls: \annotatefuncsig(\genv, \vf) \typearrow (\tenv_\vf, \vd_\vf, \vses_\vf)\OrTypeError\\\\
  \envandfs \eqdef [\DFunc(\vf)\in\decls: (L^{\tenv_\vf}, \vd_\vf, \vses_\vf)]\\
  {
  \setters \eqdef \left[ \begin{array}{r|l}
    (\lenv,\vf, \vses) & (\lenv, \vf, \vses) \in \envandfs\ \land \\
                & \vf.\funcsubprogramtype = \STSetter
  \end{array}\right]
  }\\
  {
  \others \eqdef \left[ \begin{array}{r|l}
    (\lenv,\vf, \vses) & (\lenv, \vf, \vses) \in \envandfs\ \land \\
                & \vf.\funcsubprogramtype\neq \STSetter
  \end{array}\right]
  }\\
  \envandfsone \eqdef \others \concat \setters \\
  \declaresubprograms(\genv, \envandfsone) \typearrow (\genvtwo, \envandfstwo) \OrTypeError\\\\
  {
    \begin{array}{r}
  (\lenvtwo, \vf, \vses_\vf)\in\envandfstwo: \annotatesubprogram((\genvtwo, \lenvtwo), \vf, \vses_\vf) \typearrow \\
      (\vnew_\vf, \vsesp_\vf) \OrTypeError
    \end{array}
  }\\\\
  \newdecls \eqdef [(\Ignore, \vf, \Ignore)\in\envandfstwo: \DFunc(\vnew_\vf)]\\
  \vsess \eqdef [(\Ignore, \vf, \Ignore)\in\envandfstwo: (\vnew_\vf, \vsesp_\vf)]\\
  \propagaterecursivecallssess(\vsess) \typearrow \vsessprop\\
  \tenvtwo \eqdef (\genvtwo, \emptyfunc)\\
  \addsubprogramdecls(\tenvtwo, \vsessprop) \typearrow \tenvthree
}{
  \typecheckmutuallyrec(\genv, \decls) \typearrow (\newdecls, \overname{G^\tenvthree}{\newgenv})
}
\end{mathpar}
\CodeSubsection{\TypeCheckMutuallyRecBegin}{\TypeCheckMutuallyRecEnd}{../Typing.ml}

\TypingRuleDef{CheckGlobalPragma}
\hypertarget{def-checkglobalpragma}{}
The function
\[
  \checkglobalpragma(
    \overname{\globalstaticenvs}{\genv} \aslsep
    \overname{\decl}{\vd}
  )
  \aslto
  \{\True\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
typechecks a global pragma declaration $\vd$ in the global static environment $\genv$,
yielding $\True$.
\ProseOtherwiseTypeError

\ProseParagraph

All of the following apply:
\begin{itemize}
  \item $\vd$ is a global pragma declaration with any identifier and expression list $\vargs$. that is, $\DPragma(\Ignore, \vargs)$;
  \item applying $\withemptylocal$ to $\genv$ yields $\tenv$;
  \item applying $\annotateexprlist$ to $\vargs$ in $\tenv$ yields $\vargsp$ \ProseOrTypeError;
  \item $\vargsp$ is ignored;
\end{itemize}

\FormallyParagraph

\begin{mathpar}
\inferrule{
  \withemptylocal(\genv) \typearrow \tenv \\
  \annotateexprlist(\tenv, \vargs) \typearrow \vargsp \OrTypeError \\
}{
  \checkglobalpragma(\genv, \overtext{\DPragma(\Ignore, \vargs)}{\vd}) \typearrow \True
}
\end{mathpar}

\CodeSubsection{\CheckGlobalPragmaBegin}{\CheckGlobalPragmaEnd}{../Typing.ml}

\TypingRuleDef{DeclareSubprograms}
\hypertarget{def-declaresubprograms}{}
The function
\[
  \declaresubprograms(
    \overname{\globalstaticenvs}{\genv} \aslsep
    \overname{(\localstaticenvs\times\func)^*}{\envandfs}
  ) \aslto
  \overname{\globalstaticenvs}{\newgenv} \times
  \overname{(\localstaticenvs\times\func\times\TSideEffectSet)^*}{\newenvandfs}
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
processes a list of pairs, each consisting of a local static environment and a subprogram declaration, $\envandfs$,
in the context of a global static environment $\genv$,
declaring each subprogram in the environment consisting of $\genv$ and the static local environment associated with
each subprogram.
The result is a modified global static environment $\newgenv$ and list of tuples $\newenvandfs$
consisting of local static environment, annotated $\func$ AST node, and \sideeffectdescriptorsetsterm.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\envandfs$ is the empty list;
    \item define $\newgenv$ as $\genv$;
    \item define $\newenvandfs$ as the empty list.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\envandfs$ is the list with \head\ $(\lenv, \vf, \vsesf)$ and \tail\ $\envandfsone$;
    \item define $\tenv$ as the environment where the global environment component is $\genv$ and the local environment component is $\lenv$;
    \item applying $\declareonefunc$ to $\vf$ in $\tenv$ yields $(\tenvone, \vfone)$\ProseOrTypeError;
    \item applying $\declaresubprograms$ to the global environment of $\tenvone$ and \\
          $\envandfsone$ yields $(\newgenv, \envandfstwo)$\ProseOrTypeError;
    \item define $\newenvandfs$ as the list with \head\ $(\lenv, \vfone, \vsesf)$ and \tail\ $\envandfstwo$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \declaresubprograms(\genv, \overname{\emptylist}{\envandfs}) \typearrow
   (\overname{\genv}{\newgenv}, \overname{\emptylist}{\newenvandfs})
}
\and
\inferrule[non\_empty]{
  \tenv \eqdef (\genv, \lenv)\\
  \declareonefunc(\tenv, \vf) \typearrow (\tenvone, \vfone) \OrTypeError\\\\
  \declaresubprograms(G^\tenvone, \envandfsone) \typearrow (\newgenv, \envandfstwo) \OrTypeError\\\\
  \newenvandfs \eqdef [(\lenv, \vfone, \vsesf)] \concat \envandfstwo
}{
  \declaresubprograms(\genv, \overname{[(\lenv, \vf, \vsesf)]\concat\envandfsone}{\envandfs}) \typearrow (\overname{\genv}{\newgenv}, \newenvandfs)
}
\end{mathpar}

\TypingRuleDef{AddSubprogramDecls}
\hypertarget{def-addsubprogramdecls}{}
The function
\[
  \addsubprogramdecls(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{(\func\times\TSideEffectSet)^*}{\vfuncs}
  ) \aslto
  \overname{\staticenvs}{\newtenv}
\]
adds each $\func$ element in $\vfuncs$ to the $\subprograms$ map of $G^\tenv$, yielding $\newtenv$.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\vfuncs$ is the empty list;
    \item $\newtenv$ is $\tenv$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\vfuncs$ is the list with \head\ $(\vf, \vsesf)$ and \tail\ $\vfuncsone$;
    \item applying $\addsubprogram$ to $\vf.\funcname$, $\vf$, and $\vsesf$ in $\tenv$ yields $\tenvone$;
    \item applying $\addsubprogramdecls$ to $\tenvone$ and $\vfuncsone$ yields $\newtenv$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \addsubprogramdecls(\tenv, \overname{\emptylist}{\vfuncs}) \typearrow \overname{\tenv}{\newtenv}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \addsubprogram(\tenv, \vf.\funcname, \vf, \vsesf) \typearrow \tenvone\\
  \addsubprogramdecls(\tenvone, \vfuncsone) \typearrow \newtenv
}{
  \addsubprogramdecls(\tenv, \overname{[(\vf, \vsesf)] \concat \vfuncsone}{\vfuncs}) \typearrow
  \newtenv
}
\end{mathpar}

\TypingRuleDef{PropagateRecursiveCallsSess}
\hypertarget{def-propagaterecursivecallssess}{}
The helper relation
\[
\propagaterecursivecallssess(\overname{(\func\times\TSideEffectSet)^*}{\vsess})
\aslrel
\overname{(\func\times\TSideEffectSet)^*}{\vsessnew}
\]
accepts a list of $\func$ AST nodes and their associated \sideeffectdescriptorsetsterm\ and
ensures that the \sideeffectdescriptorsterm\ of a given $\func$
consists of the \sideeffectdescriptorsterm\ of all the $\func$ AST nodes of the
recursive functions it may transitively call.

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item define the set $V$ as the set that includes an AST node $\vf$ if and only if $(\vf, \Ignore)$ exists in $\vsess$.
        Intuitively, this is the set of all function definitions in associated with \sideeffectconflictsterm\ in $\vsess$;
  \item define the relation $E : \func \times \func$ as follows:
        a pair $(\vfone, \vftwo)$ is included in $E$ if the pair $(\vfone, \vses_\vfone)$ exists in $\vsess$
        and the \RecursiveCallTerm\ for $\vftwo.\funcname$ exists in $\vses_\vfone$.
        Intuitively, there exists an edge $(\vfone, \vftwo)$ if the \sideeffectconflictsterm\ of $\vfone$ indicate that it
        may call the recursive function $\vftwo$;
  \item recall that $\graphtransitive{E}$ is the transitive closure of $E$, which intuitively means that
        $(\vfone, \vftwo)$ is included in $\graphtransitive{E}$ if there exists a path of edges in $E$ connecting $\vfone$
        to $\vftwo$;
  \item define the function $\propagatedeffects : \func \aslto \TSideEffectSet$, which binds a function definition $\vfone$
        to the set including any \sideeffectconflictterm\ $\vs$ such that $(\vfone, \vftwo) \in \graphtransitive{E}$ and
        $\vs$ is associated with $\vftwo$ in $\vsess$;
  \item define $\vsesnew$ as any listing of the set of pairs $(\vf, \propagatedeffects(\vf))$ such $\vf$ is a member of $V$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  V \eqdef \{ (\vf, \Ignore) \in \vsess\}\\
  E \eqdef \{ (\vfone, \vftwo) \;|\; \exists (\vfone, \vses_\vfone) \in \vsess \text{ and } \RecursiveCall(\vftwo.\funcname) \in \vses_\vfone\}\\
  \vfone\in V: \propagatedeffects(\vfone) \eqdef \bigcup \{ \vses_\vftwo \;|\; (\vfone, \vftwo) \in \graphtransitive{E} \text{ and } (\vftwo, \vses_\vftwo \in \vsess)\}\\
}{
  \propagaterecursivecallssess(\vsess) \typearrow \overname{[\vf\in V: (\vf, \propagatedeffects(\vf))]}{\vsessnew}
}
\end{mathpar}

\section{Establishing Def-Use Dependencies Between Global Declarations\label{sec:TopologicalOrdering}}
We now define how to construct a graph of \defusedependenciesterm\ between the identifiers associated
with global declarations.
This is achieved by associating, for each declaration $d$, the set identifiers \emph{used} by $d$,
which is formally defined by $\usedecl$, and the identifier \emph{defined} by $d$,
which is formally defined by $\defdecl$.
%
The set of \defusedependenciesterm\ associated with a declaration $\vd$ is given by
$\decldependencies(\vd)$ (see \TypingRuleRef{DeclDependencies}).

\TypingRuleDef{BuildDependencies}
\hypertarget{def-builddependencies}{}
The function
\[
\builddependencies(\overname{\decl^*}{\decls})
\aslto
(\overname{\identifier^*}{\defs}, \overname{(\identifier\times\identifier)^*}{\dependencies})
\]
takes a set of declarations $\decls$ and
returns a graph whose set of nodes --- $\defs$ --- consists of the identifiers that are used to name declarations
and whose set of edges $\dependencies$ consists of pairs $(a,b)$
where the declaration of $a$ uses an identifier defined by the declaration of $b$.
We refer to this graph as the \emph{\dependencygraphterm} (of $\decls$).

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item define $\defs$ as the union of two sets:
  \begin{enumerate}
  \item the set of identifiers obtained by applying $\defdecl$ to each declaration in $\decls$;
  \item the union of applying $\defenumlabels$ to each declaration in $\decls$.
  \end{enumerate}
  \item define $\dependencies$ as the union of applying $\decldependencies$ to each declaration in $\decls$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \defs \eqdef \{ \defdecl(\vd) \;|\; \vd \in \decls\} \cup \bigcup_{\vd\in\decls} \defenumlabels(\vd)\\
  \dependencies \eqdef \bigcup_{\vd \in \decls} \decldependencies(\vd)
}{
  \builddependencies(\decls) \typearrow (\defs, \dependencies)
}
\end{mathpar}

\TypingRuleDef{DeclDependencies}
\hypertarget{def-decldependencies}{}
The function
\[
\decldependencies(\overname{\decl}{\vd}) \aslto \overname{(\identifier\times\identifier)^*}{\dependencies}
\]
returns the set of dependent pairs of identifiers $\dependencies$ induced by the declaration $\vd$.

\ProseParagraph
Define $\dependencies$ as the union of the following two sets of pairs:
\begin{enumerate}
  \item a pair $(\idone, \idtwo)$, where $\idone$ is the result of applying $\defdecl$ to $\vd$
        and $\idtwo$ included in the result of applying $\defenumlabels$ to $\vd$; and
  \item a pair $(\idone, \idtwo)$ ,where $\idone$ is the result of applying $\defdecl$ to $\vd$
        and $\idtwo$ included in the result of applying $\usedecl$ to $\vd$.
\end{enumerate}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
    \begin{array}{rcll}
  \dependencies & \eqdef  & \{ (\idone, \idtwo) \;|\; \idone = \defdecl(\vd) \land \idtwo \in \defenumlabels(\vd) \} & \cup\\
                &         & \{ (\idone, \idtwo) \;|\; \idone = \defdecl(\vd) \land \idtwo \in \usedecl(\vd) \}  &
    \end{array}
  }
}{
  \decldependencies(\vd) \typearrow \dependencies
}
\end{mathpar}

\TypingRuleDef{DefDecl}
\hypertarget{def-defdecl}{}
The function
\[
\defdecl(\overname{\decl}{\vd}) \aslto \overname{\identifier}{\name}
\]
returns the identifier $\name$ being defined by the declaration $\vd$.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{d\_func}):
  \begin{itemize}
    \item $\vd$ declares a subprogram for the identifier $\name$.
  \end{itemize}

  \item All of the following apply (\textsc{d\_globalstorage}):
  \begin{itemize}
    \item $\vd$ declares a global storage element for the identifier $\name$.
  \end{itemize}

  \item All of the following apply (\textsc{d\_typedecl}):
  \begin{itemize}
    \item $\vd$ declares a type for the identifier $\name$.
  \end{itemize}
\end{itemize}

\begin{mathpar}
\inferrule[d\_func]{}{
  \defdecl(\overname{\DFunc(\funcname: \name, \ldots)}{\vd}) \typearrow \name
}
\and
\inferrule[d\_globalstorage]{}{
  \defdecl(\overname{\DGlobalStorage(\GDname: \name, \ldots)}{\vd}) \typearrow \name
}
\and
\inferrule[d\_typedecl]{}{
  \defdecl(\overname{\DTypeDecl(\name, \Ignore, \Ignore)}{\vd}) \typearrow \name
}
\end{mathpar}

\TypingRuleDef{DefEnumLabels}
\hypertarget{def-defenumlabels}{}
The function
\[
\defenumlabels(\overname{\decl}{\vd}) \aslto \overname{\pow{\identifier}}{\vlabels}
\]
takes a declaration $\vd$ and returns the set of enumeration labels it defines --- $\vlabels$ --
if it defines any.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{decl\_enum}):
  \begin{itemize}
    \item $\vd$ is a declaration of an enumeration type with labels $\vlabels$;
    \item the result is $\vlabels$ as a set (rather than a list).
  \end{itemize}

  \item All of the following apply (\textsc{other}):
  \begin{itemize}
    \item $\vd$ is not a declaration of an enumeration type;
    \item define $\vlabels$ as the empty set.
  \end{itemize}
\end{itemize}

\begin{mathpar}
\inferrule[decl\_enum]{
  \vd = \DTypeDecl(\name, \TEnum(\vlabels, \Ignore))
}{
  \defenumlabels(\vd) \typearrow \overname{\{\vlabels\}}{\vlabels}
}
\and
\inferrule[other]{
  \vd \neq \DTypeDecl(\name, \TEnum(\vlabels, \Ignore))
}{
  \defenumlabels(\vd) \typearrow \overname{\emptyset}{\vlabels}
}
\end{mathpar}

\TypingRuleDef{UseDecl}
\hypertarget{def-usedecl}{}
The function
\[
\usedecl(\overname{\decl}{\vd}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the declaration $\vd$ depends on.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{D\_TypeDecl}):
  \begin{itemize}
    \item $\vd$ declares a type $\tty$ and fields $\fields$, that is,
          $\DTypeDecl(\Ignore, \tty, \fields)$ (the first component is the name, which is being defined);
    \item define $\ids$ as the union of applying $\usety$ to $\tty$ and applying $\usesubtypes$ to $\fields$.
  \end{itemize}

  \item All of the following apply (\textsc{D\_GlobalStorage}):
  \begin{itemize}
    \item $\vd$ declares a global storage element with initial value $\initialvalue$ and type $\tty$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\initialvalue$ and applying $\usety$ to $\tty$.
  \end{itemize}

  \item All of the following apply (\textsc{D\_Func}):
  \begin{itemize}
    \item $\vd$ declares a subprogram with arguments $\vargs$, \optional\ return type \\
          $\rettyopt$, parameters $\vparams$, and body statement $\body$;
    \item define $\ids$ as the union of applying $\usety$ to each type of an argument in $\vargs$,
          applying $\usety$ to $\rettyopt$, applying $\usety$ to each type of a parameter in $\vparams$,
          and applying $\useexpr$ to $\body$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[D\_TypeDecl]{}{
  \usedecl(\overname{\DTypeDecl(\Ignore, \tty, \fields)}{\vd}) \typearrow \overname{\usety(\tty) \cup \usesubtypes(\fields)}{\ids}
}
\and
\inferrule[D\_GlobalStorage]{
  \ids \eqdef \useexpr(\initialvalue) \cup \usety(\tty)
}{
  \usedecl(\overname{\DGlobalStorage(\{
    \GDinitialvalue: \initialvalue,
    \GDty: \tty\ldots\})}{\vd})
  \typearrow \ids
}
\and
\inferrule[D\_Func]{
  {
    \begin{array}{rcll}
  \ids &\eqdef& \{ (\Ignore, \vt) \in \usety(\vt) : \id \} &\cup\\
  && \usety(\rettyopt) &\cup\\
  && \{ (\Ignore, \vt) \in \vparams : \usety(\vt) \} &\cup \\
  && \useexpr(\body) &
    \end{array}
  }
}{
  {
  \usedecl\left(\overname{
    \DFunc\left(
  \left\{
    \begin{array}{l}
    \funcbody: \body,\\
    \funcargs: \vargs,\\
    \funcreturntype: \rettyopt,\\
    \funcparameters: \vparams,\\
    \ldots\\
    \end{array}
  \right\}
  \right)}{\vd}
  \right)
  \typearrow \ids
  }
}
\end{mathpar}

\TypingRuleDef{UseTy}
\hypertarget{def-usety}{}
The function
\[
\usety(\overname{\ty \cup \langle\ty\rangle}{\vt}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the type or \optional\ type $\vt$ depends on.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\vt$ is $\None$;
    \item define $\ids$ as $\emptyset$.
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\vt$ is $\langle\tty\rangle$;
    \item applying $\usety$ to $\tty$ yields $\ids$.
  \end{itemize}

  \item All of the following apply (\textsc{simple}):
  \begin{itemize}
    \item $\vt$ is one of the following types: enumeration, Boolean, real, or string;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{t\_named}):
  \begin{itemize}
    \item $\vt$ is the named type for $\vs$;
    \item define $\ids$ as the singleton set for $\vs$.
  \end{itemize}

  \item All of the following apply (\textsc{int\_no\_constraints}):
  \begin{itemize}
    \item $\vt$ is either the unconstrained integer type or a \parameterizedintegertype{} or a \pendingconstrainedintegertype;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{int\_well\_constrained}):
  \begin{itemize}
    \item $\vt$ is the well-constrained integer type with constraints $\vcs$;
    \item define $\ids$ as the union of applying $\useconstraint$ to each constraint in $\vcs$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_tuple}):
  \begin{itemize}
    \item $\vt$ is the tuple type with list of types $\vli$;
    \item define $\ids$ as the union of applying $\useconstraint$ to each constraint in $\vcs$.
  \end{itemize}

  \item All of the following apply (\textsc{structured}):
  \begin{itemize}
    \item $\vt$ is a \structuredtype\ with fields $\fields$;
    \item define $\ids$ as the union of applying $\usety$ to each field type in $\fields$.
  \end{itemize}

  \item All of the following apply (\textsc{array\_expr}):
  \begin{itemize}
    \item $\vt$ is an array expression with length expression $\ve$ and element type $\vtp$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\ve$ and applying $\usety$ to $\vtp$.
  \end{itemize}

  \item All of the following apply (\textsc{array\_enum}):
  \begin{itemize}
    \item $\vt$ is an array expression with enumeration type $\vs$ and element type $\vtp$;
    \item define $\ids$ as the union of the singleton set for $\vs$ and applying $\usety$ to $\vtp$.
  \end{itemize}

  \item All of the following apply (\textsc{t\_bits}):
  \begin{itemize}
    \item $\vt$ is a bitvector type with width expression $\ve$ and bitfields $\bitfields$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\ve$ and applying $\usebitfield$ to each field in $\bitfields$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \usety(\overname{\None}{\vt}) \typearrow \overname{\emptyset}{\ids}
}
\and
\inferrule[some]{
  \usety(\tty) \typearrow \ids
}{
  \usety(\overname{\langle\tty\rangle}{\vt}) \typearrow \ids
}
\and
\inferrule[simple]{
  \astlabel(\vt) \in \{\TEnum, \TBool, \TReal, \TString\}
}{
  \usety(\vt) \typearrow \overname{\emptyset}{\ids}
}
\and
\inferrule[t\_named]{}{
  \usety(\overname{\TNamed(\vs)}{\vt}) \typearrow \overname{\{\vs\}}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_no\_constraints]{
  \astlabel(\vc) \in \{\unconstrained, \parameterized\}
}{
  \usety(\overname{\TInt(\vc)}{\vt}) \typearrow \overname{\emptyset}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[int\_well\_constrained]{}{
  \usety(\overname{\TInt(\wellconstrained(\vcs))}{\vt}) \typearrow \overname{\bigcup_{\vc \in \vcs} \useconstraint(\vc)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_tuple]{}{
  \usety(\overname{\TTuple(\vli)}{\vt}) \typearrow \overname{\bigcup_{\vt \in \vli} \usety(\vt)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[structured]{
  L \in \{\TRecord, \TException\}}{
  \usety(\overname{L(\fields)}{\vt}) \typearrow \overname{\bigcup_{(\Ignore, \vt) \in \fields} \usety(\vt)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[array\_expr]{}{
  \usety(\overname{\TArray(\ArrayLengthExpr(\ve), \vtp)}{\vt}) \typearrow \overname{\useexpr(\ve) \cup \usety(\vtp)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[array\_enum]{}{
  \usety(\overname{\TArray(\ArrayLengthEnum(\vs, \Ignore), \vtp)}{\vt}) \typearrow \overname{\{\vs\} \cup \usety(\vtp)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[t\_bits]{}{
  \usety(\overname{\TBits(\ve, \bitfields)}{\vt}) \typearrow \overname{\useexpr(\ve) \cup \bigcup_{\vf \in\bitfields}\usebitfield(\vf)}{\ids}
}
\end{mathpar}

\TypingRuleDef{UseSubtypes}
\hypertarget{def-usesubtypes}{}
The function
\[
\usesubtypes(\overname{\langle(\overname{\identifier}{\vx}\times\overname{\field^*}{\subfields})\rangle}{\fields}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the \optional\ pair consisting of
identifier $\vx$ (the type being subtyped) and fields $\subfields$ depends on.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\fields$ is $\None$;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\fields$ is $\langle(\vx, \subfields)\rangle$;
    \item define $\ids$ as the union of the singleton set for $\vx$ and the union of applying $\usety$
          to each field type in $\subfields$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \usesubtypes(\None) \typearrow \overname{\emptyset}{\ids}
}
\and
\inferrule[some]{
  \ids \eqdef \{\vx\} \cup \bigcup_{(\Ignore, \vt) \usety(\vt)}
}{
  \usesubtypes(\langle(\vx, \subfields)\rangle) \typearrow \ids
}
\end{mathpar}

\TypingRuleDef{UseExpr}
\hypertarget{def-useexpr}{}
The function
\[
\useexpr(\overname{\expr}{\ve} \cup \langle\overname{\expr}{\ve}\rangle) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the expression or \optional\ expression $\ve$ depends on.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{none}):
  \begin{itemize}
    \item $\ve$ is $\None$;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{some}):
  \begin{itemize}
    \item $\ve$ is $\langle\veone\rangle$;
    \item applying $\useexpr$ to $\veone$ yields $\ids$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_literal}):
  \begin{itemize}
    \item $\ve$ is a literal expression;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{e\_atc}):
  \begin{itemize}
    \item $\ve$ is the typing assertion for expression $\ve$ and type $\tty$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\usety$ to $\tty$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_var}):
  \begin{itemize}
    \item $\ve$ is the variable expression for identifier $\vx$;
    \item define $\ids$ as the singleton set for $\vx$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getarray}):
  \begin{itemize}
    \item $\ve$ is the \arrayaccess\ expression for base expression $\veone$ and index expression $\vetwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\useexpr$ to $\vetwo$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getenumarray}):
  \begin{itemize}
    \item $\ve$ is the \arrayaccess\ expression for base expression $\veone$ and enumeration-typed index expression $\vetwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\useexpr$ to $\vetwo$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_binop}):
  \begin{itemize}
    \item $\ve$ is the binary operation expression over expressions $\veone$ and $\vetwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\useexpr$ to $\vetwo$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_unop}):
  \begin{itemize}
    \item $\ve$ is the unary operation expression over any unary operation and an expression $\veone$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_call}):
  \begin{itemize}
    \item $\ve$ is the call expression of the subprogram named $\vx$ with argument expressions $\vargs$ and parameter expressions $\namedargs$;
    \item define $\ids$ as the union of the singleton set for $\vx$, and the set obtained by applying $\useexpr$ to each expression in
          $\vargs$ and each expression in $\namedargs$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_slice}):
  \begin{itemize}
    \item $\ve$ is the slicing expression over expression $\veone$ and slices $\slices$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\useslice$ to each slice in $\slices$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_cond}):
  \begin{itemize}
    \item $\ve$ is the conditional expression over expressions $\veone$, $\vetwo$, and $\vethree$;
    \item define $\ids$ as the union of applying $\useexpr$ to each of $\veone$, $\vetwo$, and $\vethree$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getitem}):
  \begin{itemize}
    \item $\ve$ is the tuple access expression over expression $\veone$;
    \item define $\ids$ as the application of $\useexpr$ to $\veone$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getfield}):
  \begin{itemize}
    \item $\ve$ is the field access expression over expression $\veone$;
    \item define $\ids$ as the application of $\useexpr$ to $\veone$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_getfields}):
  \begin{itemize}
    \item $\ve$ is the multiple field access expression over expression $\veone$;
    \item define $\ids$ as the application of $\useexpr$ to $\veone$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_record}):
  \begin{itemize}
    \item $\ve$ is the record construction expression of type $\tty$ and field initializations $\vli$;
    \item define $\ids$ as the union of applying of $\usety$ to $\tty$ and applying $\usety$ to each field type in $\vli$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_tuple}):
  \begin{itemize}
    \item $\ve$ is the tuple construction expression for the expressions $\ves$;
    \item define $\ids$ as the union of applying of $\useexpr$ to each expression in $\ves$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_array}):
  \begin{itemize}
    \item $\ve$ is the array construction expression for the length expression $\veone$ and value expression $\vetwo$,
          that is, $\EArray\{\EArrayLength:\veone, \EArrayValue:\vetwo\}$;
    \item define $\ids$ as the union of applying of $\useexpr$ to each of $\veone$ and $\vetwo$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_enumarray}):
  \begin{itemize}
    \item $\ve$ is the array construction expression for the array with enumeration-typed index for the list of labels
          $\vlabels$ and value expression $\vvalue$,
          that is, \\
          $\EEnumArray\{\EArrayLabels:\vlabels, \EArrayValue:\vvalue\}$;
    \item define $\ids$ as the union of labels listed in $\vlabels$ and the result of applying $\useexpr$ to $\vvalue$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_arbitrary}):
  \begin{itemize}
    \item $\ve$ is the arbitrary expression with type $\vt$;
    \item define $\ids$ as the application of $\usety$ to $\vt$.
  \end{itemize}

  \item All of the following apply (\textsc{e\_pattern}):
  \begin{itemize}
    \item $\ve$ is the pattern testing expression for subexpression $\veone$ and pattern $\vp$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\veone$ and applying $\usepattern$ to $\vp$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[none]{}{
  \useexpr(\overname{\None}{\ve}) \typearrow \overname{\emptyset}{\ids}
}
\and
\inferrule[some]{
  \useexpr(\veone) \typearrow \ids
}{
  \useexpr(\overname{\langle\veone\rangle}{\ve}) \typearrow \ids
}
\and
\inferrule[e\_literal]{}{
  \useexpr(\overname{\ELiteral(\Ignore)}{\ve}) \typearrow \overname{\emptyset}{\ids}
}
\and
\inferrule[e\_atc]{}{
  \useexpr(\overname{\EATC(\veone, \tty)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \usety(\tty)}{\ids}
}
\and
\inferrule[e\_var]{}{
  \useexpr(\overname{\EVar(\vx)}{\ve}) \typearrow \overname{\{\vx\}}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getarray]{}{
  \useexpr(\overname{\EGetArray(\veone, \vetwo)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getenumarray]{}{
  \useexpr(\overname{\EGetEnumArray(\veone, \vetwo)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_binop]{}{
  \useexpr(\overname{\EBinop(\Ignore, \veone, \vetwo)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_unop]{}{
  \useexpr(\overname{\EUnop(\Ignore, \veone)}{\ve}) \typearrow \overname{\useexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_call]{
  \ids \eqdef \{\vx\} \cup  \bigcup_{\veone\in\vargs}\useexpr(\veone) \cup \bigcup_{(\Ignore, \vt)\in\namedargs}\usety(\vt)
}{
  \useexpr(\overname{\ECall(\vx, \vargs, \namedargs)}{\ve}) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_slice]{}{
  \useexpr(\overname{\ESlice(\veone, \slices)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \bigcup_{\vs\in\slices}\useslice(\vs)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_cond]{}{
  \useexpr(\overname{\ECond(\veone, \vetwo, \vethree)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo) \cup \useexpr(\vethree)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getitem]{}{
  \useexpr(\overname{\EGetItem(\veone, \Ignore)}{\ve}) \typearrow \overname{\useexpr(\veone)}{\ids}
}
\and
\inferrule[e\_getfield]{}{
  \useexpr(\overname{\EGetField(\veone, \Ignore)}{\ve}) \typearrow \overname{\useexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_getfields]{}{
  \useexpr(\overname{\EGetFields(\veone, \Ignore)}{\ve}) \typearrow \overname{\useexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_record]{}{
  \useexpr(\overname{\ERecord(\tty, \vli)}{\ve}) \typearrow \overname{\usety(\tty) \cup \bigcup_{(\Ignore, \vt)\in\vli}\usety(\vt)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_tuple]{}{
  \useexpr(\overname{\ETuple(\ves)}{\ve}) \typearrow \overname{\bigcup_{\veone\in\ves}\useexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_array]{}{
  \useexpr(\overname{\EArray\{\EArrayLength:\veone, \EArrayValue:\vetwo\}}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_enumarray]{}{
  \useexpr(\overname{\EEnumArray\{\EArrayLabels:\vlabels, \EArrayValue:\vvalue\}}{\ve}) \typearrow \overname{\{\vlabels\} \cup \useexpr(\vvalue)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_arbitrary]{}{
  \useexpr(\overname{\EArbitrary(\vt)}{\ve}) \typearrow \overname{\usety(\vt)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[e\_pattern]{}{
  \useexpr(\overname{\EPattern(\veone, \vp)}{\ve}) \typearrow \overname{\useexpr(\veone) \cup \usepattern(\vp)}{\ids}
}
\end{mathpar}

\TypingRuleDef{UseLexpr}
\hypertarget{def-uselexpr}{}
The function
\[
\uselexpr(\overname{\lexpr}{\vle}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the left-hand-side expression $\vle$ depends on.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{le\_var}):
  \begin{itemize}
    \item $\vle$ is a left-hand-side variable expression for $\vx$;
    \item define $\ids$ as the singleton set for $\vx$.
  \end{itemize}

  \item All of the following apply (\textsc{le\_destructuring}):
  \begin{itemize}
    \item $\vle$ is a left-hand-side expression for assigning to a list of expressions $\vles$,
          that is $\LEDestructuring(\vles)$;
    \item define $\ids$ as the union of applying $\uselexpr$ to each expression in $\vles$.
  \end{itemize}

  \item All of the following apply (\textsc{le\_discard}):
  \begin{itemize}
    \item $\vle$ is a left-hand-side discard expression;
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{le\_setarray}):
  \begin{itemize}
    \item $\vle$ is a left-hand-side array update of the array given by the expression $\veone$ and index expression $\vetwo$;
    \item define $\ids$ as the union of applying $\uselexpr$ to $\veone$ and applying $\useexpr$ to $\vetwo$.
  \end{itemize}

  \item All of the following apply (\textsc{le\_setenumarray}):
  \begin{itemize}
    \item $\vle$ is a left-hand-side array update of the array given by the expression $\veone$ and
          the enumeration-typed index expression $\vetwo$;
    \item define $\ids$ as the union of applying $\uselexpr$ to $\veone$ and applying $\useexpr$ to $\vetwo$.
  \end{itemize}

  \item All of the following apply (\textsc{le\_setfield}):
  \begin{itemize}
    \item $\vle$ is a left-hand-side field update of the record given by the expression $\veone$;
    \item define $\ids$ as the application of $\uselexpr$ to $\veone$.
  \end{itemize}

  \item All of the following apply (\textsc{le\_setfields}):
  \begin{itemize}
    \item $\vle$ is a left-hand-side multiple field updates of the record given by the expression $\veone$;
    \item define $\ids$ as the application of $\uselexpr$ to $\veone$.
  \end{itemize}

  \item All of the following apply (\textsc{le\_slice}):
  \begin{itemize}
    \item $\vle$ is a left-hand-side slicing of the expression $\veone$ by slices $\slices$;
    \item define $\ids$ as the union of applying $\uselexpr$ to $\veone$ and applying $\useslice$ to each slice in $\slices$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[le\_var]{}{
  \uselexpr(\overname{\LEVar(\vx)}{\vle}) \typearrow \overname{\vx}{\ids}
}
\and
\inferrule[le\_destructuring]{}{
  \uselexpr(\overname{\LEDestructuring(\vles)}{\vle}) \typearrow \overname{\bigcup_{\ve\in\vles}\uselexpr(\ve)}{\ids}
}
\and
\inferrule[le\_discard]{}{
  \uselexpr(\overname{\LEDiscard}{\vle}) \typearrow \overname{\emptyset}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_setarray]{}{
  \uselexpr(\overname{\LESetArray(\veone, \vetwo)}{\vle}) \typearrow \overname{\uselexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_setenumarray]{}{
  \uselexpr(\overname{\LESetEnumArray(\veone, \vetwo)}{\vle}) \typearrow \overname{\uselexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_setfield]{}{
  \uselexpr(\overname{\LESetField(\veone, \Ignore)}{\vle}) \typearrow \overname{\uselexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_setfields]{}{
  \uselexpr(\overname{\LESetFields(\veone, \Ignore)}{\vle}) \typearrow \overname{\uselexpr(\veone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[le\_slice]{}{
  \uselexpr(\overname{\LESlice(\veone, \slices)}{\vle}) \typearrow \overname{\uselexpr(\veone) \cup \bigcup_{\vs\in\slices}\useslice(\vs)}{\ids}
}
\end{mathpar}

\TypingRuleDef{UsePattern}
\hypertarget{def-usepattern}{}
The function
\[
\usepattern(\overname{\pattern}{\vp}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the declaration $\vd$ depends on.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{mask\_all}):
  \begin{itemize}
    \item $\vp$ is either a mask pattern ($\PatternMask$) or a match-all pattern ($\PatternAll$);
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{tuple}):
  \begin{itemize}
    \item $\vp$ is a tuple pattern list of patterns $\vli$;
    \item define $\ids$ as the union of the application of $\usepattern$ for each pattern in $\vli$.
  \end{itemize}

  \item All of the following apply (\textsc{any}):
  \begin{itemize}
    \item $\vp$ is a pattern for matching any of the patterns in the list of patterns $\vli$;
    \item define $\ids$ as the union of the application of $\usepattern$ for each pattern in $\vli$.
  \end{itemize}

  \item All of the following apply (\textsc{single}):
  \begin{itemize}
    \item $\vp$ is a pattern for matching the expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{geq}):
  \begin{itemize}
    \item $\vp$ is a pattern for testing greater-or-equal with respect to the expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{leq}):
  \begin{itemize}
    \item $\vp$ is a pattern for testing less-than-or-equal with respect to the expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{not}):
  \begin{itemize}
    \item $\vp$ is a pattern negating the pattern $\vpone$;
    \item define $\ids$ as the application of $\usepattern$ to $\vpone$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\vp$ is a pattern for testing the range of expressions from $\veone$ to $\vetwo$;
    \item define $\ids$ as the union of the application of $\useexpr$ to both $\veone$ and $\vetwo$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[mask\_all]{
  \astlabel(\vp) \in \{\PatternMask, \PatternAll\}
}{
  \usepattern(\vp) \typearrow \overname{\emptyset}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple]{}{
  \usepattern(\overname{\PatternTuple(\vli)}{\vp}) \typearrow \overname{\bigcup_{\vpone\in\vli}\usepattern(\vpone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[any]{}{
  \usepattern(\overname{\PatternAny(\vli)}{\vp}) \typearrow \overname{\bigcup_{\vpone\in\vli}\usepattern(\vpone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[single]{}{
  \usepattern(\overname{\PatternSingle(\ve)}{\vp}) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[geq]{}{
  \usepattern(\overname{\PatternGeq(\ve)}{\vp}) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[leq]{}{
  \usepattern(\overname{\PatternLeq(\ve)}{\vp}) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[not]{}{
  \usepattern(\overname{\PatternNot(\vpone)}{\vp}) \typearrow \overname{\usepattern(\vpone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{}{
  \usepattern(\overname{\PatternRange(\veone, \vetwo)}{\vp}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\TypingRuleDef{UseSlice}
\hypertarget{def-useslice}{}
The function
\[
\useslice(\overname{\slice}{\vs}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the slice $\vs$ depends on.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{single}):
  \begin{itemize}
    \item $\vs$ is the slice at the position given by the expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{start\_length\_rang}):
  \begin{itemize}
    \item $\vs$ is a slice given by the pair of expressions $\veone$ and $\vetwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to both $\veone$ and $\vetwo$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[single]{}{
  \useslice(\overname{\SliceSingle(\ve)}{\vs}) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\and
\inferrule[star\_length\_range]{
  L \in \{\SliceStar, \SliceLength, \SliceRange\}
}{
  \useslice(\overname{L(\veone, \vetwo)}{\vs}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\TypingRuleDef{UseBitfield}
\hypertarget{def-usebitfield}{}
The function
\[
\usebitfield(\overname{\decl}{\vbf}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the bitfield $\vbf$ depends on.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{simple}):
  \begin{itemize}
    \item $\vbf$ is the single field with slices $\slices$;
    \item define $\ids$ as the union of applying $\useslice$ to each slice in $\slices$.
  \end{itemize}

  \item All of the following apply (\textsc{nested}):
  \begin{itemize}
    \item $\vbf$ is the nested bitfield with slices $\slices$ and bitfields $\bitfields$;
    \item define $\ids$ as the union of applying $\useslice$ to each slice in $\slices$ and applying
          $\usebitfield$ to each bitfield in $\bitfields$.
  \end{itemize}

  \item All of the following apply (\textsc{type}):
  \begin{itemize}
    \item $\vbf$ is the typed bitfield with slices $\slices$ and type $\tty$;
    \item define $\ids$ as the union of applying $\useslice$ to each slice in $\slices$ and applying
          $\usety$ to $\tty$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[simple]{}{
  \usebitfield(\overname{\BitFieldSimple(\Ignore, \slices)}{\vbf}) \typearrow \overname{\bigcup_{\vs\in\slices}\useslice(\vs)}{\ids}
}
\and
\inferrule[nested]{
  \ids \eqdef \bigcup_{\bfone\in\bitfields}\usebitfield(\vs) \cup \bigcup_{\vs\in\slices}\useslice(\vs)
}{
  \usebitfield(\overname{\BitFieldNested(\Ignore, \slices, \bitfields)}{\vbf}) \typearrow \ids
}
\and
\inferrule[type]{
  \ids \eqdef \bigcup_{\vs\in\slices}\useslice(\vs) \cup \usety(\tty)
}{
  \usebitfield(\overname{\BitFieldType(\Ignore, \slices, \tty)}{\vbf}) \typearrow \ids
}
\end{mathpar}

\TypingRuleDef{UseConstraint}
\hypertarget{def-useconstraint}{}
The function
\[
\useconstraint(\overname{\intconstraint}{\vc}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the integer constraint $\vc$ depends on.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{exact}):
  \begin{itemize}
    \item $\vc$ is the single-value expression constraint with expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\vc$ is the range constraint with expressions $\veone$ and $\vetwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to both $\veone$ and $\vetwo$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{}{
  \useconstraint(\overname{\ConstraintExact(\ve)}{\vc}) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\and
\inferrule[range]{}{
  \useconstraint(\overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \overname{\useexpr(\veone) \cup \useexpr(\vetwo)}{\ids}
}
\end{mathpar}

\TypingRuleDef{UseStmt}
\hypertarget{def-usestmt}{}
The function
\[
\usestmt(\overname{\stmt}{\vs}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the statement $\vs$ depends on.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{pass\_return\_none\_throw\_none}):
  \begin{itemize}
    \item $\vs$ is either a pass statement $\SPass$, a return-nothing statement $\SReturn(\None)$,
          or a throw-nothing statement ($\SThrow(\None)$);
    \item define $\ids$ as the empty set.
  \end{itemize}

  \item All of the following apply (\textsc{s\_seq}):
  \begin{itemize}
    \item $\vs$ is a sequencing statement for $\vsone$ and $\vstwo$;
    \item define $\ids$ as the union of applying $\usestmt$ to both $\vsone$ and $\vstwo$.
  \end{itemize}

  \item All of the following apply (\textsc{assert\_return\_some}):
  \begin{itemize}
    \item $\vs$ is either an assertion with expression $\ve$ or a return statement with expression $\ve$;
    \item define $\ids$ as the application of $\useexpr$ to $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{s\_assign}):
  \begin{itemize}
    \item $\vs$ is an assignment statement with left-hand-side $\vle$ and right-hand-side $\ve$;
    \item define $\ids$ as the union of applying $\uselexpr$ to $\vle$ and $\useexpr$ to $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{s\_call}):
  \begin{itemize}
    \item $\vs$ is a call statement for the subprogram with name $\vx$, arguments $\vargs$, and list of
          pairs consisting of a parameter identifier and associated expression $\namedargs$;
    \item define $\ids$ as the union of the singleton set for $\vx$, applying $\useexpr$ to
          every expression in $\vargs$ and applying $\useexpr$ to every expression associated with
          a parameter in $\namedargs$.
  \end{itemize}

  \item All of the following apply (\textsc{s\_cond}):
  \begin{itemize}
    \item $\vs$ is the conditional statement with expression $\ve$ and statements $\vsone$ and $\vstwo$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\ve$ and $\usestmt$ to both of $\vsone$ and $\vstwo$.
  \end{itemize}

  \item All of the following apply (\textsc{s\_for}):
  \begin{itemize}
    \item $\vs$ is the for statement $\SFor\left\{\begin{array}{rcl}
      \Forindexname &:& \Ignore\\
      \Forstarte &:& \vstarte\\
      \fordirection &:& \vdirection\\
      \Forende &:& \vende\\
      \Forbody &:& \vbody\\
      \Forlimit &:& \vlimit
    \end{array}\right\}$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\vlimit$, $\vstarte$, and $\vende$ and applying $\usestmt$ to $\vsone$.
  \end{itemize}

  \item All of the following apply (\textsc{while\_repeat}):
  \begin{itemize}
    \item $\vs$ is either a while statement or repeat statement, each with expression $\ve$, body statement $\vsone$,
          and optional limit expression $\vlimit$;
    \item define $\ids$ as the union of applying $\useexpr$ to $\vlimit$ and to $\ve$, and applying $\usestmt$ to $\vsone$.
  \end{itemize}

  \item All of the following apply (\textsc{s\_decl}):
  \begin{itemize}
    \item $\vs$ is a declaration statement with \optional{} type annotation $\vt$ and \optional\ initialization expression $\ve$;
    \item define $\ids$ as the union of applying $\usety$ to $\vt$ and $\useexpr$ to $\ve$.
  \end{itemize}

  \item All of the following apply (\textsc{s\_try}):
  \begin{itemize}
    \item $\vs$ is a try statement with statement $\vsone$, catcher list $\catchers$, and otherwise statement $\vstwo$;
    \item define $\ids$ as the union of applying $\usestmt$ to both $\vsone$ and $\vstwo$ and $\usecatcher$ to
          every catcher in $\catchers$.
  \end{itemize}

  \item All of the following apply (\textsc{s\_print}):
  \begin{itemize}
    \item $\vs$ is a print statement with list of expressions $\vargs$;
    \item define $\ids$ as the union of applying $\useexpr$ to each expression in $\vargs$.
  \end{itemize}

  \item All of the following apply (\textsc{s\_unreachable}):
  \begin{itemize}
    \item $\vs$ is an \texttt{Unreachable()};
    \item define $\ids$ as the empty set.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[pass\_return\_none\_throw\_none]{
  \vs = \SPass \lor \vs = \SReturn(\None) \lor \vs = \SThrow(\None)
}{
  \usestmt(\vs) \typearrow \overname{\emptyset}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_seq]{}{
  \usestmt(\overname{\SSeq(\vsone, \vstwo)}{\vs}) \typearrow \overname{\usestmt(\vsone)\cup\usestmt(\vstwo)}{\ids}
}
\and
\inferrule[assert\_return\_some]{
  \vs = \SAssert(\ve) \lor \vs = \SReturn(\langle\ve\rangle)
}{
  \usestmt(\vs) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}

\inferrule[s\_assign]{}{
  \usestmt(\overname{\SAssign(\vle, \ve)}{\vs}) \typearrow \overname{\uselexpr(\vle) \cup \useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_call]{
  \ids \eqdef \{\vx\} \cup \bigcup_{\ve\in\vargs}\useexpr(\ve) \cup \bigcup_{(\Ignore, \ve)\in\namedargs} \useexpr(\ve)
}{
  \usestmt(\overname{\SCall(\vx, \vargs, \namedargs)}{\vs}) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_cond]{}{
  \usestmt(\overname{\SCond(\ve, \vsone, \vstwo)}{\vs}) \typearrow \overname{\useexpr(\ve) \cup \usestmt(\vsone) \cup \usestmt(\vstwo)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_for]{
  \ids \eqdef \useexpr(\vlimit) \cup \useexpr(\vstarte) \cup \useexpr(\vende) \cup \usestmt(\vbody)
}{
  {
  \usestmt\left(\overname{\SFor\left\{\begin{array}{rcl}
    \Forindexname &:& \Ignore\\
    \Forstarte &:& \vstarte\\
    \fordirection &:& \vdirection\\
    \Forende &:& \vende\\
    \Forbody &:& \vbody\\
    \Forlimit &:& \vlimit
  \end{array}\right\}}{\vs}\right) \typearrow \ids
  }
}
\and
\inferrule[while\_repeat]{
  \vs = \SWhile(\ve, \vlimit, \vs) \lor \vs = \SRepeat(\vs, \ve, \vlimit)
}{
  \usestmt(\vs) \typearrow \overname{\useexpr(\vlimit) \cup \useexpr(\ve) \cup \usestmt(\vsone)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_decl]{}{
  \usestmt(\overname{\SDecl(\Ignore, \Ignore, \vt, \ve)}\vs) \typearrow \overname{\usety(\vt) \cup \useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_throw\_some]{}{
  \usestmt(\overname{\SThrow(\langle\ve\rangle)}\vs) \typearrow \overname{\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_try]{
  \ids \eqdef \usestmt(\vsone) \cup \bigcup_{\vc\in\catchers}\usecatcher(\vc) \cup \usestmt(\vstwo)
}{
  \usestmt(\overname{\STry(\vsone, \catchers, \vstwo)}{\vs}) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_print]{}{
  \usestmt(\overname{\SPrint(\vargs, \Ignore)}{\vs}) \typearrow \overname{\bigcup_{\ve\in\vargs}\useexpr(\ve)}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[s\_unreachable]{}{
  \usestmt(\overname{\SUnreachable}{\vs}) \typearrow \overname{\emptyset}{\ids}
}
\end{mathpar}

\TypingRuleDef{UseCatcher}
\hypertarget{def-usecatcher}{}
The function
\[
\usecatcher(\overname{\catcher}{\vc}) \aslto \overname{\pow{\identifier}}{\ids}
\]
returns the set of identifiers $\ids$ which the try statement catcher $\vc$ depends on.

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\vc$ is a case alternative with type $\tty$ and statement $\vs$;
  \item define $\ids$ as the union of applying $\usety$ to $\ty$ and applying $\usestmt$ to $\vs$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \usecatcher(\overname{(\Ignore, \tty, \vs)}{\vc}) \typearrow \overname{\usety(\tty) \cup \usestmt(\vs)}{\ids}
}
\end{mathpar}

\section{Ordering Global Declarations via Def-Use Dependencies\label{sec:Dependencies}}

\hypertarget{def-graphtransitive}{}
We denote the reflexive-transitive closure of a relation $E$ as $\graphtransitive{E}$.

\begin{definition}[Strongly Connected Components]
\hypertarget{def-scc}{}
Given a graph $G=(V, E)$, a \\ subset of its nodes $C \subseteq V$ is called
a \emph{strongly connected component} of $G$ if
every pair of nodes $u,v \in C$ reachable from one another.

The \emph{strongly connected components} of a graph $(V, E)$ uniquely partitions its set of
nodes $V$ into a set of strongly connected components:
\[
\SCC(V, E) \triangleq \{ C \subseteq V \;|\; \forall u,v\in C.\ (u,v), (v,u) \in \graphtransitive{E} \} \enspace.
\]
\end{definition}

\hypertarget{def-topologicalorderingcomps}{}
\begin{definition}[Topological Ordering of Components]
For a non-empty graph \\
$G=(V, E)$ and its strongly connected components $\comps \triangleq \SCC(V, E)$,
a listing of $\comps$ ---
$C_{1..k}$ --- is a \emph{topological ordering of components},
denoted \\
$C_{1..k} \in \topologicalorderingcomps(\comps, E)$, if the following condition holds:
\[
  \forall 1 \leq i \leq j \leq k.\ \exists c_i\in C_i.\ c_j\in C_j.\ (c_i,c_j) \in \graphtransitive{E} \;\;\Longrightarrow\;\;
  i \leq j \enspace .
\]
\end{definition}

\TypingRuleDef{DeclsOfComp}
\hypertarget{def-declsofcomp}{}
The helper function
\[
\declsofcomp(
  \overname{\pow{\identifier}}{\comp} \aslsep
  \overname{\decl^*}{\decls}
) \aslto \overname{\decl^*}{\compdecls}
\]
filters $\decls$ in order to retain the declarations whose identifiers are members of $\comp$,
yielding $\compdecls$

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\decls$ is the empty list;
    \item define $\compdecls$ as the empty list.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\decls$ is the list with \head\ $\vd$ and \tail\ $declsone$;
    \item define $\declstwo$ as the singleton list for $\vd$ if applying $\defdecl$ to $\vd$ yields an identifier
          that is a member of $\comp$ and the empty list, otherwise;
    \item applying $\declsofcomp$ to $\comp$ and $\declsone$ yields $\declsthree$;
    \item define $\compdecls$ as the concatenation of $\declstwo$ and $\declsthree$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \declsofcomp(\comp, \overname{\emptylist}{\decls}) \typearrow \overname{\emptylist}{\compdecls}
}
\and
\inferrule[non\_empty]{
  \declstwo \eqdef \choice{\defdecl(\vd) \in \comp}{[\vd]}{\emptylist}\\
  \declsofcomp(\comp, \declsone) \typearrow \declsthree
}{
  \declsofcomp(\comp, \overname{[\vd]\concat\declsone}{\decls}) \typearrow \overname{\declstwo\concat\declsthree}{\compdecls}
}
\end{mathpar}

\section{Semantics of Specifications\label{sec:SemanticsOfSpecifications}}
The semantics of specifications is defined via the relation $\evalspec$, which is defined next.

\SemanticsRuleDef{EvalSpec}
The relation
\hypertarget{def-evalspec}{}
\[
  \evalspec(\overname{\staticenvs}{\tenv} \aslsep \overname{\spec}{\vspec}) \;\aslrel\;
   ((\overname{\tint}{\vv}\times \overname{\XGraphs}{\vg}) \cup \overname{\TDynError}{\DynErrorConfig})
\]
evaluates the specification $\vspec$ with the static environment $\tenv$,
yielding the native integer value $\vv$ and execution graph $\vg$.
Otherwise, the result is a dynamic error.

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item \Prosebuildgenv{$\tenv$}{$\spec$}{$\env$}{$\vg$}\ProseOrError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{normal}):
    \begin{itemize}
      \item evaluating the subprogram \texttt{main} with an empty list of actual arguments and empty list of parameters
      in $\env$ yields $\Normal([(\vv, \vgtwo)], \Ignore)$\ProseOrError;
      \item $\vg$ is the ordered composition of $\vgone$ and $\vgtwo$ with the $\aslpo$ edge;
      \item the result of the entire evaluation is $(\vv, \vg)$.
    \end{itemize}

    \item All of the following apply (\textsc{throwing}):
    \begin{itemize}
      \item evaluating the subprogram \texttt{main} with an empty list of actual arguments and empty list of parameters
      in $\env$ yields $\Throwing(\vvopt, \Ignore)$, which is an uncaught exception;
      \item the result of the entire evaluation is an error indicating that an exception was not caught.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[normal]{
  \buildgenv(\tenv, \vspec) \evalarrow (\env, \vgone) \OrDynError\\\\
  \evalsubprogram{\env, \texttt{"main"}, \emptylist, \emptylist} \evalarrow \Normal([(\vv, \vgtwo)], \Ignore) \OrDynError\\\\
  \vg \eqdef \ordered{\vgone}{\aslpo}{\vgtwo}
}{
  \evalspec(\tenv, \vspec) \evalarrow (\vv, \vg)
}
\end{mathpar}

\begin{mathpar}
\inferrule[throwing]{
  \buildgenv(\tenv, \vspec) \evalarrow (\env, \vgone) \OrDynError\\\\
  \evalsubprogram{\env, \texttt{"main"}, \emptylist, \emptylist} \evalarrow \Throwing(\vvopt, \Ignore)
}{
  \evalspec(\tenv, \vspec) \evalarrow \DynamicErrorVal{\UncaughtException}
}
\end{mathpar}
\CodeSubsection{\EvalSpecBegin}{\EvalSpecEnd}{../Interpreter.ml}

\SemanticsRuleDef{BuildGlobalEnv}
The helper relation
\hypertarget{def-buildgenv}{}
\[
  \buildgenv(\overname{\staticenvs}{\tenv}, \overname{\spec}{\typedspec}) \;\aslrel\;
  (\overname{\envs}{\newenv}\times\overname{\XGraphs}{\newg}) \cup \overname{\TDynError}{\DynErrorConfig}
\]
populates the environment $\env$ and output execution graph $\newg$ with the global
storage declarations in $\typedspec$, starting from the static environment $\tenv$.
This works by traversing the global storage declarations
and updating the environment accordingly.
\ProseOtherwiseDynamicError

It is assumed that $\typedspec$ lists the declarations in reverse order with respect
to the \defusedependencyterm\ order
(see \TypingRuleRef{TypeCheckAST}).

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item define the environment $\env$ as consisting of the static environment $\tenv$ and the empty dynamic environment $\emptydenv$;
  \item evaluating the global storage declarations in $\typedspec$ in $\env$ with the empty execution graph
        is $(\newenv, \newg)$\ProseOrError.
  \item the result of the entire evaluation is $(\newenv, \newg)$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \env \eqdef (\tenv, \emptydenv)\\
  \evalglobals(\typedspec, (\env, \emptygraph)) \evalarrow (\newenv, \newg) \OrDynError
}{
  \buildgenv(\tenv, \typedspec) \evalarrow (\newenv, \newg)
}
\end{mathpar}
\CodeSubsection{\EvalBuildGlobalEnvBegin}{\EvalBuildGlobalEnvEnd}{../Interpreter.ml}
