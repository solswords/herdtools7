\chapter{Types\label{chap:Types}}

Types describe the allowed values of variables, constants, function arguments, etc.
\lrmcomment{\identi{BYVL}}
This chapter first defines for each type how it is represented by the ASL syntax,
by the abstract syntax, and how it is typechecked:
\begin{itemize}
  \item Integer types (see \secref{IntegerTypes})
  \item The real type (see \secref{RealType})
  \item The string type (see \secref{StringType})
  \item The Boolean type (see \secref{BooleanType})
  \item Bitvector types (see \secref{BitvectorTypes})
  \item Tuple types (see \secref{TupleTypes})
  \item Array types (see \secref{ArrayTypes})
  \item Enumeration types (see \secref{EnumerationTypes})
  \item Record types (see \secref{RecordTypes})
  \item Exception types (see \secref{ExceptionTypes})
  \item Named types (see \secref{NamedTypes})
\end{itemize}

\Anonymoustypes\ are grammatically derived from the non-terminal $\Nty$
and types that must be declared and named are grammatically derived from the non-terminal $\Ntydecl$.
All types are represented as ASTs derived from the AST non-terminal $\ty$.

\hypertarget{build-ty}{}
The function
\[
  \buildty(\overname{\parsenode{\Nty}}{\vparsednode}) \;\aslto\; \overname{\ty}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms an anonymous type parse node $\vparsednode$ into a type AST node $\vastnode$.
\ProseOtherwiseBuildError

\hypertarget{build-as-ty}{}
The function
\[
  \buildasty(\overname{\parsenode{\Nasty}}{\vparsednode}) \;\aslto\; \overname{\ty}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms a type annotation parse node $\vparsednode$ into a type AST node $\vastnode$.
\ProseOtherwiseBuildError

Formally:

\begin{mathpar}
\inferrule{
  \buildty(\vt) \astarrow \astversion{\vt}
} {
  \buildasty(\Tcolon, \namednode{\vt}{\Nty}) \astarrow \astversion{\vt}
}
\end{mathpar}

\hypertarget{build-tydecl}{}
The function
\[
  \buildtydecl(\overname{\parsenode{\Ntydecl}}{\vparsednode}) \;\aslto\; \overname{\ty}{\vastnode}
  \cup \overname{\TBuildError}{\BuildErrorConfig}
\]
transforms a \namedtype\ parse node $\vparsednode$ into an AST node $\vastnode$.
\ProseOtherwiseBuildError

\hypertarget{def-annotatetype}{}
The function
\[
  \annotatetype{\overname{\Bool}{\vdecl} \aslsep \overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\tty}}
  \aslto (\overname{\ty}{\newty} \times \overname{\TSideEffectSet}{\vses}) \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
typechecks a type $\tty$ in an environment $\tenv$, resulting in a \typedast\ $\newty$
and a \sideeffectsetterm\ $\vses$.
The flag $\decl$ indicates whether $\tty$ is a type currently being declared,
and makes a difference only when $\tty$ is an enumeration type or a \structuredtype.
\ProseOtherwiseTypeError

Types are not associated with a semantic relation.

The rest of this chapter defines the following aspects of types:
\begin{itemize}
\item \secref{DomainOfValuesForTypes} defines how values are associated with each type.
\item \secref{BasicTypeAttributes} assigns basic properties to types, which are useful
in classifying them.
\item \secref{RelationsOnTypes} defines relations on types that are needed to typecheck
expressions and statements.
\item \secref{BaseValues} defines how to produce an expression to initialize storage
      elements of a given type (for which no initializing expression is supplied).
\end{itemize}

\hypertarget{integertypeterm}{}
\section{Integer Types\label{sec:IntegerTypes}}
\begin{center}
\begin{tabular}{lll}
\hline
\secreflink{IntegerTypesSyntax} & \secreflink{IntegerTypesAST} & \secreflink{TypingIntegerTypes}\\
& \secreflink{ASTRule.Ty.TInt} & \secreflink{TypingRule.TInt}\\
& \secreflink{ASTRule.IntConstraintsOpt} & \secreflink{TypingRule.AnnotateConstraint}\\
& \secreflink{ASTRule.IntConstraints} & \\
& \secreflink{ASTRule.IntConstraint} &\\
\hline
\end{tabular}
\end{center}

\subsection{Syntax\label{sec:IntegerTypesSyntax}}
\begin{flalign*}
\Nty \derives\ & \Tinteger \parsesep \Nconstraintkindopt &\\
\Nconstraintkindopt \derives \ & \Nconstraintkind \;|\; \emptysentence &\\
\Nconstraintkind \derives \ & \Tlbrace \parsesep \ClistOne{\Nintconstraint} \parsesep \Trbrace &\\
|\ & \Tlbrace \parsesep \Tminus \parsesep \Trbrace &\\
\Nintconstraint \derives \ & \Nexpr &\\
|\ & \Nexpr \parsesep \Tslicing \parsesep \Nexpr &
\end{flalign*}

\subsection{Abstract Syntax\label{sec:IntegerTypesAST}}
\begin{flalign*}
\ty \derives\ & \TInt(\constraintkind)\\
\constraintkind \derives\ & \unconstrained
& \\
|\ & \wellconstrained(\intconstraint^{+})
& \\
|\ & \pendingconstrained{}
& \\
|\ & \parameterized(\overtext{\identifier}{parameter}) &\\
\intconstraint \derives\ & \ConstraintExact(\expr)
& \\
|\ & \ConstraintRange(\overtext{\expr}{start}, \overtext{\expr}{end})&
\end{flalign*}

\ASTRuleDef{Ty.TInt}
\begin{mathpar}
\inferrule[integer]{}{
  \buildty(\Nty(\Tinteger, \punnode{\Nconstraintkindopt})) \astarrow
  \overname{\TInt(\astof{\vconstraintkindopt})}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{IntConstraintsOpt}
\hypertarget{build-constraintkindopt}{}
The function
\[
  \buildconstraintkindopt(\overname{\parsenode{\Nconstraintkindopt}}{\vparsednode}) \;\aslto\; \overname{\constraintkind}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[constrained]{}{
  {
    \begin{array}{r}
  \buildconstraintkindopt(\Nconstraintkindopt(\punnode{\Nconstraintkind})) \astarrow \\
  \overname{\astof{\vconstraintkind}}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[unconstrained]{}{
  \buildconstraintkindopt(\Nconstraintkindopt(\emptysentence)) \astarrow
  \overname{\unconstrained}{\vastnode}
}
\end{mathpar}

\subsection{ASTRule.IntConstraints\label{sec:ASTRule.IntConstraints}}
\hypertarget{build-constraintkind}{}
The function
\[
  \buildconstraintkind(\overname{\parsenode{\Nconstraintkind}}{\vparsednode}) \;\aslto\; \overname{\constraintkind}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[well\_constrained]{
  \buildclist[\buildintconstraint](\vconstraints) \astarrow \vconstraintasts
}{
  {
    \begin{array}{r}
  \buildconstraintkind(\Nconstraintkind(\Tlbrace, \namednode{\vconstraints}{\ClistOne{\Nintconstraint}}, \Trbrace)) \astarrow\\
  \overname{\wellconstrained(\vconstraintasts)}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[pending\_constrained]{}{
  \buildconstraintkind(\Nconstraintkind(\Tlbrace, \Tminus, \Trbrace)) \astarrow
  \overname{\pendingconstrained}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{IntConstraint}
\hypertarget{build-intconstraint}{}
The function
\[
  \buildintconstraint(\overname{\parsenode{\Nintconstraint}}{\vparsednode}) \;\aslto\; \overname{\intconstraint}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[exact]{}{
  \buildintconstraint(\Nintconstraint(\punnode{\Nexpr})) \astarrow
  \overname{\ConstraintExact(\astof{\vexpr})}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \buildexpr(\vfromexpr) \astarrow \astversion{\vfromexpr}\\
  \buildexpr(\vtoexpr) \astarrow \astversion{\vtoexpr}\\
}{
  {
    \begin{array}{r}
  \buildintconstraint(\Nintconstraint(\namednode{\vfromexpr}{\Nexpr}, \Tslicing, \namednode{\vtoexpr}{\Nexpr})) \astarrow\\
  \overname{\ConstraintRange(\astversion{\vfromexpr}, \astversion{\vtoexpr})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing Integer Types\label{sec:TypingIntegerTypes}}
\TypingRuleDef{TInt}
\subsubsection{Example}
In \listingref{typing-unconstrained}, \listingref{typing-wellconstrained},
and \listingref{typing-parameterized} all examples of
\unconstrainedintegertypes, \wellconstrainedintegertypes,
and \parameterizedintegertypes, respectively, are well-typed.
\ASLListing{Well-typed unconstrained integer types}{typing-unconstrained}{\typingtests/TypingRule.TIntUnConstrained.asl}
\ASLListing{Well-typed well-constrained integer types}{typing-wellconstrained}{\typingtests/TypingRule.TIntWellConstrained.asl}
\ASLListing{Well-typed parameterized integer types}{typing-parameterized}{\typingtests/TypingRule.TIntParameterized.asl}

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{pending\_constrained}):
    \begin{itemize}
      \item $\tty$ is a \pendingconstrainedintegertype;
      \item the result is a type error (\UnexpectedType).
    \end{itemize}
  \item All of the following apply (\textsc{well\_constrained}):
    \begin{itemize}
      \item $\tty$ is the well-constrained integer type constrained by
        constraints $\vc_i$, for $u=1..k$;
      \item annotating each constraint $\vc_i$, for $i=1..k$,
      yields $(\newc_i, \vxs_i)$\ProseOrTypeError;
      \item $\newconstraints$ is the list of annotated constraints $\newc_i$,
      for $i=1..k$;
      \item $\newty$ is the well-constrained integer type constrained
        by $\newconstraints$;
      \item define $\vses$ as the union of all $\vxs_i$, for $i=1..k$.
    \end{itemize}

    \item All of the following apply (\textsc{parameterized}):
    \begin{itemize}
      \item $\tty$ is a \parameterizedintegertype\ for $\name$;
      \item define $\vses$ as the singleton set for the singleton \sideeffectdescriptorterm,
            \ReadLocalTerm\ for $\name$, \timeframeconstant, and $\True$ for immutability.
      \item $\newty$ is the unconstrained integer type.
    \end{itemize}

    \item All of the following apply (\textsc{unconstrained}):
    \begin{itemize}
      \item $\tty$ is an \unconstrainedintegertype;
      \item $\newty$ is the unconstrained integer type;
      \item define $\vses$ as the empty set.
    \end{itemize}
  \end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[pending\_constrained]{}{
  {
    \begin{array}{r}
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TInt(\pendingconstrained)}{\tty}} \typearrow
  \TypeErrorVal{\UnexpectedType}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[well\_constrained]{
  \constraints \eqname \vc_{1..k}\\
  i=1..k: \annotateconstraint(\vc_i) \typearrow (\newc_i, \vxs_i) \OrTypeError\\\\
  \newconstraints \eqdef \newc_{1..k}\\
  \vses \eqdef \bigcup_{i=1..k} \vxs_i
}{
  {
    \begin{array}{r}
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TInt(\wellconstrained(\constraints))}{\tty}} \typearrow \\
  (\overname{\TInt(\wellconstrained(\newconstraints))}{\newty}, \vses)
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[parameterized]{
  \tty \eqname \TInt(\parameterized(\name))\\
  \vses \eqdef \{\ \ReadLocal(\name, \timeframeconstant, \True)\ \}
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \tty} \typearrow (\overname{\tty}{\newty}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[unconstrained]{
  \tty \eqname \unconstrainedinteger
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \tty} \typearrow (\overname{\tty}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}

\CodeSubsection{\TIntBegin}{\TIntEnd}{../Typing.ml}

\TypingRuleDef{AnnotateConstraint}
\hypertarget{def-annotateconstraint}{}
The function
\[
\annotateconstraint(\overname{\staticenvs}{\tenv} \aslsep \overname{\intconstraint}{\vc})
\aslto (\overname{\intconstraint}{\newc} \times \overname{\TSideEffectSet}{\vses}) \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates an integer constraint $\vc$ in the static environment $\tenv$ yielding the annotated
integer constraint $\newc$ and \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{exact}):
  \begin{itemize}
    \item $\vc$ is the exact integer constraint for the expression $\ve$, that is, \\ $\ConstraintExact(\ve)$;
    \item applying $\annotatesymbolicconstrainedinteger$ to $\ve$ in $\tenv$ yields $(\vep, \vses)$\ProseOrTypeError;
    \item define $\newc$ as the exact integer constraint for $\vep$, that is, $\ConstraintExact(\vep)$.
  \end{itemize}

  \item All of the following apply (\textsc{range}):
  \begin{itemize}
    \item $\vc$ is the range integer constraint for expressions $\veone$ and $\vetwo$, that is, \\ $\ConstraintRange(\veone, \vetwo)$;
    \item applying $\annotatesymbolicconstrainedinteger$ to $\veone$ in $\tenv$ yields\\ $(\veonep, \vsesone)$\ProseOrTypeError;
    \item applying $\annotatesymbolicconstrainedinteger$ to $\vetwo$ in $\tenv$ yields\\ $(\vetwop, \vsestwo)$\ProseOrTypeError;
    \item define $\newc$ as the range integer constraint for expressions $\veonep$ and $\vetwop$, that is, $\ConstraintRange(\veonep, \vetwop)$;
    \item define $\vses$ as the union of $\vsesone$ and $\vsestwo$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \annotatesymbolicconstrainedinteger(\tenv, \ve) \typearrow (\vep, \vses) \OrTypeError
}{
  \annotateconstraint(\tenv, \overname{\ConstraintExact(\ve)}{\vc}) \typearrow (\overname{\ConstraintExact(\vep)}{\newc}, \vses)
}
\and
\inferrule[range]{
  \annotatesymbolicconstrainedinteger(\tenv, \veone) \typearrow (\veonep, \vsesone) \OrTypeError\\\\
  \annotatesymbolicconstrainedinteger(\tenv, \vetwo) \typearrow (\vetwop, \vsestwo) \OrTypeError\\\\
  \vses \eqdef \vsesone \cup \vsestwo
}{
  \annotateconstraint(\tenv, \overname{\ConstraintRange(\veone, \vetwo)}{\vc}) \typearrow \overname{\ConstraintRange(\veonep, \vetwop)}{\newc}
}
\end{mathpar}

\hypertarget{realtypeterm}{}
\section{The Real Type\label{sec:RealType}}
\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Treal &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TReal &
\end{flalign*}

\ASTRuleDef{TReal}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Treal)) \astarrow
  \overname{\TReal}{\vastnode}
}
\end{mathpar}

\subsection{Typing the Real Type\label{sec:TypingRealType}}
\TypingRuleDef{TReal}
\subsubsection{Example}
In \listingref{typing-treal}, all the uses of \texttt{real} are well-typed.
\ASLListing{Well-typed real types}{typing-treal}{\typingtests/TypingRule.TReal.asl}

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is the real type \TReal.
  \item $\newty$ is the real type \TReal;
  \item define $\vses$ as the empty set.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TReal}{\tty}} \typearrow (\overname{\TReal}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\TRealBegin}{\TRealEnd}{../Typing.ml}

\hypertarget{stringtypeterm}{}
\section{The String Type\label{sec:StringType}}
\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tstring &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TString&
\end{flalign*}

\ASTRuleDef{Ty.String}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Tstring)) \astarrow
  \overname{\TString}{\vastnode}
}
\end{mathpar}

\subsection{Typing the String Type\label{sec:TypingStringType}}
\TypingRuleDef{TString}
\subsubsection{Example}
In \listingref{typing-tstring}, all the uses of \texttt{string} are well-typed.
\ASLListing{Well-typed string types}{typing-tstring}{\typingtests/TypingRule.TString.asl}

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is the string type \TString.
  \item $\newty$ is the string type \TString.
  \item $\vses$ is the empty set.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TString}{\tty}} \typearrow (\overname{\TString}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\TStringBegin}{\TStringEnd}{../Typing.ml}

\hypertarget{booleantypeterm}{}
\section{The Boolean Type\label{sec:BooleanType}}
\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tboolean &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TBool &
\end{flalign*}

\ASTRuleDef{Ty.BoolType}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Tboolean)) \astarrow
  \overname{\TBool}{\vastnode}
}
\end{mathpar}

\subsection{Typing the Boolean Type\label{sec:TypingBooleanType}}
\TypingRuleDef{TBool}
\subsubsection{Example}
In \listingref{typing-tbool}, all the uses of \texttt{boolean} are well-typed.
\ASLListing{Well-typed Boolean types}{typing-tbool}{\typingtests/TypingRule.TBool.asl}

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is the boolean type, \TBool;
  \item $\newty$ is the boolean type, \TBool;
  \item define $\vses$ as the empty set.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}
{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TBool}{\tty}} \typearrow (\overname{\TBool}{\newty}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\TBoolBegin}{\TBoolEnd}{../Typing.ml}

\hypertarget{bitvectortypeterm}{}
\section{Bitvector Types\label{sec:BitvectorTypes}}
\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tbit &\\
            |\ & \Tbits \parsesep \Tlpar \parsesep \Nexpr \parsesep \Trpar \parsesep \option{\Nbitfields} &\\
\Nbitfields \derives \ & \Tlbrace \parsesep \TClistZero{\Nbitfield} \parsesep \Trbrace &\\
\Nbitfield \derives \ & \Nslices \parsesep \Tidentifier &\\
                  |\ & \Nslices \parsesep \Tidentifier \parsesep \Nbitfields &\\
                  |\ & \Nslices \parsesep \Tidentifier \parsesep \Tcolon \parsesep \Nty &\\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TBits(\overtext{\expr}{width}, \bitfield^{*}) &
\end{flalign*}

\ASTRuleDef{Ty.TBits}
\begin{mathpar}
\inferrule[bit]{}{
  \buildty(\Nty(\Tbit)) \astarrow
  \overname{\TBits(\ELiteral(\lint(1)), \emptylist)}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[bits]{
  \buildlist[\buildbitfield](\vbitfields) \astarrow \vbitfieldasts
}{
  {
    \begin{array}{r}
  \buildty(\Nty(\Tbits, \Tlpar, \punnode{\Nexpr}, \Trpar, \namednode{\vbitfields}{\maybeemptylist{\Nbitfields}})) \astarrow\\
  \overname{\TBits(\astof{\vexpr}, \vbitfieldasts)}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Typing}
\TypingRuleDef{TBits}
\subsubsection{Example}
In \listingref{typing-tbits}, all the uses of bitvector types are well-typed.
\ASLListing{Well-typed Bitevector types}{typing-tbits}{\typingtests/TypingRule.TBits.asl}

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is the bit-vector type with width given by the expression
    $\ewidth$ and the bitfields given by $\bitfields$, that is, $\TBits(\ewidth, \bitfields)$;
  \item annotating the expression $\ewidth$ yields $(\twidth, \ewidthp, \seswidth)$\ProseOrTypeError;
  \item \Prosechecksymbolicallyevaluable{\seswidth};
  \item \Prosecheckconstrainedinteger{$\tenv$}{$\twidth$};
  \item annotating the bitfields $\bitfields$ yields $(\bitfieldsp, \vsesbitfields)$\ProseOrTypeError;
  \item \Prosestaticeval{$\tenv$}{$\ewidthp$}{$\lint(\vwidth)$};
  \item \Prosecheckcommonbitfieldsalign{$\tenv$}{$\bitfieldsp$}{$\vwidth$}\ProseOrTypeError;
  \item $\newty$ is the bit-vector type with width given by the expression
    $\ewidthp$ and the bitfields given by $\bitfieldsp$, that is, $\TBits(\ewidthp, \bitfieldsp)$;
  \item define $\vses$ as the union of $\seswidth$ and $\vsesbitfields$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ewidth} \typearrow (\twidth, \ewidthp, \seswidth) \OrTypeError\\\\
  \checksymbolicallyevaluable(\seswidth) \typearrow \True \OrTypeError\\\\
  \checkconstrainedinteger(\tenv, \twidth) \typearrow \True \OrTypeError\\\\
  \annotatebitfields(\tenv, \ewidthp, \bitfields) \typearrow (\bitfieldsp, \vsesbitfields) \OrTypeError\\\\
  \staticeval(\tenv, \ewidthp) \typearrow \lint(\vwidth)\\
  \checkcommonbitfieldsalign(\tenv, \bitfieldsp, \vwidth) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \seswidth \cup \vsesbitfields
}{
  {
    \begin{array}{r}
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \TBits(\ewidth, \bitfields)} \typearrow \\
  (\overname{\TBits(\ewidthp, \bitfieldsp)}{\newty}, \vses)
    \end{array}
  }
}
\end{mathpar}
\CodeSubsection{\TBitsBegin}{\TBitsEnd}{../Typing.ml}

\subsubsection{Comments}
The width of a bitvector type $\TBits(\ewidth, \bitfields)$, given by the expression \\
$\ewidth$,
must be non-negative.

\hypertarget{tupletypeterm}{}
\section{Tuple Types\label{sec:TupleTypes}}
\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \PlistZero{\Nty} &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TTuple(\ty^{*}) &
\end{flalign*}

\ASTRuleDef{Ty.TTuple}
\begin{mathpar}
\inferrule{
  \buildplist[\buildty](\vtypes) \astarrow \vtypeasts
}{
  \buildty(\Nty(\namednode{\vtypes}{\PlistZero{\Nty}})) \astarrow
  \overname{\TTuple(\vtypeasts)}{\vastnode}
}
\end{mathpar}

\subsection{Typing Tuple Types\label{sec:TypingTupleTypes}}
\subsubsection{Example}
In \listingref{typing-ttuple}, all the uses of tuple types are well-typed.
\ASLListing{Well-typed tuple types}{typing-ttuple}{\typingtests/TypingRule.TTuple.asl}

\TypingRuleDef{TTuple}
\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is the tuple type with member types $\tys$, that is, $\TTuple(\tys)$;
  \item $\tys$ is the list $\tty_i$, for $i=1..k$;
  \item annotating each type $\tty_i$ in $\tenv$, for $i=1..k$,
  yields $(\ttyp_i, \vxs_i)$\ProseOrTypeError;
  \item $\newty$ is the tuple type with member types $\ttyp$, for $i=1..k$;
  \item define $\vses$ as the union of all $\vxs_i$, for $i=1..k$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  k \geq 2\\
  \tys \eqname \tty_{1..k}\\
  i=1..k: \annotatetype{\False, \tenv, \tty_i} \typearrow (\ttyp_i, \vxs_i) \OrTypeError\\
  \vses \eqdef \bigcup_{i=1..k} \vxs_i
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \TTuple(\tys)} \typearrow (\overname{\TTuple(\tysp)}{\newty}, \vses)
}
\end{mathpar}
\CodeSubsection{\TTupleBegin}{\TTupleEnd}{../Typing.ml}

\hypertarget{arraytypeterm}{}
\section{Array Types\label{sec:ArrayTypes}}
ASL offers two kinds of arrays:
\begin{description}
  \item[Integer-indexed arrays] representing a consecutive list of elements at positions $0$ to the size
      specified for the array. The array elements can be accessed via an \texttt{integer}
      type that specifies the $0$-based position of the element to read/update.
  \item[Enumeration-indexed arrays] representing a dictionary-like data type where the keys are defined
      by a given enumeration type. The array elements can be accessed via values of the \texttt{enumeration}
      type specified for the array type.
\end{description}

\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tarray \parsesep \Tllbracket \parsesep \Nexpr \parsesep \Trrbracket \parsesep \Tof \parsesep \Nty &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TArray(\arrayindex, \ty) &\\
\arrayindex \derives\ &  \ArrayLengthExpr(\overtext{\expr}{array length}) &
\end{flalign*}

\ASTRuleDef{Ty.TArray}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Tarray, \Tllbracket, \punnode{\Nexpr}, \Trrbracket, \Tof, \punnode{\Nty})) \astarrow
  \overname{\TArray(\ArrayLengthExpr(\astof{\vexpr}), \astof{\tty})}{\vastnode}
}
\end{mathpar}
\subsection{Typing Array Types\label{sec:TypingArrayTypes}}
\subsubsection{Example}
In \listingref{typing-tarray}, all the uses of array types are well-typed.
\ASLListing{Well-typed array types}{typing-tarray}{\typingtests/TypingRule.TArray.asl}

\TypingRuleDef{TArray}
\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is the array type with element type $\vt$;
  \item Annotating the type $\vt$ in $\tenv$ yields $(\vtp, \vsest)$\ProseOrTypeError;
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{expr\_is\_enum}):
    \begin{itemize}
      \item the array index is $\ve$ and determining whether $\ve$ corresponds to an enumeration in $\tenv$
      via $\getvariableenum$ yields the enumeration variable
      name $\vs$ of size $\vi$, that is, $\langle \vs, \vi \rangle$\ProseOrTypeError;
      \item $\newty$ is the array type indexed by an enumeration type
      named $\vs$ of length $\vi$ and of elements of type $\vtp$, that is, $\TArray(\ArrayLengthEnum(\vs, \vi), \vtp)$;
      \item define $\vses$ as $\vsest$.
    \end{itemize}

    \item All of the following apply (\textsc{expr\_not\_enum}):
    \begin{itemize}
      \item the array index is $\ve$ and determining whether $\ve$ corresponds to an enumeration in $\tenv$
      via $\getvariableenum$ yields $\None$ (meaning it does not
      correspond to an enumeration)\ProseOrTypeError;
      \item annotating the \symbolicallyevaluable{} integer expression $\ve$ yields\\
      $(\vep, \vsesindex)$\ProseOrTypeError;
      \item $\newty$ the array type indexed by integer bounded by
      the expression $\vep$ and of elements of type $\vtp$, that is,
      $\TArray(\ArrayLengthExpr(\vep), \vtp)$;
      \item define $\vses$ as the union of $\vsest$ and $\vsesindex$.
    \end{itemize}
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[expr\_is\_enum]{
  \annotatetype{\False, \tenv, \vt} \typearrow (\vtp, \vsest) \OrTypeError\\\\
  \commonprefixline\\\\
  \getvariableenum(\tenv, \ve) \typearrow \langle \vs, \vlabels \rangle\OrTypeError
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\AbbrevTArrayLengthExpr{\ve}{\vt}}{\tty}} \typearrow
  (\overname{\AbbrevTArrayLengthEnum{\ve}{\vlabels}{\vtp}}{\newty}, \overname{\emptyset}{\vsest})
}
\end{mathpar}

\begin{mathpar}
\inferrule[expr\_not\_enum]{
  \annotatetype{\False, \tenv, \vt} \typearrow (\vtp, \vsest) \OrTypeError\\\\
  \commonprefixline\\\\
  \getvariableenum(\tenv, \ve) \typearrow \None \OrTypeError\\\\
  \annotatesymbolicinteger(\tenv, \ve) \typearrow (\vep, \vsesindex) \OrTypeError\\\\
  \vses \eqdef \vsest \cup \vsesindex
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\AbbrevTArrayLengthExpr{\ve}{\vt}}{\tty}} \typearrow
  (\overname{\AbbrevTArrayLengthExpr{\vep}{\vtp}}{\newty}, \vses)
}
\end{mathpar}
\CodeSubsection{\TArrayBegin}{\TArrayEnd}{../Typing.ml}

\TypingRuleDef{GetVariableEnum}
\hypertarget{def-getvariableenum}{}
The function
\[
\getvariableenum(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
\langle (\overname{\identifier}{\vx}, \overname{\identifier^+}{\vlabels})\rangle
\]
tests whether the expression $\ve$ represents a variable of an enumeration type.
If so, the result is $\vx$ --- the name of the variable and the list of labels $\vlabels$,
declared for the enumeration type.
Otherwise, the result is $\None$.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{not\_evar}):
  \begin{itemize}
    \item $\ve$ is not a variable expression;
    \item the result is $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{no\_declared\_type}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item $\vx$ is not associated with a type in the global environment of $\tenv$;
    \item the result is $\None$.
  \end{itemize}

  \item All of the following apply (\textsc{declared\_enum}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item $\vx$ is associated with a type $\vt$ in the global environment of $\tenv$;
    \item obtaining the \underlyingtype\ of $\vt$ in $\tenv$ yields an enumeration type with labels $\vlabels$\ProseOrTypeError;
    \item the result is the pair consisting of $\vx$ and $\vlabels$.
  \end{itemize}

  \item All of the following apply (\textsc{declared\_not\_enum}):
  \begin{itemize}
    \item $\ve$ is a variable expression for $\vx$, that is, $\EVar(\vx)$;
    \item $\vx$ is associated with a type $\vt$ in the global environment of $\tenv$;
    \item obtaining the \underlyingtype\ of $\vt$ in $\tenv$ yields a type that is not an enumeration type;
    \item the result is $\None$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[not\_evar]{
  \astlabel(\ve) \neq \EVar
}{
  \getvariableenum(\tenv, \ve) \typearrow \None
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_declared\_type]{
  G^\tenv.\declaredtypes(\vx) = \bot
}{
  \getvariableenum(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \None
}
\end{mathpar}

\begin{mathpar}
\inferrule[declared\_enum]{
  G^\tenv.\declaredtypes(\vx) = (\vt, \Ignore)\\
  \makeanonymous(\tenv, \vt) \typearrow \TEnum(\vlabels) \OrTypeError
}{
  \getvariableenum(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \langle(\vx, \vlabels)\rangle
}
\end{mathpar}

\begin{mathpar}
\inferrule[declared\_not\_enum]{
  G^\tenv.\declaredtypes(\vx) = (\vt, \Ignore)\\
  \makeanonymous(\tenv, \vt) \typearrow \vtone\\
  \astlabel(\vtone) \neq \TEnum
}{
  \getvariableenum(\tenv, \overname{\EVar(\vx)}{\ve}) \typearrow \None
}
\end{mathpar}

\TypingRuleDef{AnnotateSymbolicallyEvaluableExpr}
\hypertarget{def-annotatesymbolicallyevaluableexpr}{}
The function
\[
\begin{array}{r}
  \annotatesymbolicallyevaluableexpr(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto \\
  (\overname{\ty}{\vt}\times\overname{\expr}{\vep}\times\overname{\TSideEffectSet}{\vses}) \cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the expression $\ve$ in the static environment $\tenv$ and checks that it is \symbolicallyevaluable,
yielding the resulting type in $\vt$, the annotated expression in $\vep$ and the \sideeffectsetterm\ in $\vses$.
\ProseOtherwiseTypeError

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item \Proseannotateexpr{$\tenv$}{$\ve$}{$(\vt, \vep, \vses)$};
  \item \Prosechecksymbolicallyevaluable{$\vses$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \ve} \typearrow (\vt, \vep, \vses) \OrTypeError\\\\
  \checksymbolicallyevaluable(\vses) \typearrow \True \OrTypeError
}{
  \annotatesymbolicallyevaluableexpr(\tenv, \ve) \typearrow (\vt, \vep, \vses)
}
\end{mathpar}
\CodeSubsection{\AnnotateSymbolicallyEvaluableExprBegin}{\AnnotateSymbolicallyEvaluableExprEnd}{../Typing.ml}

\TypingRuleDef{AnnotateSymbolicInteger}
\hypertarget{def-annotatesymbolicinteger}{}
The function
\[
  \annotatesymbolicinteger(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ve}) \aslto
  (\overname{\expr}{\vepp} \times \overname{\TSideEffectSet}{\vses}) \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a \symbolicallyevaluable\ integer expression $\ve$ in the static environment $\tenv$
and returns the annotated expression $\vepp$ and \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item \Proseannotatesymbolicallyevaluableexpr{$\tenv$}{$\ve$}{$(\vt, \vep, \vses)$\ProseOrTypeError};
  \item determining whether $\vt$ has the structure of an integer yields $\True$\ProseOrTypeError;
  \item determining whether $\vep$ is \symbolicallyevaluable\ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item applying $\normalize$ to $\vep$ in $\tenv$ yields $\vepp$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatesymbolicallyevaluableexpr(\tenv, \ve) \typearrow (\vt, \vep, \vses) \OrTypeError\\\\
  \checkstructureinteger(\tenv, \vt) \typearrow \True \OrTypeError\\\\
  \checksymbolicallyevaluable(\tenv, \vep) \typearrow \True \OrTypeError\\\\
  \normalize(\tenv, \vep) \typearrow \vepp
}{
  \annotatesymbolicinteger(\tenv, \ve) \typearrow (\vepp, \vses)
}
\end{mathpar}
\CodeSubsection{\AnnotateSymbolicIntegerBegin}{\AnnotateSymbolicIntegerEnd}{../Typing.ml}

\hypertarget{def-checkstructureinteger}{}
\TypingRuleDef{CheckStructureInteger}
The function
\[
  \checkstructureinteger(\overname{\staticenvs}{\tenv} \aslsep \overname{\ty}{\vt}) \aslto
  \{\True\} \cup \TTypeError
\]
returns $\True$ is $\vt$ is has the \structure\ an integer type and a type error otherwise.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{okay}):
  \begin{itemize}
    \item determining the \structure\ of $\vt$ yields $\vtp$\ProseOrTypeError;
    \item $\vtp$ is an integer type;
    \item the result is $\True$;
  \end{itemize}

  \item All of the following apply (\textsc{error}):
  \begin{itemize}
    \item determining the \structure\ of $\vt$ yields $\vtp$\ProseOrTypeError;
    \item $\vtp$ is not an integer type;
    \item the result is a type error indicating that $\vt$ was expected to have the \structure\ of an integer.
  \end{itemize}
\end{itemize}

\CodeSubsection{\CheckStructureIntegerBegin}{\CheckStructureIntegerEnd}{../Typing.ml}

\FormallyParagraph
\begin{mathpar}
\inferrule[okay]{
  \tstruct(\vt) \typearrow \vtp \OrTypeError\\\\
  \astlabel(\vtp) = \TInt
}
{
  \checkstructureinteger(\tenv, \vt) \typearrow \True
}
\and
\inferrule[error]{
  \tstruct(\vt) \typearrow \vtp\\
  \astlabel(\vtp) \neq \TInt
}
{
  \checkstructureinteger(\tenv, \vt) \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}

\hypertarget{enumerationtypeterm}{}
\section{Enumeration Types\label{sec:EnumerationTypes}}
\subsection{Syntax}
\begin{flalign*}
\Ntydecl \derives\ & \Tenumeration \parsesep \Tlbrace \parsesep \TClistOne{\Tidentifier} \parsesep \Trbrace &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TEnum(\overtext{\identifier^{*}}{labels}) &
\end{flalign*}

\ASTRuleDef{TyDecl.TEnum}
\begin{mathpar}
\inferrule{
  \buildtclist[\buildidentity](\vids) \astarrow \vidasts
}{
  {
    \begin{array}{r}
  \buildtydecl(\Ntydecl(\Tenumeration, \Tlbrace, \namednode{\vids}{\TClistOne{\Tidentifier}}, \Trbrace)) \astarrow\\
  \overname{\TEnum(\vidasts)}{\vastnode}
\end{array}
  }
}
\end{mathpar}

\subsection{Typing Enumeration Types\label{sec:TypingEnumerationTypes}}
\TypingRuleDef{TEnumDecl}

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is the enumeration type with enumeration literals
    $\vli$, that is, $\TEnum(\vli)$;
  \item $\decl$ is $\True$, indicating that $\tty$ should be considered in the context of a declaration;
  \item determining that $\vli$ does not contain duplicates yields $\True$\ProseOrTypeError;
  \item determining that none of the labels in $\vli$ is declared in the global environment
  yields $\True$\ProseOrTypeError;
  \item $\newty$ is the enumeration type $\tty$;
  \item define $\vses$ as the empty set.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \checknoduplicates(\vli) \typearrow \True \OrTypeError\\\\
  \vl \in \vli: \checkvarnotingenv{G^\tenv, \vl} \typearrow \True \OrTypeError
}{
  \annotatetype{\True, \tenv, \TEnum(\vli)} \typearrow (\overname{\TEnum(\vli)}{\newty}, \overname{\emptyset}{\vses})
}
\CodeSubsection{\TEnumDeclBegin}{\TEnumDeclEnd}{../Typing.ml}

\end{mathpar}
\lrmcomment{This is related to \identd{YZBQ}, \identr{DWSP}, \identi{MZXL}.}
\subsubsection{Example}
\listingref{typing-tenum} shows an example of a well-typed enumeration type declaration.
\ASLListing{Well-typed enumeration type}{typing-tenum}{\typingtests/TypingRule.TEnumDecl.asl}

\hypertarget{recordtypeterm}{}
\section{Record Types\label{sec:RecordTypes}}
\subsection{Syntax}
\begin{flalign*}
\Ntydecl \derives\ & \Trecord \parsesep \Nfieldsopt &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TRecord(\Field^{*}) &
\end{flalign*}

\ASTRuleDef{TyDecl.TRecord}
\begin{mathpar}
\inferrule{}{
  \buildtydecl(\Ntydecl(\Trecord, \punnode{\Nfieldsopt})) \astarrow
  \overname{\TRecord(\astof{\vfieldsopt})}{\vastnode}
}
\end{mathpar}

\subsection{Typing Record Types\label{sec:TypingRecordTypes}}
\TypingRuleDef{TStructuredDecl}
\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is a \structuredtype\ with AST label $L$;
  \item the list of fields of $\tty$ is $\fields$;
  \item $\decl$ is $\True$, indicating that $\tty$ should be considered in the context of a declaration;
  \item $\fields$ is a list of pairs where the first element is an identifier and the second is a type --- $(\vx_i, \vt_i)$, for $i=1..k$;
  \item checking that the list of field identifiers $\vx_{1..k}$ does not contain duplicates
  yields $\True$\ProseOrTypeError;
  \item annotating each field type $\vt_i$, for $i=1..k$, yields $(\vtp_i, \vxs_i)$
        \ProseOrTypeError;
  \item $\fieldsp$ is the list with $(\vx_i, \vtp_i)$, for $i=1..k$;
  \item $\newty$ is the AST node with AST label $L$ (either record type or exception type,
  corresponding to the type $\tty$) and fields $\fieldsp$;
  \item define $\vses$ as the union of all $\vxs_i$, for $i=1..k$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  L \in \{\TRecord, \TException\}\\
  \fields \eqname [i=1..k: (\vx_i, \vt_i)]\\
  \checknoduplicates(\vx_{1..k}) \typearrow \True \OrTypeError\\\\
  i=1..k: \annotatetype{\False, \tenv, \vt_i} \typearrow (\vtp_i, \vxs_i) \OrTypeError\\\\
  \fieldsp \eqdef [i=1..k: (\vx_i, \vtp_i)]\\
  \vses \eqdef \bigcup_{i=1..k} \vxs_i
}{
  \annotatetype{\True, \tenv, L(\fields)} \typearrow (\overname{L(\fieldsp)}{\newty}, \vses)
}
\end{mathpar}
\CodeSubsection{\TStructuredDeclBegin}{\TStructuredDeclEnd}{../Typing.ml}

\subsubsection{Example}
In \listingref{typing-trecord}, all the uses of record or exception types are well-typed.
\ASLListing{Well-typed structured types}{typing-trecord}{\typingtests/TypingRule.TRecordExceptionDecl.asl}

\hypertarget{exceptiontypeterm}{}
\section{Exception Types\label{sec:ExceptionTypes}}
\subsection{Syntax}
\begin{flalign*}
\Ntydecl \derives\ & \Texception \parsesep \Nfieldsopt &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TException(\Field^{*}) &
\end{flalign*}

\ASTRuleDef{TyDecl.TException}
\begin{mathpar}
\inferrule{}{
  \buildtydecl(\Ntydecl(\Texception, \punnode{\Nfieldsopt})) \astarrow
  \overname{\TException(\astof{\vfieldsopt})}{\vastnode}
}
\end{mathpar}

\hypertarget{namedtypeterm}{}
\section{Named Types\label{sec:NamedTypes}}
\subsection{Syntax}
\begin{flalign*}
\Nty \derives\ & \Tidentifier &
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\ty \derives\ & \TNamed(\overtext{\identifier}{type name}) &
\end{flalign*}

\subsection{Typing Exception Types}
The rule for typing exception type is \TypingRuleRef{TStructuredDecl}.

\ASTRuleDef{Ty.TNamed}
\begin{mathpar}
\inferrule{}{
  \buildty(\Nty(\Tidentifier(\id))) \astarrow
  \overname{\TNamed(\id)}{\vastnode}
}
\end{mathpar}

\subsection{Typing Named Types\label{sec:TypingNamedTypes}}
\TypingRuleDef{TNamed}
\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is the named type $\vx$, that is $\TNamed(\vx)$;
  \item checking whether $\vx$ is bound to any declared type in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\vx$ is bound to a type with associated \timeframeterm\ $\vtimeframe$;
  \item define $\vses$ as the singleton set for the \ReadGlobalTerm\ for $\vx$, $\vtimeframe$, and $\True$ for immutability;
  \item $\newty$ is $\tty$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \checktrans{G^\tenv.\declaredtypes(\vx) \neq \bot}{\UndefinedIdentifier} \typearrow \True \OrTypeError\\\\
  G^\tenv.\declaredtypes(\vx) = (\Ignore, \vtimeframe)\\
  \vses \eqdef \{\ \ReadGlobal(\vx, \vtimeframe, \True)\ \}
}{
  \annotatetype{\overname{\Ignore}{\vdecl}, \tenv, \overname{\TNamed(\vx)}{\tty}} \typearrow (\overname{\TNamed(\vx)}{\newty}, \vses)
}
\end{mathpar}
\CodeSubsection{\TNamedBegin}{\TNamedEnd}{../Typing.ml}

\subsubsection{Example}
In \listingref{typing-tnamed}, all the uses of \texttt{MyType} are well-typed.
\ASLListing{Well-typed named types}{typing-tnamed}{\typingtests/TypingRule.TNamed.asl}

\section{Declared Types}
A declared type can be an enumeration type, a record type, an exception type, or an \anonymoustype.
\subsection{Syntax}
\begin{flalign*}
\Ntydecl \derives\ & \Nty &
\end{flalign*}

\subsection{Abstract Syntax}
\ASTRuleDef{TyDecl}
\begin{mathpar}
\inferrule[ty]{}{
  \buildtydecl(\Ntydecl(\punnode{\Nty})) \astarrow
  \overname{\astof{\tty}}{\vastnode}
}
\end{mathpar}

\subsection{Typing Declared Types}
\TypingRuleDef{TNonDecl}
\subsubsection{Example}
In \listingref{typing-trecorderror}, the use of a record type outside of a declaration is erroneous.
\ASLListing{An erroneous use of a record type}{typing-trecorderror}{\typingtests/TypingRule.TNonDecl.asl}

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tty$ is a \structuredtype\ or an enumeration type;
  \item $\decl$ is $\False$, indicating that $\tty$ should be considered to be outside the context of a declaration
  of $\tty$;
  \item a type error is returned, indicating that the use of anonymous form of enumerations, record,
  and exceptions types is not allowed here.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \astlabel(\tty) \in \{\TEnum, \TRecord, \TException\}
}{
  \annotatetype{\False, \tenv, \tty} \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}
\CodeSubsection{\TNonDeclBegin}{\TNonDeclEnd}{../Typing.ml}

\input{TypeDomains.tex}
\input{TypeAttributes.tex}
\input{RelationsOnTypes.tex}
\input{BaseValues.tex}
