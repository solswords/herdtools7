\chapter{Subprogram Declarations\label{chap:SubprogramDeclarations}}

Subprogram declarations are grammatically derived from $\Ndecl$ via the subset of productions shown in
\secref{SubprogramDeclarationsSyntax} and represented as ASTs via the production of $\decl$
shown in \secref{SubprogramDeclarationsAbstractSyntax}.
%
Subprogram declarations are typed via $\annotateanddeclarefunc$, which is defined in \TypingRuleRef{AnnotateAndDeclareFunc}.
%
Subprogram declarations have no associated semantics.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syntax\label{sec:SubprogramDeclarationsSyntax}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\Ndecl  \derives \ & \Tfunc \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs \parsesep \Nreturntype \parsesep \Nrecurselimit \\
& \wrappedline\ \parsesep \Nfuncbody &\\
|\ & \Tfunc \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs \parsesep \Nfuncbody &\\
|\ & \Tgetter \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs \parsesep \Nreturntype \parsesep \Nfuncbody&\\
|\ & \Tsetter \parsesep \Tidentifier \parsesep \Nparamsopt \parsesep \Nfuncargs \parsesep \Teq \parsesep \Ntypedidentifier & \\
    & \wrappedline\ \parsesep \Nfuncbody &\\
\end{flalign*}

\begin{flalign*}
\Nrecurselimit   \derives \ & \Trecurselimit \parsesep \Nexpr &\\
|\              & \emptysentence &\\
\Nparamsopt \derives \ & \emptysentence &\\
                   |\ & \Tlbrace \parsesep \ClistZero{\Nopttypedidentifier} \parsesep \Trbrace &\\
\Nopttypedidentifier \derives \ & \Tidentifier \parsesep \option{\Nasty} &\\
\Nfuncargs          \derives \ & \Tlpar \parsesep \ClistZero{\Ntypedidentifier} \parsesep \Trpar &\\
\Nreturntype        \derives \ & \Tarrow \parsesep \Nty &\\
\Nfuncbody          \derives \ & \Tbegin \parsesep \Nmaybeemptystmtlist \parsesep \Tend \parsesep \Tsemicolon &\\
\Nmaybeemptystmtlist \derives \ & \emptysentence \;|\; \Nstmtlist &
\end{flalign*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Syntax\label{sec:SubprogramDeclarationsAbstractSyntax}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flalign*}
\decl \derives\ & \DFunc(\func) &
\end{flalign*}

\begin{flalign*}
\func \derives\ &
{
\left\{
  \begin{array}{rcl}
 \funcname &:& \Strings, \\
 \funcparameters &:& (\identifier, \ty?)^*,\\
 \funcargs &:& \typedidentifier^*,\\
 \funcbody &:& \subprogrambody,\\
 \funcreturntype &:& \ty?,\\
 \funcsubprogramtype &:& \subprogramtype,\\
 \funcrecurselimit    &:& \expr?\\
 \funcbuiltin &:& \Bool
\end{array}
\right\}
} &\\
\typedidentifier \derives\ & (\identifier, \ty) &\\
\subprogrambody \derives\ & \SBASL(\stmt) \;|\; \SBPrimitive &\\
\subprogramtype \derives\ & \STProcedure \;|\; \STFunction &\\
                |\  & \STGetter \;|\; \STSetter &
\end{flalign*}

\ASTRuleDef{GlobalDecl}
The relation
\[
  \builddecl : \overname{\parsenode{\Ndecl}}{\vparsednode} \;\aslrel\; \overname{\decl}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[func\_decl]{}{
  \builddecl\left(
    \overname{\Ndecl\left(
      \begin{array}{l}
    \Tfunc, \Tidentifier(\name), \punnode{\Nparamsopt}, \punnode{\Nfuncargs}, \punnode{\Nreturntype}, \\
    \wrappedline\ \punnode{\Nrecurselimit}, \punnode{\Nfuncbody}
      \end{array}
  \right)}{\vparsednode}\right)
\astarrow \\
{
    \overname{
  \DFunc\left(\left\{
    \begin{array}{rcl}
            \funcname &:& \name,\\
            \funcparameters &:& \astof{\vparamsopt},\\
            \funcargs &:& \astof{\vfuncargs},\\
            \funcbody &:& \SBASL(\astof{\vfuncbody}),\\
            \funcreturntype &:& \langle \astof{\vreturntype} \rangle,\\
            \funcsubprogramtype &:& \STFunction,\\
            \funcrecurselimit   &:& \langle\astof{\vrecurselimit}\rangle\\
            \funcbuiltin &:& \False
    \end{array}
  \right\}\right)}{\vastnode}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[procedure\_decl]{}{
  \builddecl(
    \overname{\Ndecl(\Tfunc, \Tidentifier(\name), \punnode{\Nparamsopt}, \punnode{\Nfuncargs}, \punnode{\Nfuncbody})}{\vparsednode}
    )
  \astarrow \\
  {
    \overname{
  \DFunc\left(\left\{
    \begin{array}{rcl}
            \funcname &:& \name,\\
            \funcparameters &:& \astof{\vparamsopt},\\
            \funcargs &:& \astof{\vfuncargs},\\
            \funcbody &:& \SBASL(\astof{\vfuncbody}),\\
            \funcreturntype &:& \None,\\
            \funcsubprogramtype &:& \STProcedure,\\
            \funcrecurselimit   &:& \None\\
            \funcbuiltin &:& \False
    \end{array}
  \right\}\right)
    }{\vastnode}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[getter]{}{
  {
    \begin{array}{r}
  \builddecl\left(\overname{\Ndecl\left(
    \begin{array}{l}
      \Tgetter, \Tidentifier(\name), \punnode{\Nparamsopt}, \punnode{\Nfuncargs}, \\
      \wrappedline\ \punnode{\Nreturntype}, \punnode{\Nfuncbody}
    \end{array}
      \right)}{\vparsednode}\right)
  \astarrow \\
  \overname{
  \DFunc\left(\left\{
    \begin{array}{rcl}
            \funcname &:& \name,\\
            \funcparameters &:& \astof{\vparamsopt},\\
            \funcargs &:& \astof{\vfuncargs},\\
            \funcbody &:& \SBASL(\astof{\vfuncbody}),\\
            \funcreturntype &:& \langle \astof{\vreturntype}\rangle,\\
            \funcsubprogramtype &:& \STGetter,\\
            \funcrecurselimit   &:& \None\\
            \funcbuiltin &:& \False
    \end{array}
  \right\}\right)
  }{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[setter]{}{
  {
      \builddecl\left(\overname{\Ndecl\left(
        \begin{array}{r}
          \Tsetter, \Tidentifier(\name), \punnode{\Nparamsopt}, \punnode{\Nfuncargs}, \Teq, \\
   \wrappedline\ \namednode{\vv}{\Ntypedidentifier}, \punnode{\Nfuncbody}
        \end{array}
   \right)}{\vparsednode}\right)
  } \astarrow
  \\
  {
    \overname{
  \DFunc\left(\left\{
    \begin{array}{rcl}
            \funcname &:& \name,\\
            \funcparameters &:& \astof{\vparamsopt},\\
            \funcargs &:& [\vv] \concat \astof{\vfuncargs},\\
            \funcbody &:& \SBASL(\astof{\vfuncbody}),\\
            \funcreturntype &:& \None,\\
            \funcsubprogramtype &:& \STSetter,\\
            \funcrecurselimit   &:& \None\\
            \funcbuiltin &:& \False
    \end{array}
  \right\}\right)
    }{\vastnode}
  }
}
\end{mathpar}

\ASTRuleDef{RecurseLimit}
\hypertarget{build-recurselimit}{}
The function
\[
\buildrecurselimit(\overname{\parsenode{\Nrecurselimit}}{\vparsednode}) \aslto \overname{\langle\expr\rangle}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[limit]{}{
  \buildrecurselimit\left(\overname{\Nrecurselimit(\Trecurselimit, \punnode{\Nexpr})}{\vparsednode}\right)
  \astarrow
  \overname{\langle\astof{\vexpr}\rangle}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[no\_limit]{}{
  \buildrecurselimit\left(\overname{\Nrecurselimit(\emptysentence)}{\vparsednode}\right)
  \astarrow
  \overname{\None}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{TypedIdentifier}
\hypertarget{build-typedidentifier}{}
The function
\[
\buildtypedidentifier(\overname{\parsenode{\Ntypedidentifier}}{\vparsednode}) \aslto \overname{(\identifier \times \ty)}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  \buildtypedidentifier(\overname{\Ntypedidentifier(\Tidentifier(\id), \punnode{\Nasty})}{\vparsednode}) \astarrow \overname{(\id,\astof{\vasty})}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{OptTypedIdentifier}
\hypertarget{build-opttypedidentifier}{}
The function
\[
\buildopttypedidentifier(\overname{\parsenode{\Nopttypedidentifier}}{\vparsednode}) \aslto \overname{(\identifier \times \langle\ty\rangle)}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  \buildoption[\Nasty](\vastyopt) \astarrow \astversion{\vastyopt}
}{
  {
  \begin{array}{r}
  \buildopttypedidentifier(\overname{\Ntypedidentifier(\Tidentifier(\id), \namednode{\vastyopt}{\option{\Nasty}})}{\vparsednode}) \astarrow \\
  \overname{(\id, \astversion{\vastyopt})}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{ReturnType}
\hypertarget{build-returntype}{}
The function
\[
\buildreturntype(\overname{\parsenode{\Nreturntype}}{\vparsednode}) \aslto \overname{\ty}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  \buildreturntype(\overname{\Nreturntype(\Tarrow, \punnode{\Nty})}{\vparsednode}) \astarrow
  \overname{\astof{\tty}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{ParamsOpt}
\hypertarget{build-paramsopt}{}
The function
\[
\buildparamsopt(\overname{\parsenode{\Nparamsopt}}{\vparsednode}) \aslto
  \overname{(\identifier\times\langle\ty\rangle)^*}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[empty]{}{
  \buildparamsopt(\overname{\Nparamsopt(\epsilonnode)}{\vparsednode}) \astarrow
  \overname{\emptylist}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \buildclist[\Nopttypedidentifier](\ids) \astarrow \astversion{\ids}
}{
  \buildparamsopt(\overname{\Nparamsopt(\Tlbrace, \namednode{\ids}{\ClistZero{\Nopttypedidentifier}}, \Trbrace)}{\vparsednode}) \astarrow
  \overname{\astversion{\ids}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{FuncArgs}
\hypertarget{build-funcargs}{}
The function
\[
\buildfuncargs(\overname{\parsenode{\Nfuncargs}}{\vparsednode}) \aslto
  \overname{(\identifier\times\ty)^*}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  \buildclist[\Ntypedidentifier](\ids) \astarrow \astversion{\ids}
}{
  \buildfuncargs(\overname{\Nfuncargs(\Tlpar, \namednode{\ids}{\ClistZero{\Ntypedidentifier}}, \Trpar)}{\vparsednode}) \astarrow
  \overname{\astversion{\ids}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{MaybeEmptyStmtList}
\hypertarget{build-maybeemptystmtlist}{}
The function
\[
\buildmaybeemptystmtlist(\overname{\parsenode{\Nmaybeemptystmtlist}}{\vparsednode}) \aslto
  \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[empty]{}{
  \buildmaybeemptystmtlist(\overname{\Nmaybeemptystmtlist(\epsilonnode)}{\vparsednode}) \astarrow
  \overname{\SPass}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{}{
  \buildmaybeemptystmtlist(\overname{\Nmaybeemptystmtlist(\Nstmtlist)}{\vparsednode}) \astarrow
  \overname{\astof{\vstmtlist}}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{FuncBody}
\hypertarget{build-funcbody}{}
The function
\[
\buildfuncargs(\overname{\parsenode{\Nfuncbody}}{\vparsednode}) \aslto
  \overname{\stmt}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{}{
  {
  \begin{array}{r}
  \buildfuncbody(\overname{\Nfuncbody(\Tbegin, \namednode{\vstmts}{\Nmaybeemptystmtlist}, \Tend, \Tsemicolon)}{\vparsednode}) \astarrow \\
  \overname{\astof{\vmaybeemptystmtlist}}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Typing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We also define the following helper rules:
\begin{itemize}
  \item \TypingRuleRef{AnnotateAndDeclareFunc}
  \item \TypingRuleRef{AnnotateFuncSig}
  \item \TypingRuleRef{AnnotateParams}
  \item \TypingRuleRef{AnnotateOneParam}
  \item \TypingRuleRef{CheckParamDecls}
  \item \TypingRuleRef{TypesInFuncSig}
  \item \TypingRuleRef{ParametersOfTy}
  \item \TypingRuleRef{ParametersOfExpr}
  \item \TypingRuleRef{ParametersOfConstraint}
  \item \TypingRuleRef{AnnotateArgs}
  \item \TypingRuleRef{AnnotateOneArg}
  \item \TypingRuleRef{AnnotateReturnType}
  \item \TypingRuleRef{DeclareOneFunc}
  \item \TypingRuleRef{SubprogramClash}
  \item \TypingRuleRef{AddNewFunc}
  \item \TypingRuleRef{CheckSetterHasGetter}
  \item \TypingRuleRef{AddSubprogram}
\end{itemize}

\TypingRuleDef{AnnotateAndDeclareFunc}
\hypertarget{def-annotateanddeclarefunc}{}
The function
\[
  \annotateanddeclarefunc(\overname{\globalstaticenvs}{\tenv}, \overname{\func}{\funcsig})
  \aslto (\overname{\staticenvs}{\tenv} \times \overname{\func}{\newfuncsig} \times \overname{\TSideEffectSet}{\vses})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a subprogram definition $\funcsig$ in the global static environment $\genv$,
yielding a new subprogram definition $\newfuncsig$, a modified static environment
$\newtenv$, and an inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item annotating the signature of $\funcsig$ in $\genv$ as per
        \TypingRuleRef{AnnotateFuncSig} yields
        $(\tenvone, \funcsigfone, \vsesone)$\ProseOrTypeError;
  \item declaring the subprogram defined by $\funcsigfone$ in $\tenvone$ with $\vsesfone$
        as per \TypingRuleRef{DeclareOneFunc} yields the environment $\newtenv$
        and new $\func$ node $\newfuncsig$\ProseOrTypeError;
  \item \Proseeqdef{$\vses$}{$\vsesfone$}.
\end{itemize}
\CodeSubsection{\AnnotateAndDeclareFuncBegin}{\AnnotateAndDeclareFuncEnd}{../Typing.ml}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatefuncsig(\genv, \funcsig) \typearrow (\tenvone, \funcsigfone, \vsesfone) \OrTypeError\\\\
  \declareonefunc(\tenvone, \funcsigfone, \vsesfone) \typearrow (\newtenv, \newfuncsig) \OrTypeError
}{
  \annotateanddeclarefunc(\genv, \funcsig) \typearrow (\newtenv, \newfuncsig, \overname{\vsesfone}{\vses})
}
\end{mathpar}

\TypingRuleDef{AnnotateFuncSig}
\hypertarget{def-annotatefuncsig}{}
The function
\[
  \annotatefuncsig(\overname{\globalstaticenvs}{\genv}, \overname{\func}{\funcsig})
  \aslto (\overname{\staticenvs}{\newtenv} \times \overname{\func}{\newfuncsig} \times \overname{\TSideEffect}{\vses})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the signature of a function definition $\funcsig$ in the global static environment $\genv$,
yielding a new function definition $\newfuncsig$,
a modified static environment $\newtenv$, and
an inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\tenv$ is the static environment which comprises of the global static environment $\genv$ and an empty local environment;
  \item applying $\annotatelimitexpr$ to $\funcsig.\funcrecurselimit$ in $\tenvone$ yields \\
        $(\vrecurselimit, \vsesrecurselimit)$\ProseOrTypeError;
  \item annotating and declaring the parameters $\funcsig.\funcparameters$ in $\tenv$ using \\
        $\annotateparams$ yields $(\tenvwithparams, \vseswithparams, \params)$\ProseOrTypeError;
  \item checking that the parameters $\funcsig.\funcparameters$ are declared correctly using $\checkparamdecls$, yields $\True$\ProseOrTypeError;
  \item annotating and declaring the arguments $\funcsig.\funcargs$ in $\tenvwithparams$ using $\annotateargs$
        and $\vseswithparams$ yields
        $(\tenvwithargs, \vseswithargs, \vargs)$\ProseOrTypeError;
  \item annotating the return type of $\funcsig$ in $\tenvwithparams$ using \\ $\annotatereturntype$ and $\vseswithargs$, yields
        $(\newtenv, \vreturntype, \vseswithreturn)$\ProseOrTypeError;
  \item \Proseeqdef{$\vses$}{$\vseswithreturn$ with all instances of \ReadLocal\ and \WriteLocalTerm\ removed};
  \item $\newfuncsig$ is $\funcsig$ with the annotated parameters $\vparams$, annotated arguments $\vargs$, annotated return type $\vreturntype$,
        and $\vrecurselimit$ as its recursion limit.
\end{itemize}
\CodeSubsection{\AnnotateFuncSigBegin}{\AnnotateFuncSigEnd}{../Typing.ml}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \withemptylocal(\genv) \typearrow \tenv\\
  \annotatelimitexpr(\tenvone, \funcsig.\funcrecurselimit) \typearrow (\vrecurselimit, \vsesrecurselimit) \OrTypeError\\\\
  {
    \begin{array}{r}
    \annotateparams(\tenv, \funcsig.\funcparameters, (\tenv, \emptylist)) \typearrow \\
    (\tenvwithparams, \vseswithparams, \params) \OrTypeError
    \end{array}
  }\\
  \checkparamdecls(\tenv, \funcsig) \typearrow \True \OrTypeError \\
  {
    \begin{array}{r}
    \annotateargs(\tenvwithparams, \funcsig.\funcargs, (\tenvwithparams, \emptylist), \vseswithparams) \typearrow \\
    (\tenvwithargs, \vseswithargs, \vargs) \OrTypeError
      \end{array}
  }\\\\
  {
    \begin{array}{r}
  \annotatereturntype(\tenvwithargs, \tenvwithparams, \funcsig.\funcreturntype, \vseswithargs) \typearrow \\
    (\newtenv, \vreturntype, \vseswithreturn) \OrTypeError
    \end{array}
  }\\\\
  \vses \eqdef \vseswithreturn \setminus \{ \vs \;|\; \configdomain{\vs} \in \{\ReadLocal, \WriteLocal\} \}\\
  {
    \newfuncsig \eqdef
    \left\{
    \begin{array}{rcl}
      \funcname            &:& \funcsig.\funcname,\\
      \funcparameters      &:& \vparameters,\\
      \funcargs            &:& \vargs,\\
      \funcbody            &:& \funcsig.\funcbody,\\
      \funcreturntype      &:& \vreturntype,\\
      \funcsubprogramtype  &:& \funcsig.\funcsubprogramtype,\\
      \funcrecurselimit    &:& \vrecurselimit\\
      \funcbuiltin         &:& \funcsig.\funcbuiltin
    \end{array}
    \right\}
  }
}{
  \annotatefuncsig(\genv, \funcsig) \typearrow (\newtenv, \newfuncsig, \vses)
}
\end{mathpar}

\TypingRuleDef{AnnotateParams}
\hypertarget{def-annotateparams}{}
The function
\[
\begin{array}{r}
\annotateparams(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier \times \langle\ty\rangle)^*}{\params} \aslsep\
  (\overname{\staticenvs}{\newtenv} \times \overname{(\identifier\times\ty)^*}{\acc})
) \aslto \\
(\overname{\staticenvs}{\tenvwithparams} \times \overname{\identifier\times\ty}{\paramsone})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates each parameter in $\params$ with respect to $\tenv$,
and declares it in environment $\newtenv$.
It returns the updated environment $\tenvwithparams$ and the annotated parameters $\paramsone$, together with any annotated parameters already in the accumulator $\acc$.
\ProseOtherwiseTypeError

\subsection{Example}
In \listingref{typing-parameterofconstraint}, the list of explicitly defined parameters
of the function \texttt{signature\_example} is $\{\texttt{A},\texttt{B}\}$.
Therefore, $\tenvwithparams$ effectively reflects the added declarations \verb|let A: integer{A}| and \verb|let B: integer{B}|.

\ASLListing{A function with parameters}{typing-parameterofconstraint}{\typingtests/TypingRule.AnnotateFuncSig.asl}

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\params$ is the empty list;
    \item $\tenvwithparams$ is $\newtenv$;
    \item $\paramsone$ is $\acc$.
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\params$ is a list with $(\vx, \tyopt)$ as its \head\ and $\paramsp$ as its \tail;
    \item applying $\annotateoneparam$ to the parameter $(\vx, \tyopt)$ with $\tenv$ and $\newtenv$ yields the pair $\newtenvp$ and $\tty$\ProseOrTypeError;
    \item define $\accp$ as the concatenation of $\acc$ and the pair $(\vx, \tty)$;
    \item applying $\annotateparams$ to $\paramsp$ with $\tenv$, $\newtenvp$, and $\accp$ yields $\tenvwithparams$ and $\paramsone$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \annotateparams(\tenv, \overname{\emptylist}{\params}, (\newtenv, \acc)) \typearrow
  (\overname{\newtenv}{\tenvwithparams}, \overname{\acc}{\paramsone})
}
\and
\inferrule[non\_empty]{
  \params \eqname [(\vx,\tyopt)] \concat \paramsp\\\\
  \annotateoneparam(\tenv, \newtenv, (\vx, \tyopt)) \typearrow (\newtenvp, \tty) \OrTypeError \\\\
  \accp \eqdef \acc \concat [(\vx, \tty)] \\\\
  \annotateparams(\tenv, \paramsp, (\newtenvp, \accp)) \typearrow (\tenvwithparams, \paramsone) \OrTypeError
}{
  \annotateparams(\tenv, \params, (\newtenv, \acc)) \typearrow (\tenvwithparams, \paramsone)
}
\end{mathpar}

\TypingRuleDef{AnnotateOneParam}
The function
\hypertarget{def-annotateoneparam}{}
\[
\begin{array}{r}
\annotateoneparam(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\staticenvs}{\newtenv} \aslsep
  (\overname{\identifier}{\vx} \times \overname{\langle\ty\rangle}{\tyopt})
) \aslto
(\overname{\staticenvs}{\newtenvp} \times \overname{\ty}{\tty})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates the parameter given by $\vx$ and the \optional\ type $\tyopt$
with respect to $\tenv$ and then declares the parameter $\vx$ in environment $\newtenv$.
The updated environment $\newtenvp$ and annotated parameter type $\tty$ are returned.
\ProseOtherwiseTypeError

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item One of the following applies:
  \begin{itemize}
    \item All of the following apply (\textsc{type\_parameterized}):
    \begin{itemize}
      \item $\tyopt$ is either $\None$ or an \unconstrainedintegertype{};
      \item $\tty$ is defined as the \parameterizedintegertype\ for the identifier $\vx$.
    \end{itemize}

    \item All of the following apply (\textsc{type\_annotated}):
    \begin{itemize}
      \item $\tyopt$ is the type $\langle\ttyp\rangle$, which is not the unconstrained integer type;
      \item annotating $\ttyp$ in $\tenv$ yields $\tty$\ProseOrTypeError.
    \end{itemize}
  \end{itemize}
  \item checking that $\vx$ is not defined in $\newtenv$ yields $\True$\ProseOrTypeError;
  \item checking that $\tty$ is a constrained integer in $\newtenv$ via $\checkconstrainedinteger$
        yields $\True$\ProseOrTypeError;
  \item adding the local storage element given by the identifier $\vx$, type $\tty$, and local declaration keyword
        $\LDKLet$ in $\newtenv$ yields $\newtenvp$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[type\_parameterized]{
  (\tyopt = \None \lor \tyopt = \langle \unconstrainedinteger\rangle) \\
  \tty \eqdef \TInt(\parameterized(\vx))\\
  \checkvarnotinenv{\newtenv, \vx} \typearrow \True \OrTypeError\\\\
  \checkconstrainedinteger(\newtenv, \tty) \typearrow \True \OrTypeError\\\\
  \addlocal(\newtenv, \vx, \tty, \LDKLet) \typearrow \newtenvp
}{
  \annotateoneparam(\tenv, \newtenv, (\vx, \tyopt)) \typearrow (\newtenvp, \tty)
}
\and
\inferrule[type\_annotated]{
  \ttyp \neq \unconstrainedinteger\\
  \annotatetype{\False, \tenv, \ttyp} \typearrow \tty \OrTypeError\\\\
  \checkvarnotinenv{\newtenv, \vx} \typearrow \True \OrTypeError\\\\
  \checkconstrainedinteger(\newtenv, \tty) \typearrow \True \OrTypeError\\\\
  \addlocal(\newtenv, \vx, \tty, \LDKLet) \typearrow \newtenvp
}{
  \annotateoneparam(\tenv, \newtenv, (\vx, \langle\ttyp\rangle)) \typearrow (\newtenvp, \tty)
}
\end{mathpar}

\TypingRuleDef{CheckParamDecls}
\hypertarget{def-checkparamdecls}{}
The function
\[
\checkparamdecls(\overname{\staticenvs}{\tenv}, \overname{\func}{\funcsig}) \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks the parameters declared in $\funcsig$ for validity.

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item Finding the list of types in $\funcsig$ using $\typesinfuncsig$ yields $\tys$;
  \item Applying $\paramsofty$ to each type in $\tys$ and concatenating the results yields the list of parameter identifiers $\params$;
  \item Finding unique elements in $\params$ yields $\paramsone$;
  \item Checking that the expected parameters $\paramsone$ and the declared parameters $\funcsig.\funcparameters$ are equal yields $\vb$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \typesinfuncsig(\funcsig) \typearrow \tys \\
  \vi \in \listrange(\tys): \paramsofty(\tenv, \tty_i) \typearrow \params_i \\
  \params \eqdef \params_1 \concat \ldots \concat \params_{\listlen{\tys}} \\
  \paramsone \eqdef \uniquelist(\params) \\\\
  \checktrans{\paramsone = \funcsig.\funcparameters}{\BadSubprogramDeclaration} \checktransarrow \vb \OrTypeError
}{
  \checkparamdecls(\tenv, \funcsig) \typearrow \vb
}
\end{mathpar}

\TypingRuleDef{TypesInFuncSig}
\hypertarget{def-typesinfuncsig}{}
The function
\[
\typesinfuncsig(\overname{\func}{\funcsig}) \aslto \overname{\ty^*}{\tys}
\]
returns the list of types $\tys$ in the function signature $\funcsig$.
Their ordering is return type first (if any), followed by argument types left-to-right.

\ProseParagraph
Define $\tys$ as the return type (if any) concatenated with the argument types.

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
    \left(
    \begin{array}{l}
    \funcsig.\funcreturntype \eqname \None \;\land\; \vreturntype \eqdef \emptylist \;\lor\\
    \funcsig.\funcreturntype \eqname \langle\ttyp\rangle \;\land\; \vreturntype \eqdef [\ttyp]
    \end{array}
    \right)
  } \\\\
  \argtypes \eqdef [(\Ignore, \ttyp)\in\funcsig.\funcargs: \ttyp]
}{
  \typesinfuncsig(\funcsig) \typearrow \overname{\vreturntype \concat \argtypes}{\tys}
}
\end{mathpar}


\TypingRuleDef{ParametersOfTy}
\hypertarget{def-paramsofty}{}
The function
\[
\paramsofty(\overname{\staticenvs}{\tenv}, \overname{\ty}{\tty}) \typearrow \overname{\identifier^*}{\ids}
\]
finds the list of parameters in the type $\tty$.
It assumes that $\tty$ appears in a function signature.

\ProseParagraph
One of the following applies:

\begin{itemize}
  \item All of the following apply (\textsc{tbits}):
    \begin{itemize}
      \item $\tty$ is a bitvector type, that is, $\TBits(\ve, \Ignore)$;
      \item applying $\paramsofexpr$ to $\ve$ in $\tenv$ yields $\ids$.
    \end{itemize}

  \item All of the following apply (\textsc{ttuple}):
    \begin{itemize}
      \item $\tty$ is a tuple over a list of types $\tys$, that is, $\TTuple(\tys)$;
      \item applying $\paramsofty$ to each type $\tty_i$ in $\tys$ yields $\ids_i$;
      \item $\ids$ is the concatenation of all the $\ids_i$.
    \end{itemize}

  \item All of the following apply (\textsc{tint\_constrained}):
    \begin{itemize}
      \item $\tty$ is a \wellconstrainedintegertype, that is, $\TInt(\wellconstrained(\cs))$;
      \item applying $\paramsofconstraint$ to each constraint $\vc_i$ in $\cs$ yields $\ids_i$;
      \item $\ids$ is the concatenation of all the $\ids_i$.
    \end{itemize}

  \item All of the following apply (\textsc{other}):
    \begin{itemize}
      \item $\tty$ is not a tuple type, bitvector type, or \wellconstrainedintegertype;
      \item $\ids$ is the empty list.
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[tbits]{
  \paramsofexpr(\tenv, \ve) \typearrow \ids
}{
  \paramsofty(\tenv, \TBits(\ve, \Ignore)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[ttuple]{
  \tty_i \in \tys: \paramsofty(\tenv, \tty_i) \typearrow \ids_i \\
  \ids \eqdef \ids_1 \concat \ldots \concat \ids_{\listlen{\tys}}
}{
  \paramsofty(\tenv, \TTuple(\tys)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[tint\_constrained]{
  \vc_i \in \cs: \paramsofconstraint(\tenv, \vc_i) \typearrow \ids_i \\
  \ids \eqdef \ids_1 \concat \ldots \concat \ids_{\listlen{\tys}}
}{
  \paramsofty(\tenv, \TInt(\wellconstrained(\cs)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\tty) \notin \{ \TBits, \TTuple \} \\
  \tty \neq \TInt(\wellconstrained(\Ignore))
}{
  \paramsofty(\tenv, \tty) \typearrow \overname{\emptylist}{\ids}
}
\end{mathpar}


\TypingRuleDef{ParametersOfExpr}
\hypertarget{def-paramsofexpr}{}
The function
\[
\paramsofexpr(\overname{\staticenvs}{\tenv}, \overname{\expr}{\ve}) \typearrow \overname{\identifier^*}{\ids}
\]
finds the list of parameters in the expression $\ve$.
It assumes that $\ve$ appears as $\TBits(\ve, \Ignore)$ or as part of a \wellconstrainedintegertype{} in a function signature.

\ProseParagraph
One of the following applies:

\begin{itemize}
  \item All of the following apply (\textsc{eval}):
    \begin{itemize}
      \item $\ve$ is a variable, that is, $\EVar(\vx)$;
      \item if $\vx$ is undefined in $\tenv$ then $\ids$ is $[\vx]$, otherwise $\ids$ is $\emptylist$.
    \end{itemize}

  \item All of the following apply (\textsc{eunop}):
    \begin{itemize}
      \item $\ve$ is a unary operation, that is, $\EUnop(\Ignore, \ve)$;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\ids$.
    \end{itemize}

  \item All of the following apply (\textsc{ebinop}):
    \begin{itemize}
      \item $\ve$ is a binary operation, that is, $\EBinop(\Ignore, \veone, \vetwo)$;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\idsone$;
      \item applying $\paramsofexpr$ to $\vetwo$ in $\tenv$ yields $\idstwo$;
      \item define $\ids$ as the concatenation of $\idsone$ and $\idstwo$.
    \end{itemize}

  \item All of the following apply (\textsc{other}):
    \begin{itemize}
      \item $\ve$ is not a variable, unary operation, or binary operation;
      \item $\ids$ is the empty list.
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[eval]{
  \isundefined(\tenv, \vx) \typearrow \vb\\
  \ids \eqdef \choice{\vb}{[\vx]}{\emptylist}
}{
  \paramsofexpr(\tenv, \EVar(\vx)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[eunop]{
  \paramsofexpr(\tenv, \veone) \typearrow \ids
}{
  \paramsofexpr(\tenv, \EUnop(\Ignore, \veone)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[ebinop]{
  \paramsofexpr(\tenv, \veone) \typearrow \idsone \\
  \paramsofexpr(\tenv, \vetwo) \typearrow \idstwo
}{
  \paramsofexpr(\tenv, \EBinop(\Ignore, \veone, \vetwo)) \typearrow \overname{\idsone \concat \idstwo}{\ids}
}
\end{mathpar}

\begin{mathpar}
\inferrule[other]{
  \astlabel(\ve) \notin \{ \EVar, \EUnop, \EBinop \}
}{
  \paramsofexpr(\tenv, \ve) \typearrow \overname{\emptylist}{\ids}
}
\end{mathpar}

\TypingRuleDef{ParametersOfConstraint}
\hypertarget{def-paramsofconstraint}{}
The function
\[
\paramsofconstraint(\overname{\staticenvs}{\tenv}, \overname{\intconstraint}{\vc}) \typearrow \overname{\identifier^*}{\ids}
\]
finds the list of parameters in the constraint $\vc$.
It assumes that $\vc$ appears within a \wellconstrainedintegertype{} in a function signature.

\ProseParagraph
One of the following applies:

\begin{itemize}
  \item All of the following apply (\textsc{exact}):
    \begin{itemize}
      \item $\vc$ is an exact constraint, that is, $\ConstraintExact(\ve)$;
      \item applying $\paramsofexpr$ to $\ve$ in $\tenv$ yields $ids$.
    \end{itemize}

  \item All of the following apply (\textsc{range}):
    \begin{itemize}
      \item $\vc$ is an range constraint, that is, $\ConstraintRange(\veone, \vetwo)$;
      \item applying $\paramsofexpr$ to $\veone$ in $\tenv$ yields $\idsone$;
      \item applying $\paramsofexpr$ to $\vetwo$ in $\tenv$ yields $\idstwo$;
      \item $\ids$ is the concatenation of $\idsone$ and $\idstwo$.
    \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[exact]{
  \paramsofexpr(\tenv, \ve) \typearrow \ids
}{
  \paramsofconstraint(\tenv, \ConstraintExact(\ve)) \typearrow \ids
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \paramsofexpr(\tenv, \veone) \typearrow \idsone \\
  \paramsofexpr(\tenv, \vetwo) \typearrow \idstwo \\
}{
  \paramsofconstraint(\tenv, \ConstraintRange(\veone, \vetwo)) \typearrow \overname{\idsone \concat \idstwo}{\ids}
}
\end{mathpar}

\subsection{Example}
In \listingref{typing-parameterofconstraint}, the set of identifiers that may correspond
to parameters of the function \texttt{signature\_example} is $\{\texttt{A}, \texttt{B}\}$,
since they appear in the type \texttt{bits(A)}
of the argument \texttt{bv} and the type \texttt{bits(A+B)} of the argument \texttt{bv3}.

Finding parameters for each type in the signature of the function \texttt{signature\_example}
yields the following results:
\begin{center}
\begin{tabular}{lll}
\textbf{Expression} & \textbf{Result} & \textbf{Reason}\\
\hline
\texttt{bits(A)} & $\{\texttt{A}\}$ & \texttt{A} is a variable expression \\
& & and \texttt{A} is not defined in the environment.\\
\texttt{bits(W)} & $\emptyset$ & \texttt{W} is defined in the environment.\\
\texttt{bits(A+B)} & $\{\texttt{A}, \texttt{B}\}$ & \texttt{A} and \texttt{B} are variables \\
& & and neither is defined in the environment.\\
\end{tabular}
\end{center}

\TypingRuleDef{AnnotateArgs}
\hypertarget{def-annotateargs}{}
The function
\[
\begin{array}{r}
\annotateargs(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{(\identifier \times \ty)^*}{\args} \aslsep\
  (\overname{\staticenvs}{\newtenv} \times \overname{(\identifier\times\ty)^*}{\acc} \aslsep
  \overname{\TSideEffectSet}{\vsesin})
) \aslto \\
(\overname{\staticenvs}{\tenvwithargs} \times \overname{(\identifier\times\ty)^*}{\vnewargs} \times \overname{\TSideEffectSet}{\vses})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\end{array}
\]
annotates each argument in $\args$ with respect to $\tenv$ and a \sideeffectsetterm\ $\vsesin$,
and declares it in environment $\newtenv$.
It returns the updated environment $\tenvwithargs$, the annotated arguments $\vnewargs$,
together with any annotated arguments already in the accumulator $\acc$,
and a \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\subsection{Example}
In \listingref{typing-parameterofconstraint}, the annotated arguments are
\texttt{bv}, \texttt{bv2}, \texttt{bv3}, and \texttt{C}.

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{empty}):
  \begin{itemize}
    \item $\args$ is the empty list;
    \item $\tenvwithargs$ is $\newtenv$;
    \item $\newargs$ is $\acc$;
    \item \Proseeqdef{$\vses$}{$\vsesin$}
  \end{itemize}

  \item All of the following apply (\textsc{non\_empty}):
  \begin{itemize}
    \item $\args$ is a list with $(\vx, \tty)$ as its \head\ and $\vargsp$ as its \tail;
    \item applying $\annotateonearg$ to the argument $(\vx, \tty)$ with $\tenv$ and $\newtenv$ yields
          $(\newtenvp, \ttyp, \vsesty)$\ProseOrTypeError;
    \item define $\accp$ as the concatenation of $\acc$ and the pair $(\vx, \ttyp)$;
    \item applying $\annotateargs$ to $\vargsp$ with $\tenv$, $\newtenvp$, and $\accp$ yields $(\tenvwithargs, \newargs, \newses)$;
    \item \Proseeqdef{$\vses$}{the union of $\vsesty$ and $\newses$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \annotateargs(\tenv, \overname{\emptylist}{\args}, (\newtenv, \acc), \vsesin) \typearrow
  (\overname{\newtenv}{\tenvwithargs}, \overname{\acc}{\newargs}, \overname{\vsesin}{\vses})
}
\and
\inferrule[non\_empty]{
  \vargs \eqname [(\vx,\tty)] \concat \vargsp\\\\
  \annotateonearg(\tenv, \newtenv, (\vx, \tty)) \typearrow (\newtenvp, \ttyp, \vsesty) \OrTypeError \\\\
  \accp \eqdef \acc \concat [(\vx, \ttyp)] \\\\
  \annotateargs(\tenv, \vargsp, (\newtenvp, \accp), \vsesin) \typearrow (\tenvwithargs, \newargs, \newses) \OrTypeError\\\\
  \vses \eqdef \vsesty \cup \newses
}{
  \annotateargs(\tenv, \args, (\newtenv, \acc), \vsesin) \typearrow (\tenvwithargs, \newargs, \vses)
}
\end{mathpar}

\TypingRuleDef{AnnotateOneArg}
\hypertarget{def-annotateonearg}{}
The function
\[
\annotateonearg(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\staticenvs}{\newtenv} \aslsep
  (\overname{\identifier}{\vx} \times \overname{\ty}{\tty})
) \aslto
(\overname{\staticenvs}{\newtenvp} \times\ \overname{\ty}{\ttyp} \times \overname{\TSideEffectSet}{\vses})
\cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates the argument given by the identifier $\vx$ and the type $\tty$
with respect to $\tenv$ and then declares the parameter $\vx$ in environment $\newtenv$.
The result is the updated environment $\newtenvp$, annotated argument type $\ttyp$,
and inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item annotating the type $\tty$ in $\tenv$ yields $(\ttyp, \vses)$\ProseOrTypeError;
  \item checking that $\vx$ is not defined in $\newtenv$ yields $\True$\ProseOrTypeError;
  \item adding the local storage element given by the identifier $\vx$, type $\ttyp$, and local declaration keyword
        $\LDKLet$ in $\newtenv$ yields $\newtenvp$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotatetype{\tenv, \tty} \typearrow (\ttyp, \vses) \OrTypeError \\
  \checkvarnotinenv{\newtenv, \vx} \typearrow \True \OrTypeError\\
  \addlocal(\newtenv, \vx, \ttyp, \LDKLet) \typearrow \newtenvp
}{
  \annotateonearg(\tenv, \newtenv, (\vx, \tty))
  \typearrow (\newtenvp, \ttyp, \vses)
}
\end{mathpar}

\TypingRuleDef{AnnotateReturnType}
\hypertarget{def-annotatereturntype}{}
The function
\[
\begin{array}{rl}
\annotatereturntype(
  \overname{\staticenvs}{\tenvwithparams} \aslsep
  \overname{\staticenvs}{\tenvwithargs} \aslsep
  \overname{\langle\ty\rangle}{\vreturntype \aslsep
  \overname{\TSideEffectSet}{\vsesin}}
) & \aslto \\
(\overname{\staticenvs}{\newtenv} \times \overname{\ty}{\newreturntype} \times \overname{\TSideEffectSet}{\vses})
\cup \overname{\TTypeError}{\TypeErrorConfig} &
\end{array}
\]
annotates the \optional\ return type $\vreturntype$ in the context of the static environment
$\tenvwithparams$, where all parameters have been declared,
and the \sideeffectsetterm\ $\vsesin$.
The result is $\newtenv$, which is the input $\tenvwithargs$ (where all parameters and arguments have been declared)
with the \optional{} annotated return type $\newreturntype$ added
and the inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{no\_return\_type}):
  \begin{itemize}
    \item $\vreturntype$ is $\None$;
    \item $\newtenv$ is $\tenvwithargs$;
    \item $\newreturntype$ is $\None$;
    \item \Proseeqdef{$\vses$}{$\vsesin$}.
  \end{itemize}

  \item All of the following apply (\textsc{has\_return\_type}):
  \begin{itemize}
    \item $\returntype$ is $\langle\tty\rangle$;
    \item annotating $\tty$ in $\tenvwithparams$ yields $(\ttyp, \vsesty)$\ProseOrTypeError;
    \item $\newreturntype$ is $\langle\ttyp\rangle$;
    \item $\newtenv$ is $\tenvwithargs$ with its local environment updated by binding its \\ $\funcreturntype$ field
          to $\newreturntype$;
    \item \Proseeqdef{$\vses$}{the union of $\vsesin$ and $\vsesty$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[no\_return\_type]{}
{
  {
  \begin{array}{r}
  \annotatereturntype(\tenvwithparams, \tenvwithargs, \overname{\None}{\vreturntype}, \vsesin) \typearrow \\
  (\overname{\tenvwithargs}{\newtenv}, \overname{\None}{\newreturntype}, \overname{\vsesin}{\vses})
  \end{array}
  }
}
\and
\inferrule[has\_return\_type]{
  \annotatetype{\tenvwithparams, \tty} \typearrow (\ttyp, \vsesty) \OrTypeError\\\\
  \newreturntype \eqdef \langle\ttyp\rangle\\
  \newtenv \eqdef (G^\tenvwithargs, L^\tenvwithargs[\funcreturntype\mapsto\newreturntype])\\
  \vses \eqdef \vsesin \cup \vsesty
}{
  {
  \begin{array}{r}
  \annotatereturntype(\tenvwithparams, \tenvwithargs, \overname{\langle\tty\rangle}{\returntype}, \vsesin) \typearrow \\
  (\newtenv, \newreturntype, \vses)
  \end{array}
  }
}
\end{mathpar}

\TypingRuleDef{DeclareOneFunc}
\hypertarget{def-declareonefunc}{}
The function
\[
  \declareonefunc(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\func}{\funcsig} \aslsep
    \overname{\TSideEffectSet}{\vsesfuncsig})
  \aslto (\overname{\staticenvs}{\newtenv} \times \overname{\func}{\newfuncsig})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks that a subprogram defined by $\funcsig$
and associated with the \sideeffectsetterm\ $\vsesfuncsig$
can be added to the static environment $\tenv$,
resulting in an annotated function definition $\newfuncdef$ and new static environment $\newtenv$.
\ProseOtherwiseTypeError

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item $\funcsig$ has name $\name$, arguments $\vargs$, and type $\subprogramtype$, that is,
  \[
    \begin{array}{rrcl}
      \funcsig \eqdef \{
                      & \funcname            &:& \name,\\
                      & \funcparameters      &:& \vp,\\
                      & \funcargs            &:& \vargs,\\
                      & \funcbody            &:& \SBASL(\bd),\\
                      & \funcreturntype      &:& \vt,\\
                      & \funcsubprogramtype  &:& \subprogramtype, \\
                      & \funcbuiltin         &:& \vb \\
                  \}  & ; &&
        \end{array}
  \]
  \item adding a new subprogram with $\name$, $\vargs$, and $\subprogramtype$ to $\tenv$ yields the new
        environment $\tenvone$ and new name $\namep$\ProseOrTypeError;
  \item checking that $\namep$ is not already declared in the global environment of $\tenvone$
        yields $\True$\ProseOrTypeError;
  \item ensuring that each setter has a getter given $\funcsig$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item $\funcsigone$ is $\funcsig$ with $\name$ substituted by $\nameone$;
  \item \Proseeqdef{$\initses$}{the union of $\vsesfuncsig$ and the singleton set for
        a \RecursiveCallTerm\ for $\namep$};
  \item adding a subprogram with name $\namep$, definition $\funcsigone$,
        and \sideeffectsetterm\ $\initses$ to $\tenvone$ yields $\newtenv$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
  \begin{array}{rrcl}
    \funcsig \eqdef \{
                    & \funcname            &:& \name,\\
                    & \funcparameters      &:& \vp,\\
                    & \funcargs            &:& \vargs,\\
                    & \funcbody            &:& \SBASL(\bd),\\
                    & \funcreturntype      &:& \vt,\\
                    & \funcsubprogramtype  &:& \subprogramtype, \\
                    & \funcbuiltin         &:& \vb \\
                \} &&&
      \end{array}
    }\\
  \addnewfunc(\tenv, \name, \vargs, \subprogramtype) \typearrow
  (\tenvone, \namep) \OrTypeError\\\\
  \checkvarnotingenv{G^\tenvone, \namep} \typearrow \True \OrTypeError\\\\
  \checksetterhasgetter(\tenvone, \funcsig) \typearrow \True \OrTypeError\\\\
  {
  \begin{array}{rrcl}
    \newfuncsig \eqdef \{
                    & \funcname            &:& \namep,\\
                    & \funcparameters      &:& \vp,\\
                    & \funcargs            &:& \vargs,\\
                    & \funcbody            &:& \SBASL(\bd),\\
                    & \funcreturntype      &:& \vt,\\
                    & \funcsubprogramtype  &:& \subprogramtype, \\
                    & \funcbuiltin         &:& \vb \\
                \} &&&
      \end{array}
    }\\
    \initses \eqdef \vsesfuncsig \cup \{ \RecursiveCall(\namep) \}\\
    \addsubprogram(\tenvone, \namep, \funcsigone, \initses) \typearrow \newtenv \OrTypeError
}{
  \declareonefunc(\tenv, \funcsig) \typearrow (\newtenv, \newfuncsig)
}
\end{mathpar}
\CodeSubsection{\DeclareOneFuncBegin}{\DeclareOneFuncEnd}{../Typing.ml}
\lrmcomment{This relates to \identi{HJRD}, \identd{BTBR}, \identi{FSFQ}, \identi{PFGQ}, and \identr{PGFC}.}

\TypingRuleDef{SubprogramClash}
\hypertarget{def-subprogramclash}{}
The function
\[
  \subprogramclash(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\Strings}{\name} \aslsep
    \overname{\subprogramtype}{\subpgmtype} \aslsep
    \overname{\ty^*}{\formaltypes}
  )
  \aslto
  \overname{\Bool}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the unique subprogram associated with $\name$
clashes with another subprogram
that has subprogram type $\subpgmtype$ and list of formal types $\formaltypes$,
yielding a Boolean value in $\vb$.
\ProseOtherwiseTypeError

The function is only defined when there exists a binding for $\name$ in the
$\subprograms$ map of $\tenv$.

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item the identifier $\name$ is bound to the $\func$ AST node $\otherfuncsig$ in the \\
        $\subprograms$ map
        of the static global environment of $\tenv$ (ignoring the associated \sideeffectdescriptorsterm);
  \item applying $\subprogramtypesclash$ to the subprogram type of $\otherfuncsig$ \\
        ($\otherfuncsig.\subprogramtype$) and $\subpgmtype$ yields \\
        $\True$\ProseTerminateAs{\False}
        (that is, if both subprogram types are $\STGetter$ or both are $\STSetter$ then the
        subprogram types are considered to be non-clashing and the entire rule short-circuits to $\False$);
  \item determining whether there is an argument clash between $\formaltypes$ and \\
        the formal arguments of $\otherfuncsig$ ($\otherfuncsig.\funcargs$) in $\tenv$ yields $\vb$\ProseOrTypeError.
\end{itemize}
\FormallyParagraph
\hypertarget{def-subprogramtypeclash}{}
We first introduce the helper predicate
\[
  \subprogramtypesclash(
    \overname{\subprogramtype}{\subpgmtypeone} \aslsep
    \overname{\subprogramtype}{\subpgmtypetwo}
  ) \aslto \overname{\Bool}{\vb}
\]
which defines whether two subprogram types are considered to be clashing:
\begin{mathpar}
\inferrule{
  \vbone \eqdef
  {
    \begin{array}{l}
  (\subpgmtypeone=\STGetter \land \subpgmtypetwo=\STSetter)\ \lor\\
  (\subpgmtypeone=\STSetter \land \subpgmtypetwo=\STGetter)
    \end{array}
  }\\\\
  \vb \eqdef \neg\vbone
}{
  \subprogramtypesclash(\subpgmtypeone, \subpgmtypetwo) \typearrow \vb
}
\end{mathpar}

\begin{mathpar}
\inferrule{
  G^\tenv.\subprograms(\name) = (\otherfuncsig, \Ignore)\\
  \subprogramtypesclash(\otherfuncsig.\subprogramtype, \subpgmtype) \typearrow \True \terminateas \False\\
  \hasargclash(\formaltypes, \otherfuncsig.\funcargs) \typearrow \vb
}{
  \subprogramclash(\tenv, \name, \subpgmtype, \formaltypes) \typearrow \vb
}
\end{mathpar}
\lrmcomment{This is related to \identd{BTBR}, \identi{FSFQ}, \identi{PFGQ}.}

\TypingRuleDef{AddNewFunc}
\hypertarget{def-addnewfunc}{}
The function
\[
  \begin{array}{rl}
  \addnewfunc(
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\identifier}{\name} \aslsep
    \overname{\typedidentifier^*}{\formals} \aslsep
    \overname{\subprogramtype}{\subpgmtype})
  & \aslto\\
  (\overname{\staticenvs}{\newtenv} \times \overname{\Strings}{\newname})
  \cup \overname{\TTypeError}{\TypeErrorConfig} &
  \end{array}
\]
ensures that the subprogram given by the identifier $\name$, list of formals $\formals$,
and subprogram type $\subpgmtype$ has a unique name among all the potential subprograms
that overload $\name$.
The result is the unique subprogram identifier $\newname$, which is used to distinguish it in the set
of overloaded subprograms (that is, other subprograms that share the same name)
and the environment $\newtenv$, which is updated with $\newname$.
\ProseOtherwiseTypeError

\ProseParagraph
One of the following applies:
\begin{itemize}
  \item All of the following apply (\textsc{first\_name}):
  \begin{itemize}
    \item the $\overloadedsubprograms$ map in the global environment of $\tenv$ does not have a binding for $\name$;
    \item $\newtenv$ is $\tenv$ with the $\overloadedsubprograms$ updated by binding $\name$ to the singleton set containing
          $\name$.
  \end{itemize}

  \item All of the following apply (\textsc{name\_exists}):
  \begin{itemize}
    \item the $\overloadedsubprograms$ map in the global environment of $\tenv$ binds $\name$ to the set of strings $\othernames$;
    \item $\newname$ is the unique name that will be associated with the subprogram given by the identifier $\name$, list of formals $\formals$,
          and subprogram type $\subpgmtype$. It is constructed by concatenating a hyphen (\texttt{-}) to $\name$, followed
          by a string corresponding to the number of strings in $\othernames$.
          Notice that this is not an ASL identifier, as ASL identifiers do not contain hyphens, which ensures that this string
          does not occur in any specification;
    \item $\formaltypes$ is the list of types that appear in $\formals$ in the same order;
    \item checking for each $\namep$ in $\othernames$ whether the subprogram associated with $\namep$ clashes
          with the subprogram type $\subpgmtype$ and list of types $\formaltypes$ yields $\False$
          or a type error that indicates there are multiply defined subprograms, which short-circuits the entire rule;
    \item $\newtenv$ is $\tenv$ with the $\overloadedsubprograms$ updated by binding $\name$ to the union of $\othernames$ and
          $\{\newname\}$.
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[first\_name]{
  G^\tenv.\overloadedsubprograms(\name) = \bot\\
  \newtenv \eqdef (G^\tenv.\overloadedsubprograms[\name\mapsto\{\name\}],  L^\tenv)
}{
  \addnewfunc(\tenv, \name, \formals, \subpgmtype) \typearrow
  (\newtenv, \overname{\name}{\newname})
}
\end{mathpar}

\begin{mathpar}
\inferrule[name\_exists]{
  G^\tenv.\overloadedsubprograms(\name) = \othernames\\
  k \eqdef \cardinality{\othernames}\\
  \newname \eqdef \name\ \stringconcat\ \texttt{"-"}\ \stringconcat\ \stringofnat(k)\\
  \formaltypes \eqdef [(\id,\vt) \in \formals : \vt]\\
  {
    \left(\begin{array}{l}
  \namep \in \othernames: \\ \subprogramclash(\tenv, \namep, \subpgmtype, \formaltypes) \typearrow
  \vb_{\namep} \OrTypeError
    \end{array}\right)
  }\\\\
  \namep \in \othernames: \checktrans{\neg\vb_{\namep}}{\BadSubprogramDeclaration} \typearrow \True \OrTypeError\\\\
  \newtenv \eqdef (G^\tenv.\overloadedsubprograms[\name\mapsto \othernames \cup \{\newname\}],  L^\tenv)
}{
  \addnewfunc(\tenv, \name, \formals, \subpgmtype) \typearrow
  (\newtenv, \newname)
}
\end{mathpar}
\lrmcomment{This is related to \identr{PGFC}.}
\CodeSubsection{\AddNewFuncBegin}{\AddNewFuncEnd}{../Typing.ml}

\TypingRuleDef{CheckSetterHasGetter}
\hypertarget{def-checksetterhashgetter}{}
The function
\[
  \checksetterhasgetter(\overname{\staticenvs}{\tenv} \aslsep \overname{\func}{\funcsig})
  \aslto \overname{\True}{\vb} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the setter procedure given by $\funcsig$ has a corresponding getter,
returning $\True$ if this condition holds and a type error otherwise.

\ProseParagraph
All of the following apply:
\begin{itemize}
  \item checking that the subprogram type of $\funcsig$ is $\STSetter$ has one of two outcomes:
        $\False$, which satisfies the premise;
        or $\True$, which short-circuits the entire rule
        (since the subprogram is not any kind of setter and no getter is required);
  \item \view\ the list of arguments of $\funcsig$ (that is, $\funcsig.\funcargs$) as follows:
        the \head\ is an argument that has the type $\rettype$;
        the \tail\ is a list with arguments that have the types $\argtypes$;
  \item applying $\subprogramforname$ to look up $\tenv$ for a subprogram with the name given by $\funcsig$ (that is, $\funcsig.\funcname$)
        yields a subprogram definition AST node $\funcsigp$\ProseOrTypeError;
  \item checking that $\funcsigp.\funcsubprogramtype$ is $\STGetter$ yields $\True$\ProseOrTypeError;
  \item define $\argtypesp$ as the list of types appearing in the signature of $\funcsigp$ (that is, in $\funcsigp.\funcargs$);
  \item checking, for each index $\vi$ in the indices for $\argtypes$, that the type at $\argtypes[\vi]$ and the type at $\argtypesp[\vi]$
        are \typeequivalent\ yields $\True$\ProseOrTypeError;
  \item checking that $\rettype$ and $\funcsigp.\funcreturntype$ are \typeequivalent\ yields \\
        $\True$\ProseOrTypeError;
  \item define $\vb$ as $\True$ (that is, unless the rule short-circuited with a type error).
\end{itemize}
\CodeSubsection{\CheckSetterHasGetterBegin}{\CheckSetterHasGetterEnd}{../Typing.ml}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \issetter \eqdef \funcsig.\subprogramtype = \STSetter\\
  \booltrans{\issetter} \booltransarrow \False \terminateas \True\\\\
  \funcsig.\funcargs \eqname (\Ignore, \rettype) \concat \vargs\\
  \argtypes \eqdef [(\Ignore, \vt) \in \vargs: \vt]\\
  \subprogramforname(\tenv, \funcsig.\funcname, \argtypes) \typearrow (\Ignore, \Ignore, \funcsigp) \OrTypeError\\\\
  \checktrans{\funcsigp.\funcsubprogramtype = \STGetter}{\BadSubprogramDeclaration} \typearrow \True \OrTypeError\\\\
  \argtypesp \eqdef [(\Ignore, \vt) \in \funcsigp.\funcargs : \vt]\\
  \vi\in\listrange(\argtypes): \typeequal(\argtypes[\vi], \argtypesp[\vi]) \typearrow \vb_\vi \OrTypeError\\\\
  \vi\in\listrange(\argtypes): \checktrans{\vb_\vi}{\BadSubprogramDeclaration} \typearrow \True \OrTypeError\\\\
  \typeequal(\rettype, \funcsigp.\funcreturntype) \typearrow \vb_\ret \OrTypeError\\\\
  \checktrans{\vb_\ret}{\BadSubprogramDeclaration} \typearrow \True \OrTypeError
}{
  \checksetterhasgetter(\tenv, \funcsig) \typearrow \overname{\True}{\vb}
}
\end{mathpar}
