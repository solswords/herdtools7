\chapter{Bitfields\label{chap:Bitfields}}

Bitvector types allow defining bitslices of bitvectors, to be treated as named
fields, which can be read or written. \identi{KGMC}

Individual bitfields are grammatically derived from $\Nbitfield$ and represented as ASTs by $\bitfield$.
Bitfields are not associated with a semantic relation.

\ExampleDef{A bitvector type with bitfields}
\listingref{bitfields1} declares a global variable whose type is a bitvector with bitfields.
\ASLListing{A bitvector type with bitfields}{bitfields1}{\definitiontests/Bitfields.asl}
\begin{itemize}
  \item The expression \texttt{myData.flag} evaluates to the same value as \verb|myData[4]|, with type \verb|bits(1)|;
  \item The expression \texttt{myData.data} evaluates to the same value as \\
        \verb|myData[3:0] :: myData[8:5]|, with type \verb|bits(8)|;
  \item There is no bitfield which accesses \verb|myData[15:10]|;
  \item The value field overlaps with the other fields;
  \item The slices \verb|3:0| and \verb|8:5| which define \texttt{data} do not overlap.
\end{itemize}
Note that in the \texttt{data} bitfield, bits |3:0| come before bits |8:5|,
which is a different order from their occurrence in \texttt{myData}.

\hypertarget{def-singleslice}{}
\hypertarget{def-rangeslice}{}
\hypertarget{def-lengthslice}{}
\hypertarget{def-scaledslice}{}
We refer to a slice of the form \texttt{[$\ve$]} as a \singleslice,
a slice of the form \texttt{[$\veone$:$\vetwo$]} as a \rangeslice,
a slice of the form \texttt{[$\veone$+:$\vetwo$]} as a \lengthslice,
and slice of the form \texttt{[$\veone$*:$\vetwo$]} as a \scaledslice.

\section{Nested Bitfields}
Bitfields may have nested bitfields. This can have several uses, one of which being able to define two
different views of a register.

We now define several properties of bitfields, illustrated by the example below.
These are used to define \RequirementRef{BitfieldAlignment}.

The \hypertarget{def-absolutename}{\absolutename} of a (possibly-nested) bitfield is the list of identifiers starting from the
name of the top-level bitfield containing it and following with the names of the nested bitfields,
until the name of the bitfield at hand. We denote an absolute name by separating the names with a
period, similar to the expression used to refer to it.
%
The \hypertarget{def-absoluteslice}{\absoluteslice} of a bitfield are the slices it defines with respected to its containing
bitvector type.
%
The \hypertarget{def-absolutebitfield}{\absolutebitfield} of a given bitfield consists of bits absolute name and its
\absoluteslices.

Further, the \hypertarget{def-bitfieldscope}{\bitfieldscope} of a bitfield is its \absolutename, with the last
identifier (the bitfield's name) removed.
For example, the \bitfieldscope\ of a bitfield with the absolute name \texttt{fmt0.later1.remainder.moving}
is \texttt{fmt0.later1.remainder} and the \bitfieldscope\ of a bitfield with the absolute name
\texttt{fmt0} is the empty list.

We say that two bitfields exist in the same \bitfieldscope\ if the \bitfieldscope\ of one is a prefix
of the \bitfieldscope\ of the other. For example, consider two bitfields whose corresponding \absolutenames\ are
\texttt{fmt0.later1.remainder} and \\
\texttt{fmt0.later1.remainder.moving}, respectively.
They exist in the same scope, since \texttt{fmt0.later1} is a prefix of
\texttt{fmt0.later1.remainder}.
In contrast, a pair of bitfields with \absolutenames\ \texttt{fmt0.common}
and \texttt{fmt1.common}, since neither of \texttt{fmt0} and \texttt{fmt1} is a prefix of the other.

\RequirementDef{BitfieldAlignment}
For every two bitfields of a given bitvector type,
if they share the same name and exist in the same \bitfieldscope\ then their \absoluteslices\ must be
equal.
This is formalized in \TypingRuleRef{CheckCommonBitfieldsAlign} and exemplified in \listingref{nestedbitfields}.

\ExampleDef{A bitvector type with nested bitfields}
\listingref{nestedbitfields} shows a bitvector type with nested bitfields, along with the absolute bitfield
defined for each bitfield.
\ASLListing{A bitvector type with nested bitfields}{nestedbitfields}{\definitiontests/Bitfields_nested.asl}

\subsection{Syntax}
\begin{flalign*}
\Nbitfields \derives \ & \Tlbrace \parsesep \TClistZero{\Nbitfield} \parsesep \Trbrace &\\
\Nbitfield \derives \ & \Nslices \parsesep \Tidentifier &\\
                  |\ & \Nslices \parsesep \Tidentifier \parsesep \Nbitfields &\\
                  |\ & \Nslices \parsesep \Tidentifier \parsesep \Tcolon \parsesep \Nty &\\
\end{flalign*}

\subsection{Abstract Syntax}
\begin{flalign*}
\bitfield \derives\ & \BitFieldSimple(\identifier, \slice^{*})
  & \\
  |\ & \BitFieldNested(\identifier, \slice^{*}, \bitfield^{*})
  & \\
  |\ & \BitFieldType(\identifier, \slice^{*}, \ty) &
\end{flalign*}

\ASTRuleDef{Bitfields}
\hypertarget{build-bitfields}{}
The function
\[
  \buildbitfields(\overname{\parsenode{\Nbitfields}}{\vparsednode}) \;\aslto\; \overname{\bitfield^*}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule{
  \buildtclist[\buildbitfield](\vbitfields) \astarrow \vbitfieldasts
}{
  \buildbitfields(\Nbitfields(\Tlbrace, \namednode{\vbitfields}{\TClistZero{\Nbitfield}}, \Trbrace)) \astarrow
  \overname{\vbitfieldasts}{\vastnode}
}
\end{mathpar}

\ASTRuleDef{Bitfield}
\hypertarget{build-bitfield}{}
The function
\[
  \buildbitfield(\overname{\parsenode{\Nbitfield}}{\vparsednode}) \;\aslto\; \overname{\bitfield}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[simple]{}{
  \buildbitfields(\Nbitfield(\punnode{\Nslices}, \Tidentifier(\vx))) \astarrow
  \overname{\BitFieldSimple(\vx, \astof{\vslices})}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[nested]{}{
  {
    \begin{array}{r}
      \buildbitfields(\Nbitfield(\punnode{\Nslices}, \Tidentifier(\vx), \punnode{\Nbitfields})) \astarrow\\
      \overname{\BitFieldNested(\vx, \astof{\vslices}, \astof{\vbitfields})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[type]{}{
  {
    \begin{array}{r}
      \buildbitfields(\Nbitfield(\punnode{\Nslices}, \Tidentifier(\vx), \Tcolon, \punnode{\Nty})) \astarrow\\
      \overname{\BitFieldType(\vx, \astof{\vslices}, \astof{\tty})}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\section{Typing Bitfields}
\TypingRuleDef{TBitFields}
\hypertarget{def-annotatebitfields}{}
The function
\[
  \annotatebitfields(\overname{\staticenvs}{\tenv} \aslsep \overname{\expr}{\ewidth} \aslsep \overname{\bitfield^*}{\fields})
  \aslto (\overname{\bitfield^*}{\newfields} \times \overname{\TSideEffectSet}{\vses})
  \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a list of bitfields --- $\fields$ --- with an expression denoting the overall number of bits in the containing
bitvector type --- $\ewidth$,
in an environment $\tenv$,
resulting in $\newfields$ --- the \typedast\ for $\fields$ and $\ewidth$
as well as a set of \sideeffectdescriptorsterm\ $\vses$. \ProseOtherwiseTypeError

\ProseParagraph
\AllApply
\begin{itemize}
  \item checking that the list of bitfield names in $\bitfields$ does not contain duplicates yields $\True$\ProseOrTypeError;
  \item symbolically simplifying $\ewidth$ in $\tenv$ via $\staticeval$ yields the literal integer for $\width$\ProseOrTypeError;
  \item annotating each bitfield $\vf$ in $\fields$ with width $\width$ in $\tenv$ yields the corresponding annotated
  bitfield $\vfp$ and \sideeffectsetterm\ $\vxs_\vf$\ProseOrTypeError;
  \item define $\newfields$ as the list of annotated bitfields;
  \item \Prosenonconflictingunion{$\vxs_\vf$ for every field $\vf$ in $\fields$}{$\vses$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \names \eqdef [\field\in\fields: \bitfieldgetname(\field)]\\
  \checknoduplicates(\names) \typearrow \True \OrTypeError\\\\
  \staticeval(\tenv, \ewidth) \typearrow \lint(\width) \OrTypeError\\\\
  \vf\in\fields: \annotatebitfield(\tenv, \width, \field) \typearrow (\vfp, \vxs_\vf) \OrTypeError\\\\
  \newfields \eqdef [\vf\in\fields: \vfp]\\
  \nonconflictingunion(\vf\in\fields: \vxs_\vf) \typearrow \vses \OrTypeError
}{
  \annotatebitfields(\tenv, \ewidth, \fields) \typearrow (\newfields, \vses)
}
\end{mathpar}
\CodeSubsection{\TBitFieldsBegin}{\TBitFieldsEnd}{../Typing.ml}

\TypingRuleDef{BitFieldGetName}
\hypertarget{def-bitfieldgetname}{}
The function
\[
  \bitfieldgetname : \overname{\bitfield}{\vbf} \aslto \overname{\identifier}{\name}
\]
returns the name of a bitfield --- $\name$, given a bitfield $\vbf$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item $\vbf$ is a simple bitfield with name $\name$, that is, $\BitFieldSimple(\name, \Ignore)$;
  \item $\vbf$ is a nested bitfield with name $\name$, that is, $\BitFieldNested(\name, \Ignore, \Ignore)$;
  \item $\vbf$ is a typed bitfield with name $\name$, that is, $\BitFieldType(\name, \Ignore, \Ignore)$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule[simple]{}{
    \bitfieldgetname(\overname{\BitFieldSimple(\name, \Ignore)}{\vbf}) \typearrow \name
  }
  \and
  \inferrule[nested]{}{
    \bitfieldgetname(\overname{\BitFieldNested(\name, \Ignore, \Ignore)}{\vbf}) \typearrow \name
  }
  \and
  \inferrule[type]{}{
    \bitfieldgetname(\overname{\BitFieldType(\name, \Ignore, \Ignore)}{\vbf}) \typearrow \name
  }
\end{mathpar}

\TypingRuleDef{BitFieldGetSlices}
\hypertarget{def-bitfieldgetslices}{}
The function
\[
  \bitfieldgetslices : \overname{\bitfield}{\vbf} \aslto \overname{\slice^*}{\vslices}
\]
returns the list of slices $\vslices$ associated with the bitfield $\vbf$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item $\vbf$ is a simple bitfield with list of slices $\vslices$, that is, $\BitFieldSimple(\Ignore, \vslices)$;
  \item $\vbf$ is a nested bitfield with list of slices $\vslices$, that is, $\BitFieldNested(\Ignore, \vslices, \Ignore)$;
  \item $\vbf$ is a typed bitfield with list of slices $\vslices$, that is, $\BitFieldType(\Ignore, \vslices, \Ignore)$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[simple]{}{
  \bitfieldgetslices(\overname{\BitFieldSimple(\Ignore, \vslices)}{\vbf}) \typearrow \vslices
}
\and
\inferrule[nested]{}{
  \bitfieldgetslices(\overname{\BitFieldNested(\Ignore, \vslices, \Ignore)}{\vbf}) \typearrow \vslices
}
\and
\inferrule[type]{}{
  \bitfieldgetslices(\overname{\BitFieldType(\Ignore, \vslices, \Ignore)}{\vbf}) \typearrow \vslices
}
\end{mathpar}

\TypingRuleDef{BitFieldGetNested}
\hypertarget{def-bitfieldgetnested}{}
The function
\[
  \bitfieldgetnested : \overname{\bitfield}{\vbf} \aslto \overname{\bitfield^*}{\vnested}
\]
returns the list of bitfields $\vnested$ nested within the bitfield $\vbf$, if there are any,
and an empty list if there are none.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{simple\_type}
  \begin{itemize}
    \item $\vbf$ does not have nested bitfields;
    \item $\vnested$ is the empty list.
  \end{itemize}

  \item \AllApplyCase{nested}
  \begin{itemize}
    \item $\vbf$ is bitfields with nested bitfields $\vnested$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[simple\_type]{
  \astlabel(\vbf) \neq \BitFieldNested
}{
  \bitfieldgetname(\vbf) \typearrow \emptylist
}
\and
\inferrule[nested]{}{
  \bitfieldgetname(\overname{\BitFieldNested(\Ignore, \Ignore, \vnested)}{\vbf}) \typearrow \vnested
}
\end{mathpar}

\TypingRuleDef{TBitField}
\hypertarget{def-annotatebitfield}{}
The function
\[
  \annotatebitfield(\overname{\staticenvs}{\tenv} \aslsep \overname{\Z}{\width} \aslsep \overname{\bitfield}{\vfield})
  \aslto (\overname{\bitfield}{\newfield} \times \overname{\TSideEffectSet}{\vses}) \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
annotates a bitfield --- $\vfield$ --- with an integer --- $\width$ --- indicating the number of bits in
the bitvector type that contains $\field$,
in an environment $\tenv$, resulting in an
annotated bitfield --- $\newfield$ --- or a type error, if one is detected.

\ProseParagraph
\begin{itemize}
  \item $\vfield$ is a bitfield with list of slices $\vslices$;
  \item annotating the slices $\vslices$ yields $(\slicesone, \vsesslices)$\ProseOrTypeError;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{simple}
    \begin{itemize}
      \item checking whether the range of positions in $\slicesone$ fits inside $0..\width-1$ yields $\True$\ProseOrTypeError;
      \item define $\newfield$ as the bitfield named $\name$ with list of slices $\slicesone$, that is, $\BitFieldSimple(\name, \slicesone)$.
    \end{itemize}

    \item \AllApplyCase{nested}
    \begin{itemize}
      \item converting the $\slicesone$ into a list of positions with $\width$ and static environment $\tenv$
            yields $\positions$\ProseOrTypeError;
      \item checking that all positions in $\positions$ fit inside $0..\width$ yields \\
            $\True$\ProseOrTypeError;
      \item let $\widthp$ be the length of the list $\positions$;
      \item annotating the bitfields $\bitfieldsp$ with $\widthp$ in static environment $\tenv$ yields $ (\bitfieldspp, \vsesbitfields)$\ProseOrTypeError;
      \item define $\newfields$ as the nested bitfield with $\slicesone$ and bitfields \\
            $\bitfieldspp$, that is, $\BitFieldNested(\slicesone, \bitfieldspp)$;
      \item define $\vses$ as the union of $\vsesslices$ and $\vsesbitfields$.
    \end{itemize}

    \item \AllApplyCase{type}
    \begin{itemize}
      \item Annotating the type $\vt$ yields $(\vtp, \vsesty)$\ProseOrTypeError;
      \item checking whether the range of positions in $\slicesone$ fit inside $0..\width$ yields $\True$\ProseOrTypeError;
      \item converting the list of slices $\slicesone$ into a list of positions in $\tenv$ yields $\positions$\ProseOrTypeError;
      \item checking that all positions in $\positions$ fit inside $0..\width$ yields $\True$\ProseOrTypeError;
      \item let $\widthp$ be the length of the list $\positions$;
      \item checking whether the $\vt$ and the bitvector with $\widthp$ bits have the same width yields $\True$\ProseOrTypeError
      \item define $\newfield$ as the typed bitfield with name $\name$, list of slices \\
            $\slicesone$ and type $\vtp$, that is, \BitFieldType(\name, \slicesone, \vtp);
      \item define $\vses$ as the union of $\vsesslices$ and $\vsesty$.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[simple]{
  \annotateslices(\tenv, \vslices) \typearrow (\slicesone, \vsesslices) \OrTypeError\\\\
  \commonprefixline\\\\
  \checkslicesinwidth(\tenv, \width, \slicesone) \typearrow \True \OrTypeError
}{
  \annotatebitfield(\tenv, \width, \BitFieldSimple(\name, \vslices)) \typearrow \\
  (\overname{\BitFieldSimple(\name, \slicesone)}{\newfield}, \overname{\vsesslices}{\vses})
}
\end{mathpar}

\begin{mathpar}
\inferrule[nested]{
  \annotateslices(\tenv, \vslices) \typearrow (\slicesone, \vsesslices) \OrTypeError\\\\
  \commonprefixline\\\\
  \disjointslicestopositions(\tenv, \slicesone) \typearrow \positions \OrTypeError\\\\
  \checkpositionsinwidth(\tenv, \width, \positions) \typearrow \True \OrTypeError\\\\
  \widthp \eqdef \listlen{\positions}\\
  {
  \begin{array}{r}
  \annotatebitfields(\tenv, \widthp, \bitfieldsp) \typearrow \\ (\bitfieldspp, \vsesbitfields) \OrTypeError
  \end{array}
  }\\
  \vses \eqdef \vsesslices \cup \vsesbitfields
}{
  \annotatebitfield(\tenv, \width, \BitFieldNested(\name, \vslices, \bitfieldsp)) \typearrow \\
  (\overname{\BitFieldNested(\slicesone, \bitfieldspp)}{\newfield}, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[type]{
  \annotateslices(\tenv, \vslices) \typearrow (\slicesone, \vsesslices) \OrTypeError\\\\
  \commonprefixline\\\\
  \annotatetype{\tenv, \vt} \typearrow (\vtp, \vsesty) \OrTypeError\\\\
  \checkslicesinwidth(\tenv, \width, \slicesone) \typearrow \True \OrTypeError\\\\
  \disjointslicestopositions(\tenv, \slicesone) \typearrow \positions \OrTypeError\\\\
  \checkpositionsinwidth(\tenv, \slicesone, \width, \positions) \typearrow \True \OrTypeError\\\\
  \widthp \eqdef \listlen{\positions}\\
  \checkbitsequalwidth(\TBits(\widthp, \emptylist), \vt) \typearrow \True \OrTypeError\\\\
  \vses \eqdef \vsesslices \cup \vsesty
}{
  \annotatebitfield(\tenv, \width, \BitFieldType(\name, \vslices, \vt)) \typearrow \\
  (\overname{\BitFieldType(\name, \slicesone, \vtp)}{\newfield}, \vses)
}
\end{mathpar}

\ExampleDef{Well-typed Bitfields}
In \listingref{welltypedbitvectortypes}, all the uses of bitvector types with bitfields are well-typed.
\ASLListing{Well-typed bitfields}{welltypedbitvectortypes}{\typingtests/TypingRule.TBitField.asl}

\CodeSubsection{\TBitFieldBegin}{\TBitFieldEnd}{../Typing.ml}

\TypingRuleDef{CheckSlicesInWidth}
\hypertarget{def-checkslicesinwidth}{}
The function
\[
  \checkslicesinwidth(\overname{\staticenvs}{\tenv} \aslsep \overname{\Z}{\vwidth} \aslsep \overname{\slice^*}{\vslices})
  \aslto \{\True\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the slices in $\vslices$ fit within the bitvector width given by $\vwidth$ in $\tenv$,
yielding $\True$. \ProseOtherwiseTypeError

\ProseParagraph
\AllApply
\begin{itemize}
    \item applying $\disjointslicestopositions$ to $\vslices$ in $\tenv$ checks whether the
    slices in $\vslices$ are disjoint and yields the set of their positions\ProseOrTypeError;
    \item applying $\checkpositionsinwidth$ to $\vwidth$ and $\positions$ to check that
    all of the positions fit with the width given by $\vwidth$ yields $\True$\ProseOrError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
    \disjointslicestopositions(\tenv, \vslices) \typearrow \positions \OrTypeError\\\\
    \checkpositionsinwidth(\vwidth, \positions) \typearrow \True \OrTypeError
}{
    \checkslicesinwidth(\tenv, \vwidth, \vslices) \typearrow \True
}
\end{mathpar}
\CodeSubsection{\CheckSlicesInWidthBegin}{\CheckSlicesInWidthEnd}{../Typing.ml}

\TypingRuleDef{CheckPositionsInWidth}
\hypertarget{def-checkpositionsinwidth}{}
The function
\[
  \checkpositionsinwidth(\overname{\Z}{\vwidth} \aslsep \overname{\pow{\Z}}{\positions})
  \aslto \{\True\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks whether the set of positions in $\positions$ fit within the bitvector width given by $\vwidth$,
yielding $\True$. \ProseOtherwiseTypeError

\ProseParagraph
\AllApply
\begin{itemize}
    \item define $\minpos$ as the minimal position in $\positions$;
    \item define $\maxpos$ as the maximal position in $\positions$;
    \item checking that $\minpos$ is non-negative and that $\maxpos$ is less than or equal to $\vwidth$
            yields $\True$\ProseTerminateAs{\BadSlices}.
    \item the result is $\True$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
    \minpos \eqdef \min(\positions)\\
    \maxpos \eqdef \max(\positions)\\
    \checktrans{0 \leq \minpos \land \maxpos \leq \vwidth}{\BadSlices} \typearrow \True \OrTypeError
}{
    \checkpositionsinwidth(\vwidth, \positions) \typearrow \True
}
\end{mathpar}

\TypingRuleDef{DisjointSlicesToPositions}
\hypertarget{def-disjointslicestopositions}{}
The function
\[
  \disjointslicestopositions(\overname{\staticenvs}{\tenv}, \overname{\slice^*}{\vslices})
  \aslto \overname{\powfin{\Z}}{\positions} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the set of integers defined by the list of slices in $\vslices$ in $\positions$.
In particular, this rule checks that the bitfield slices do not overlap and that they are not defined in reverse
(e.g., \texttt{0:1} rather than \texttt{1:0})
\ProseOtherwiseTypeError

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vslices$ is the empty list;
    \item $\positions$ is the empty set.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vslices$ is the list with $\vs$ as its \head\ and $\vslicesone$ as its \tail;
    \item applying $\bitfieldslicetopositions$ to $\vs$ in $\tenv$ yields the optional set of positions \\
          $\positionsoneopt$\ProseOrTypeError;
    \item define $\positionsone$ as $\vsone$ if $\positionsoneopt$ is $\langle\vsone\rangle$ and the empty set, otherwise;
    \item applying $\disjointslicestopositions$ to $\vslicesone$ in $\tenv$ yields the optional set of positions
          $\positionstwoopt$\ProseOrTypeError;
    \item define $\positionstwo$ as $\vsone$ if $\positionstwoopt$ is $\langle\vstwo\rangle$ and the empty set, otherwise;
    \item checking that $\positionsone$ is disjoint from $\positionstwo$ yields $\True$\ProseTerminateAs{\BadSlices}
    \item $\positions$ is the union of $\positionsone$ and $\positionstwo$.
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \disjointslicestopositions(\tenv, \overname{\emptylist}{\vslices}) \typearrow \overname{\emptyset}{\positions}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \bitfieldslicetopositions(\tenv, \vs) \typearrow \positionsoneopt \OrTypeError\\\\
  \positionsone \eqdef \choice{\positionsoneopt = \langle\vsone\rangle}{\vsone}{\emptyset}\\
  \disjointslicestopositions(\tenv, \vslicesone) \typearrow \positionstwoopt \OrTypeError\\\\
  \positionstwo \eqdef \choice{\positionstwoopt = \langle\vstwo\rangle}{\vstwo}{\emptyset}\\
  \checktrans{\positionsone \cap \positionstwo = \emptyset}{\BadSlices} \checktransarrow \True \OrTypeError
}{
  \disjointslicestopositions(\tenv, \overname{\vs \concat \vslicesone}{\vslices}) \typearrow \overname{\positionsone \cup \positionstwo}{\positions}
}
\end{mathpar}

\TypingRuleDef{BitfieldSliceToPositions}
\hypertarget{def-bitfieldslicetopositions}{}
The function
\[
  \bitfieldslicetopositions(\overname{\staticenvs}{\tenv}, \overname{\slice}{\vslice})
  \aslto \overname{\langle\powfin{\Z}\rangle}{\positions} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
returns the set of integers defined by the bitfield slice $\vslice$ in $\positions$,
if they can be statically evaluated, or $\None$ if they cannot be statically evaluated.
\ProseOtherwiseTypeError

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{single}
  \begin{itemize}
    \item $\vslice$ is a \singleslice\ defined by the expression $\ve$, that is, $\SliceSingle(\ve)$;
    \item applying $\reducetozopt$ to $\ve$ in $\tenv$ yields the integer literal for $\vx$\ProseTerminateAs{\None};
    \item $\positions$ is the singleton set for $\vx$.
  \end{itemize}

  \item \AllApplyCase{range}
  \begin{itemize}
    \item $\vslice$ is \rangeslice\ defined by expressions $\veone$ and $\vetwo$, that is, \\
          $\SliceRange(\veone, \vetwo)$;
    \item applying $\reducetozopt$ to $\veone$ in $\tenv$ yields the integer literal for $\vx$\ProseTerminateAs{\None};
    \item applying $\reducetozopt$ to $\vetwo$ in $\tenv$ yields the integer literal for $\vy$\ProseTerminateAs{\None};
    \item checking that $\vx$ is less than or equal to $\vy$ yields $\True$\ProseTerminateAs{\BadSlices};
    \item $\positions$ is the set of integers between $\vx$ and $\vy$, inclusive.
  \end{itemize}

  \item \AllApplyCase{length}
  \begin{itemize}
    \item $\vslice$ is \lengthslice\ defined by expressions $\veone$ and $\vetwo$, that is, \\
          $\SliceLength(\veone, \vetwo)$;
    \item applying $\reducetozopt$ to $\veone$ in $\tenv$ yields the integer literal for $\vx$\ProseTerminateAs{\None};
    \item applying $\reducetozopt$ to $\vetwo$ in $\tenv$ yields the integer literal for $\vy$\ProseTerminateAs{\None};
    \item checking that $\vy > 0$ holds (which implies that $\vx \leq \vx+\vy-1$ holds) yields $\True$\ProseTerminateAs{\BadSlices};
    \item $\positions$ is the set of integers between $\vx$ and $\vx+\vy-1$, inclusive.
  \end{itemize}

  \item \AllApplyCase{scaled}
  \begin{itemize}
    \item $\vslice$ is \scaledslice\ defined by expressions $\veone$ and $\vetwo$, that is, \\
          $\SliceStar(\veone, \vetwo)$;
    \item applying $\reducetozopt$ to $\veone$ in $\tenv$ yields the integer literal for $\vx$\ProseTerminateAs{\None};
    \item applying $\reducetozopt$ to $\vetwo$ in $\tenv$ yields the integer literal for $\vy$\ProseTerminateAs{\None};
    \item checking that $\vx > 0$ holds (which implies that $\vx \times \vy \leq \vx \times (\vy + 1) - 1$ holds) yields $\True$\ProseTerminateAs{\BadSlices};
    \item $\positions$ is the set of integers between $\vx \times \vy$ and $\vx \times (\vy + 1) - 1$, inclusive.
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[single]{
  \reducetozopt(\tenv, \ve) \typearrow \langle\vx\rangle \terminateas\None
}{
  \bitfieldslicetopositions(\tenv, \overname{\SliceSingle(\ve)}{\vslice}) \typearrow \overname{\langle\{\vx\}\rangle}{\positions}
}
\end{mathpar}

\begin{mathpar}
\inferrule[range]{
  \reducetozopt(\tenv, \veone) \typearrow \langle\vx\rangle \terminateas\None\\\\
  \reducetozopt(\tenv, \vetwo) \typearrow \langle\vy\rangle \terminateas\None\\\\
  \checktrans{\vy \leq \vx}{\BadSlices} \checktransarrow \True \OrTypeError\\\\
}{
  \bitfieldslicetopositions(\tenv, \overname{\SliceRange(\veone, \vetwo)}{\vslice}) \typearrow
  \overname{\langle\{n \;|\; \vy \leq n \leq \vx\}\rangle}{\positions}
}
\end{mathpar}

\begin{mathpar}
\inferrule[length]{
  \reducetozopt(\tenv, \veone) \typearrow \langle\vx\rangle \terminateas\None\\\\
  \reducetozopt(\tenv, \vetwo) \typearrow \langle\vy\rangle \terminateas\None\\\\
  \checktrans{\vy > 0}{\BadSlices} \checktransarrow \True \OrTypeError\\\\
}{
  \bitfieldslicetopositions(\tenv, \overname{\SliceLength(\veone, \vetwo)}{\vslice}) \typearrow
  \overname{\langle\{n \;|\; \vx \leq n \leq \vx+\vy-1\}\rangle}{\positions}
}
\end{mathpar}
\begin{mathpar}

\inferrule[scaled]{
  \reducetozopt(\tenv, \veone) \typearrow \langle\vx\rangle \terminateas\None\\\\
  \reducetozopt(\tenv, \vetwo) \typearrow \langle\vy\rangle \terminateas\None\\\\
  \checktrans{\vx > 0}{\BadSlices} \checktransarrow \True \OrTypeError
}{
  {
  \begin{array}{r}
  \bitfieldslicetopositions(\tenv, \overname{\SliceStar(\veone, \vetwo)}{\vslice}) \typearrow \\
  \overname{\langle\{n \;|\; \vx \times \vy \leq n \leq \vx \times (\vy + 1) - 1\}\rangle}{\positions}
  \end{array}
  }
}
\end{mathpar}

\TypingRuleDef{CheckCommonBitfieldsAlign}
\hypertarget{def-checkcommonbitfieldsalign}{}
The function
\[
\checkcommonbitfieldsalign(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\bitfield^*}{\vbitfields} \aslsep
  \overname{\N}{\vwidth}
) \aslto \{\True\} \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
checks \RequirementRef{BitfieldAlignment}
for every pair of bitfields in $\vbitfields$, contained in a
bitvector type of width $\vwidth$ in the static environment $\tenv$.
\ProseOtherwiseTypeError

\hypertarget{def-tabsfield}{}
We represent \absolutebitfields\ by the type
$\TAbsField \eqdef (\overname{\identifier^*}{\name}, \overname{\N^*}{\vslice})$,
where the component $\name$ is a list of identifiers corresponding to the \absolutename,
and the component $\vslice$ corresponds to an \absoluteslice\ by listing the indices
into the containing bitvector type.\footnote{An implementation of the type system may compactly represent the list of indices
via a list of intervals, each represented by its limits.}

Premises in \TypingRuleRef{TBits} guarantee that $\vwidth > 0$ holds.

\ExampleDef{Ill-typed Bitfields}
\listingref{CommonBitfieldsAlignError} shows an example where the two bitfields named \texttt{common}
exist in the same \bitfieldscope, but their \absoluteslices\ are not the same.
Specifically, the \absoluteslice\ for the bitfield \texttt{common} is \texttt{[1:0]}
whereas the \absoluteslice\ for the bitfield \texttt{sub.common} is \texttt{[0, 1]}.
Typechecking this example results in the \typingerrorterm{} \BadSlices.

\ASLListing{An example where two bitfields of the same name (\texttt{common}) exist in the same scope
but have different absolute slices}
{CommonBitfieldsAlignError}{\typingtests/TypingRule.CheckCommonBitfieldsAlign.Error.asl}

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vbitfields$ is the empty list;
    \item the result is $\True$.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vbitfields$ is not the empty list;
    \item define $\vlastindex$ as $\vwidth - 1$;
    \item define $\vtopabsolute$ as an \absolutebitfield\ with the empty list
          for a name and a the interval $\vlastindex..0$ (that is, the entire range
          of indices for the containing bitvector type),
          as an artificial top-level \absolutebitfield\ for the entire bitvector type;
    \item \Prosebitfieldstoabsolute{$\tenv$}{$\vbitfields$}{$\vtopabsolute$}{$\vfs$};
    \item checking that \absolutebitfields\ $\vfone$ and $\vftwo$ align via
          $\absolutebitfieldsalign$ in $\tenv$, for every $\vfone$ and $\vftwo$ in $\vfs$,
          yields $\True$\ProseTerminateAs{\BadSlices};
    \item the result is $\True$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{
  \vbitfields = \emptylist
}{
  \checkcommonbitfieldsalign(\tenv, \vbitfields, \overname{0}{\vwidth}) \typearrow \True
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \vbitfields \neq \emptylist\\
  \vlastindex \eqdef \vwidth - 1\\
  \vtopabsolute \eqdef (\emptylist, \vlastindex..0)\\
  \bitfieldstoabsolute(\tenv, \vbitfields, \vtopabsolute) \typearrow \vfs\\
  \checktrans{\forall \vfone, \vftwo \in \vfs: \absolutebitfieldsalign(\vfone, \vftwo)}{\BadSlices} \typearrow \True \OrTypeError
}{
  \checkcommonbitfieldsalign(\tenv, \vbitfields, \vwidth) \typearrow \True
}
\end{mathpar}

\TypingRuleDef{BitfieldsToAbsolute}
\hypertarget{def-bitfieldstoabsolute}{}
The function
\[
\bitfieldstoabsolute(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\bitfield^+}{\vbitfields} \aslsep
  \overname{\TAbsField}{\vabsoluteparent}
) \aslto \overname{\pow{\TAbsField}}{\vabsbitfields}
\]
returns the set of \absolutebitfields\ $\vabsbitfields$ that correspond to the list
of bitfields $\vbitfields$, whose \bitfieldscope\ and \absoluteslice\ is given by
$\vabsoluteparent$, in the static environment $\tenv$.

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\bitfieldtoabsolute$ to each field $\vf$ in $\vbitfields$ with $\vabsoluteparent$ in $\tenv$,
        yields $\va_\vf$;
  \item define $\vabsbitfields$ as the union of the sets $\va_\vf$, for every $\vf$ in $\vbitfields$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vf\in\vbitfields: \bitfieldtoabsolute(\tenv, \vf, \vabsoluteparent) \typearrow \va_\vf\\
  \vabsbitfields \eqdef \bigcup_{\vf\in\vbitfields} \va_\vf
}{
  \bitfieldstoabsolute(\tenv, \vbitfields, \vabsoluteparent) \typearrow \vabsbitfields
}
\end{mathpar}

\TypingRuleDef{BitfieldToAbsolute}
\hypertarget{def-bitfieldtoabsolute}{}
The function
\[
\bitfieldtoabsolute(
  \overname{\staticenvs}{\tenv} \aslsep
  \overname{\bitfield}{\vbf} \aslsep
  \overname{\TAbsField}{\vabsoluteparent}
) \aslto \overname{\pow{\TAbsField}}{\vabsbitfields}
\]
returns the set of \absolutebitfields\ $\vabsbitfields$ that correspond to the
bitfields nested in $\vbf$, including itself, where the \bitfieldscope\ and \absoluteslice\
of the bitfield containing $\vbf$ are $\vabsoluteparent$, in the static environment $\tenv$.

\ProseParagraph
\AllApply
\begin{itemize}
  \item obtaining the name of the bitfield $\vbf$ via $\bitfieldgetname$ yields $\name$;
  \item define the \absolutename\ of $\vbfname$ for $\vbf$ by appending $\name$ to $\vabsname$, the \absolutename{} of $\vabsoluteparent$;
  \item obtaining the list of slices for $\vbf$ via $\bitfieldgetslices$ yields $\vslices$;
  \item \Proseslicetoindices{$\tenv$}{$\vs$}{$\indices_\vs$};
  \item define $\vslicesasindices$ as the concatenation of the sequences $\indices_\vs$,
        for each slice $\vs$ in $\vslices$, in their order of appearance in $\vslices$;
  \item \Proseselectindicesbyslices{$\vabsslices$}{$\vslicesasindices$}{$\vbfindices$}, where $\vabsslices$ are the \absoluteslices{} of $\vabsoluteparent$;
  \item define $\vbfabsolute$ as the \absolutebitfield\ with \absolutename\ $\vbfname$
        and \absoluteslices\ $\vbfindices$;
  \item obtaining the bitfields nested in $\vbf$ via $\bitfieldgetnested$ yields $\vnested$;
  \item \Prosebitfieldstoabsolute{$\tenv$}{$\vnested$}{$\vbfabsolute$}{$\vabsbitfieldsone$};
  \item define $\vabsbitfields$ as the set containing $\vbfabsolute$ and the \absolutebitfields\
        of $\vabsbitfieldsone$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \bitfieldgetname(\vbf) \typearrow \name\\
  \vbfname \eqdef \vabsname \concat [\name]\\
  \bitfieldgetslices(\vbf) \typearrow \vslices\\
  \vs \in \vslices: \slicetoindices(\tenv, \vs) \typearrow \indices_\vs\\
  \vslicesasindices \eqdef [\vs \in \vslices: \indices_\vs]\\
  \selectindicesbyslices(\vabsslices, \vslicesasindices) \typearrow \vbfindices\\
  \vbfabsolute \eqdef (\vbfname, \vbfindices)\\
  \bitfieldgetnested(\vbf) \typearrow \vnested\\
  \bitfieldstoabsolute(\tenv, \vnested, \vbfabsolute) \typearrow \vabsbitfieldsone
}{
  {
    \begin{array}{r}
      \bitfieldtoabsolute(\tenv, \vbf, \overname{(\vabsname, \vabsslices)}{\vabsoluteparent}) \typearrow \\
      \overname{\{\vbfabsolute\} \cup \vabsbitfieldsone}{\vabsbitfields}
    \end{array}
  }
}
\end{mathpar}

\TypingRuleDef{SliceIndicesBySlices}
\hypertarget{def-selectindicesbyslices}{}
The function
\[
\selectindicesbyslices(\overname{\N^+}{\indices}, \overname{\N^+}{\sliceindices})
\aslto \overname{\N^*}{\vabsslice}
\]
considers the list $\indices$ as a list of indices into a bitvector type (essentially, a slice of it),
and the list $\sliceindices$ as a list of indices into $\indices$ (a slice of a slice),
and returns the sub-list of $\indices$ indicated by the indices in $\sliceindices$.
% The reference abstracts away from the implementation,
% which represents sequence of indices via intervals.

\ProseParagraph
\AllApply
\begin{itemize}
  \item view $\sliceindices$ as the list $S_{m..0}$;
  \item view $\indices$ as the list $I_{n..0}$;
  \item define $\vabsslice$ as the list $I[S_m] \ldots I[S_0]$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \selectindicesbyslices(\overname{I_{n..0}}{\indices}, \overname{S_{m..0}}{\sliceindices}) \typearrow
    \overname{I[S_m] \ldots I[S_0]}{\vabsslice}
}
\end{mathpar}

\TypingRuleDef{AbsoluteBitfieldsAlign}
\hypertarget{def-absolutefieldsalign}{}
The function
\[
\absolutebitfieldsalign(\overname{\TAbsField}{\vf}, \overname{\TAbsField}{\vg})
\aslto \overname{\Bool}{\vb}
\]
tests whether the \absolutebitfields\ $\vfone$ and $\vftwo$ share the same name
and exist in the same scope. If they do, $\vb$ indicates whether their \absoluteslices\
are equal. Otherwise, the result if $\True$.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vf$ is an \absolutebitfield\ with \absolutename\ $\vf_{1..k}$ and \absoluteslice\ $\vsliceone$;
  \item $\vg$ is an \absolutebitfield\ with \absolutename\ $\vg_{1..n}$ and \absoluteslice\ $\vslicetwo$;
  \item define $\nameone$ to be the name of the bitfield corresponding to $\vf$, that is, $\vf_k$;
  \item define $\nametwo$ to be the name of the bitfield corresponding to $\vg$, that is, $\vg_n$;
  \item define $\vscopeone$ to be the \bitfieldscope\ of $\vf$, that is, $\vf_{1..k-1}$;
  \item define $\vscopetwo$ to be the \bitfieldscope\ of $\vg$, that is, $\vg_{1..n-1}$;
  \item define $\vsamescope$ as $\True$ if and only if $\vscopeone$ is a \listprefixterm\ of $\vscopetwo$ or vice versa;
  \item define $\vb$ as $\True$ if and only if $\nameone$ and $\nametwo$ are equal and $\vsamescope$ is $\True$ implies
        that $\vsliceone$ is equal to $\vslicetwo$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \nameone \eqdef \vf_k\\
  \nametwo \eqdef \vg_n\\
  \vscopeone \eqdef \vf_{1..k-1}\\
  \vscopetwo \eqdef \vg_{1..n-1}\\
  \vsamescope \eqdef \listprefix(\vscopeone, \vscopetwo) \lor \listprefix(\vscopetwo, \vscopeone)\\
  \vb \eqdef (\nameone = \nametwo\ \land\ \vsamescope) \Longrightarrow (\vsliceone = \vslicetwo)
}{
  \absolutebitfieldsalign(\overname{(\vf_{1..k}, \vsliceone)}{\vf}, \overname{(\vg_{1..n}, \vslicetwo)}{\vf})
  \typearrow \vb
}
\end{mathpar}

\TypingRuleDef{SliceToIndices}
\hypertarget{def-slicetoindices}{}
The function
\[
\slicetoindices(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice}{\vs}) \aslto \overname{\N^*}{\indices}
\]
returns the list of indices $\indices$ represented by the bitvector slice $\vs$ in the static environment $\tenv$.

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vs$ is a \lengthslice\ for the expressions $\vi$ and $\vw$;
  \item \Prosestaticeval{$\tenv$}{$\vi$}{the literal for the integer $\vz_\vi$};
  \item \Prosestaticeval{$\tenv$}{$\vw$}{the literal for the integer $\vz_\vw$};
  \item define $\vstart$ as $\vz_\vi$;
  \item define $\vend$ as $\vz_\vi + \vz_\vw - 1$;
  \item define $\indices$ as the list of integers starting at $\vend$ and counting down to $\vstart$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
  \inferrule{
  \staticeval(\tenv, \vi) \typearrow \lint(\vz_\vi)\\
  \staticeval(\tenv, \vw) \typearrow \lint(\vz_\vw)\\
  \vstart \eqdef \vz_\vi\\
  \vend \eqdef \vz_\vi + \vz_\vw - 1\\
}{
  \slicetoindices(\tenv, \overname{\SliceLength(\vi, \vw)}{\vs}) \typearrow \overname{\vend..\vstart}{\indices}
}
\end{mathpar}
