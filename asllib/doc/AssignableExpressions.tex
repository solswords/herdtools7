\chapter{Assignable Expressions\label{chap:AssignableExpressions}}

\hypertarget{def-assignableexpression}{}
We refer to expressions that may appear on the left hand side of an assignment statement as \assignableexpressions.
An \assignableexpression\ is grammatically derived from $\Nlexpr$ and is represented as an AST
by $\lexpr$.

We show the syntax relevant to \assignableexpressions\ in \secref{AssignableExpressionsSyntax} and
the rules need to build the AST for \assignableexpressions\ in \secref{AssignableExpressionsAbstractSyntaxBuilders}.
These rules rely on three further desugaring relations, defined in \secref{AssignableExpressionsDesugaring}.
We then define the abstract syntax, typing, and semantics of the different kinds of \assignableexpressions:
\begin{itemize}
\item Discarding assignment expressions (see \secref{DiscardingAssignmentExpressions})
\item Variable assignment expressions (see \secref{VariableAssignmentExpressions})
\item Multi-assignment expressions (see \secref{MultiAssignmentExpressions})
\item Array assignment expressions (see \secref{ArrayAssignmentExpressions})
\item Bitvector slice assignment expressions (see \secref{BitvectorSliceAssignmentExpressions})
\item Structured type field assignment expressions (\secref{StructuredTypeFieldAssignmentExpressions})
\item Structured type multi-field assignment expressions (\secref{StructuredTypeMultiFieldAssignmentExpressions})
\item Bitfield assignment expressions (see \secref{BitfieldAssignmentExpressions})
\end{itemize}

\hypertarget{def-annotatelexpr}{}
The function
\[
  \annotatelexpr{
    \overname{\staticenvs}{\tenv} \aslsep
    \overname{\lexpr}{\vle} \aslsep
    \overname{\ty}{\vte}} \aslto
    (\overname{\lexpr}{\newle} \times \overname{\TSideEffectSet}{\vses}) \cup \TTypeError
\]
annotates a left-hand side expression $\vle$ in an environment $\tenv$, assuming $\vte$
to be the type of the corresponding right-hand-side expression,
resulting in an annotated expression $\newle$ and inferred \sideeffectsetterm\ $\vses$.
\ProseOtherwiseTypeError

The relation
\hypertarget{def-evallexpr}{}
\[
  \evallexpr{\overname{\envs}{\env} \aslsep \overname{\lexpr}{\vle} \aslsep (\overname{\vals}{\vv} \times \overname{\XGraphs}{\vg})} \;\aslrel\;
    \Normal(\overname{\XGraphs}{\newg},\overname{\envs}{\newenv}) \cup
    \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TDynError}{\DynErrorConfig}
\]
evaluates the assignment of a value $\vv$
to the left-hand-side expression $\vle$ in an environment $\env$,
resulting in either a configuration $\Normal(\newg, \env)$ or an abnormal configuration.

\paragraph{Semantics Rules Naming Convention:}
In this chapter, variables containing $\vm$ range over $\vals\times\XGraphs$
while variables where the $\vm$ is replaced with $\vv$ correspond to their value component.
For example, $\rmarray\eqname(\rvarray,\vgtwo)$ and $\mindex\eqname(\vindex, \vgone)$.

\paragraph{Viewing Assignable Expressions as Right-hand-side Expressions:}
Some of the typing rules and semantics rules require viewing \assignableexpressions\
as \rhsexpressions.
The correspondence is given by the function $\torexpr : \lexpr \rightarrow \expr$., defined in \secref{LeftToRight}.
%
For example, \SemanticsRuleRef{LESetField}
needs to evaluate the record subexpression $\rerecord$, which is an \assignableexpression.
To achieve this, $\torexpr(\record)$ is used to obtain an \rhsexpression, which then allows
using $\texttt{eval\_expr}$ to evaluate it.

\section{Syntax\label{sec:AssignableExpressionsSyntax}}
\begin{flalign*}
\Nlexpr \derives\
   & \Tminus &\\
|\ & \Nslicedbasiclexpr &\\
|\ & \Tlpar \parsesep \Clisttwo{\Ndiscardorslicedbasiclexpr} \parsesep \Trpar &\\
|\ & \Tidentifier \parsesep \Tdot \parsesep \Tlbracket \parsesep \Clisttwo{\Tidentifier} \parsesep \Trbracket &\\
|\ & \Tidentifier \parsesep \Tdot \parsesep \Tlpar \parsesep \Clisttwo{\Ndiscardoridentifier} \parsesep \Trpar &
\end{flalign*}

\begin{flalign*}
\Nbasiclexpr \derives\
   & \Tidentifier \parsesep \Nnestedfields &\\
|\ & \Tidentifier \parsesep \Tllbracket \parsesep \Nexpr \parsesep \Trrbracket \parsesep \Nnestedfields &
\end{flalign*}

\begin{flalign*}
\Nnestedfields \derives\ & \emptysentence \;|\; \Tdot \parsesep \Tidentifier \parsesep \Nnestedfields &
\end{flalign*}

\begin{flalign*}
\Nslicedbasiclexpr \derives\ & \Nbasiclexpr \;|\; \Nbasiclexpr \parsesep \Nslices &
\end{flalign*}

\begin{flalign*}
\Ndiscardorslicedbasiclexpr \derives\ & \Tminus \;|\; \Nslicedbasiclexpr &
\end{flalign*}

\begin{flalign*}
\Ndiscardoridentifier \derives \ & \Tminus \;|\; \Tidentifier &
\end{flalign*}

\subsection{Abstract Syntax Builders\label{sec:AssignableExpressionsAbstractSyntaxBuilders}}

We first define $\lhsaccess$, which we use in this section as an intermediate representation between some syntax forms of \assignableexpressions{} and their corresponding abstract syntax.
In particular, rather than directly building the abstract syntax for these \assignableexpressions{}, we first build structures containing $\lhsaccess$, which we then desugar into abstract syntax in \secref{AssignableExpressionsDesugaring}.

\hypertarget{ast-lhsaccess}{}
\begin{flalign*}
\lhsaccess \derives\ &
{
\left\{
  \begin{array}{rcl}
    \lhsaccessbase &:& \identifier, \\
    \lhsaccessindex &:& \expr?,\\
    \lhsaccessfields &:& \identifier^{*},\\
    \lhsaccessslices &:& \slice^{*}
\end{array}
\right\}
} &
\end{flalign*}

\ASTRuleDef{LExpr}
\hypertarget{build-lexpr}{}
The function
\[
  \buildlexpr(\overname{\parsenode{\Nlexpr}}{\vparsednode}) \;\aslto\; \overname{\lexpr}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[discard]{}{
  \buildlexpr(\Nlexpr(\Tminus)) \astarrow \overname{\LEDiscard}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[sliced\_basic\_lexpr]{
  \desugarlhsaccess(\astof{\vslicedbasiclexpr}) \astarrow \vastnode
}{
  \buildlexpr(\Nlexpr(\punnode{\Nslicedbasiclexpr})) \astarrow \vastnode
}
\end{mathpar}

\begin{mathpar}
\inferrule[multi\_lexpr]{
  \buildclist[\builddiscardorslicedbasiclexpr](\vlexprs) \astarrow \vlexprasts \\
  \desugarlhstuple(\vlexprasts) \astarrow \vastnode
}{
  {
  \begin{array}{r}
  \buildlexpr(\Nlexpr(\Tlpar, \namednode{\vlexprs}{\Clisttwo{\Ndiscardorslicedbasiclexpr}}, \Trpar)) \\
  \astarrow \vastnode
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[concat\_fields]{
  \buildclist[\buildidentity](\vfields) \astarrow \vfieldasts
}{
  {
  \begin{array}{r}
  \buildlexpr(\Nlexpr(\Tidentifier(\id), \Tdot, \Tlbracket, \namednode{\vfields}{\Clisttwo{\Tidentifier}}, \Trbracket)) \astarrow \\
  \overname{\LESetFields (\LEVar(\id), \vfieldasts)}{\vastnode}
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
\inferrule[tuple\_fields]{
  \buildclist[\builddiscardoridentifier](\vids) \astarrow \astversion{\vids} \\
  \desugarlhsfieldstuple(\id, \astversion{\vids}) \astarrow \vastnode
}{
  {
  \begin{array}{r}
  \buildlexpr(\Nlexpr(\Tidentifier(\id), \Tdot, \Tlpar, \namednode{\vids}{\Clisttwo{\Ndiscardoridentifier}}, \Trpar))\\ \astarrow
  \vastnode
  \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{BasicLexpr}
\hypertarget{build-basiclexpr}{}
The function
\[
  \buildbasiclexpr(\overname{\parsenode{\Nbasiclexpr}}{\vparsednode}) \;\aslto\; \overname{\lhsaccess}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[no\_index]{
  \vastnode \eqdef \left\{
  {
  \begin{array}{rcl}
    \lhsaccessbase   &:& \id,\\
    \lhsaccessindex  &:& \None,\\
    \lhsaccessfields &:& \astof{\vnestedfields},\\
    \lhsaccessslices &:& \emptylist
  \end{array}
  }
  \right\}
}{
  \buildbasiclexpr(\Nbasiclexpr(\Tidentifier(\id), \punnode{\Nnestedfields})) \astarrow
  \vastnode
}
\end{mathpar}

\begin{mathpar}
\inferrule[index]{
  \vastnode \eqdef \left\{
  {
  \begin{array}{rcl}
    \lhsaccessbase   &:& \id,\\
    \lhsaccessindex  &:& \langle \astof{\vexpr} \rangle,\\
    \lhsaccessfields &:& \astof{\vnestedfields},\\
    \lhsaccessslices &:& \emptylist
  \end{array}
  }
  \right\}
}{
  \buildbasiclexpr(\Nbasiclexpr(\Tidentifier(\id), \Tllbracket, \punnode{\Nexpr}, \Trrbracket, \punnode{\Nnestedfields})) \astarrow
  \vastnode
}
\end{mathpar}

\ASTRuleDef{NestedFields}
\hypertarget{build-nestedfields}{}
The function
\[
  \buildnestedfields(\overname{\parsenode{\Nnestedfields}}{\vparsednode}) \;\aslto\; \overname{\identifier^*}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[empty]{}{
  \buildnestedfields(\Nnestedfields(\emptysentence)) \astarrow
  \overname{\emptylist}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{}{
  {
    \begin{array}{r}
      \buildnestedfields(\Nnestedfields(\Tdot, \Tidentifier(\id), \punnode{\Nnestedfields})) \astarrow\\
      \overname{[\id] \concat \astof{\vnestedfields}}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{SlicedBasicLexpr}
\hypertarget{build-slicedbasiclexpr}{}
The function
\[
  \buildslicedbasiclexpr(\overname{\parsenode{\Nslicedbasiclexpr}}{\vparsednode}) \;\aslto\; \overname{\lhsaccess}{\vastnode}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[no\_slices]{}{
  \buildslicedbasiclexpr(\Nslicedbasiclexpr(\punnode{\Nbasiclexpr})) \astarrow
  \overname{\astof{\vbasiclexpr}}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[slices]{}{
  {
    \begin{array}{r}
      \buildslicedbasiclexpr(\Nslicedbasiclexpr(\punnode{\Nbasiclexpr}, \punnode{\Nslices})) \astarrow \\
      \overname{\astof{\vbasiclexpr}[\lhsaccessslices \mapsto \astof{\vslices}]}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{DiscardOrSlicedBasicLexpr}

\hypertarget{build-discardorslicedbasiclexpr}{}
The function
\[
\begin{array}{r}
  \builddiscardorslicedbasiclexpr(\overname{\parsenode{\Ndiscardorslicedbasiclexpr}}{\vparsednode}) \;\aslto\\
  \overname{\langle\lhsaccess\rangle}{\vastnode}
\end{array}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[discard]{}{
  \builddiscardorslicedbasiclexpr(\Ndiscardorslicedbasiclexpr(\Tminus)) \astarrow \overname{\None}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[sliced\_basic]{}{
  {
    \begin{array}{r}
      \builddiscardorslicedbasiclexpr(\Ndiscardorslicedbasiclexpr(\punnode{\Nslicedbasiclexpr})) \astarrow \\
      \overname{\langle \astof{\vslicedbasiclexpr} \rangle}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\ASTRuleDef{DiscardOrIdentifier}

\hypertarget{build-discardoridentifier}{}
The function
\[
\begin{array}{r}
  \builddiscardoridentifier(\overname{\parsenode{\Ndiscardoridentifier}}{\vparsednode}) \;\aslto
  \overname{\langle\identifier\rangle}{\vastnode}
\end{array}
\]
transforms a parse node $\vparsednode$ into an AST node $\vastnode$.

\begin{mathpar}
\inferrule[none]{}{
  \builddiscardoridentifier(\Ndiscardoridentifier(\Tminus)) \astarrow \overname{\None}{\vastnode}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{}{
  {
    \begin{array}{r}
      \builddiscardoridentifier(\Ndiscardoridentifier(\Tidentifier(\id))) \astarrow
      \overname{\langle \id \rangle}{\vastnode}
    \end{array}
  }
}
\end{mathpar}

\subsection{Desugaring Assignable Expressions\label{sec:AssignableExpressionsDesugaring}}

This section defines three desugaring relations which produce assignable expression abstract syntax, that is, $\lexpr$.
They are used in \secref{AssignableExpressionsAbstractSyntaxBuilders} to build $\lexpr$ abstract syntax.
\begin{itemize}
  \item $\desugarlhsaccess$, which desugars an $\lhsaccess$ into an $\lexpr$.
  \item $\desugarlhstuple$, which desugars a tuple of optional $\lhsaccess$ elements into an $\lexpr$.
    This represents a multi-assignment of a tuple value, where $\None$ means that element of the tuple is discarded.
  \item $\desugarlhsfieldstuple$, which desugars a multi-assignment of a tuple value to multiple fields of an identifier.
\end{itemize}

\ASTRuleDef{DesugarLHSAccess}
\hypertarget{def-desugarlhsaccess}{}
The function
\[
  \desugarlhsaccess(\overname{\lhsaccess}{\vlhsaccess}) \;\aslto\; \overname{\lexpr}{\vlexpr}
\]
transforms an $\lhsaccess$ into an AST node $\vlexpr$.

\begin{mathpar}
\inferrule[index\_none]{
  \vlexprs_0 \eqdef \EVar(\id) \\
  i \in 1..|\vfields|: \vlexprs_i \eqdef \LESetField(\vlexprs_{i-1}, \vfields_i) \\
  \vsliced \eqdef
  \choice{\vslices = \emptylist}{\vlexprs_{|\vfields|}}{\ESlice(\vlexprs_{|\vfields|}, \vslices)} \\
}{
  \desugarlhsaccess\overname{
    \left\{
      {
        \begin{array}{rcl}
          \lhsaccessbase &:& \id, \\
          \lhsaccessindex &:& \None,\\
          \lhsaccessfields &:& \vfields,\\
          \lhsaccessslices &:& \vslices
        \end{array}
      }
    \right\}
  }{\vlhsaccess} \astarrow \overname{\vsliced}{\vlexpr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[index\_some]{
  \vlexprs_0 \eqdef \LESetArray(\EVar(\id), \vindex) \\
  i \in 1..|\vfields|: \vlexprs_i \eqdef \LESetField(\vlexprs_{i-1}, \vfields_i) \\
  \vsliced \eqdef
  \choice{\vslices = \emptylist}{\vlexprs_{|\vfields|}}{\ESlice(\vlexprs_{|\vfields|}, \vslices)} \\
}{
  \desugarlhsaccess\overname{
    \left\{
      {
        \begin{array}{rcl}
          \lhsaccessbase &:& \id, \\
          \lhsaccessindex &:& \langle\vindex\rangle,\\
          \lhsaccessfields &:& \vfields,\\
          \lhsaccessslices &:& \vslices
        \end{array}
      }
    \right\}
  }{\vlhsaccess} \astarrow \overname{\vsliced}{\vlexpr}
}
\end{mathpar}
\ASTRuleDef{DesugarLHSTuple}
\hypertarget{def-desugarlhstuple}{}
The function
\[
  \desugarlhstuple(\overname{\langle\lhsaccess\rangle^*}{\vlhsaccessopts}) \;\aslto\; \overname{\lexpr}{\vlexpr}
\]
transforms a list of \optional{} $\lhsaccess$ elements into an AST node $\vlexpr$. \\

\hypertarget{def-desugarlhsaccessopt}{}
\noindent We first define the helper AST function
\[
    \desugarlhsaccessopt(\overname{\langle\lhsaccess\rangle}{\vlhsaccessopt}) \;\aslto\; \overname{\lexpr}{\vlexpr}
\]
via the following rules:
\begin{mathpar}
\inferrule[none]{}
{
  \desugarlhsaccessopt(\overname{\None}{\vlhsaccessopt}) \astarrow \overname{\LEDiscard}{\vlexpr}
}
\end{mathpar}

\begin{mathpar}
\inferrule[some]{
  \desugarlhsaccess(\vlhsaccess) \astarrow \vlexpr
}{
  \desugarlhsaccessopt(\overname{\langle\vlhsaccess\rangle}{\vlhsaccessopt}) \astarrow \vlexpr
}
\end{mathpar}

\noindent We now use the helper rules to define $\desugarlhstuple$:
\begin{mathpar}
\inferrule{
  \vlhsaccesses \eqdef \filteroptionlist(\vlhsaccessopts) \\
  \vids \eqdef [i \in 1..|\vlhsaccesses|: \vlhsaccesses_i.\lhsaccessbase] \\
  \checknoduplicates(\vids) \typearrow \True \OrTypeError \\
  i \in 1..|\vlhsaccessopts|: \desugarlhsaccessopt(\vlhsaccessopt_i) \astarrow \vlexpr_i \\
  \vlexprs \eqdef [i \in 1..|\vlhsaccessopts|: \vlexpr_i]
}{
  \desugarlhstuple(\vlhsaccessopts) \astarrow \overname{\LEDestructuring(\vlexprs)}{\vlexpr}
}
\end{mathpar}

\ASTRuleDef{DesugarLHSFieldsTuple}
\hypertarget{def-desugarlhsfieldstuple}{}
The function
\[
  \desugarlhsfieldstuple(\overname{\identifier}{\id} \aslsep \overname{\langle\identifier\rangle^*}{\fieldopts}) \;\aslto\; \overname{\lexpr}{\vlexpr}
\]
transforms an assignment to a tuple of fields $\fields$ of variable $\id$ into an AST node $\vlexpr$. \\

\hypertarget{def-desugarlhsfieldopt}{}
\noindent We first define the helper AST function
\[
    \desugarlhsfieldopt(\overname{\identifier}{\id} \aslsep \overname{\langle\identifier\rangle}{\fieldopt}) \;\aslto\; \overname{\lexpr}{\vlexpr}
\]
via the following rules:
\begin{mathpar}
\inferrule[none]{}
{
  \desugarlhsfieldopt(\id, \overname{\None}{\fieldopt}) \astarrow \overname{\LEDiscard}{\vlexpr}
}
\end{mathpar}

\begin{mathpar}
\inferrule{}{
  \desugarlhsfieldopt(\id, \overname{\langle\vfield\rangle}{\fieldopt}) \astarrow \overname{\LESetField(\LEVar(\id), \vfield)}{\vlexpr}
}
\end{mathpar}

\noindent We now use the helper rules to define $\desugarlhsfieldstuple$:
\begin{mathpar}
\inferrule{
  \fields \eqdef \filteroptionlist(\fieldopts) \\
  \checknoduplicates(\fields) \typearrow \True \OrTypeError \\
  i \in 1..|\fieldopts|: \desugarlhsfieldopt(\fieldopts_i) \astarrow \vlexpr_i \\
  \vlexprs \eqdef [i \in 1..|\fieldopts|: \vlexpr_i]
}{
  \desugarlhsfieldstuple(\id, \fieldopts) \astarrow \overname{\LEDestructuring(\vlexprs)}{\vlexpr}
}
\end{mathpar}

\hypertarget{def-discardlexprterm}{}
\section{Discarding Assignment Expressions\label{sec:DiscardingAssignmentExpressions}}
\subsection{Abstract Syntax}
\begin{flalign*}
\lexpr \derives\ & \overtext{\LEDiscard}{\texttt{"-"}} &
\end{flalign*}

\subsection{Typing}
\TypingRuleDef{LEDiscard}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes an expression that can be discarded, that is, $\LEDiscard$;
  \item \Proseeqdef{$\newle$}{$\vle$};
  \item \Proseeqdef{$\vses$}{the empty set}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{}{
  \annotatelexpr{\tenv, \overname{\LEDiscard}{\vle}, \vte} \typearrow (\overname{\LEDiscard}{\newle}, \overname{\emptyset}{\vses})
}
\end{mathpar}
\CodeSubsection{\LEDiscardBegin}{\LEDiscardEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{LEDiscard}
\ExampleDef{Discarding Assignments}
In \listingref{semantics-lediscard}, the assignment \texttt{- = 42;} does not affect the environment.
\ASLListing{Assignment to \texttt{-}}{semantics-lediscard}{\semanticstests/SemanticsRule.LEDiscard.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ is a discarding expression, $\LEDiscard$;
  \item $\newg$ is $\vg$;
  \item $\newenv$ is $\env$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \newg\eqdef\vg\\
  \newenv\eqdef\env
}{
  \evallexpr{\env, \LEDiscard, (\vv, \vg)} \evalarrow \Normal(\newg, \newenv)
}
\end{mathpar}
\CodeSubsection{\EvalLEDiscardBegin}{\EvalLEDiscardEnd}{../Interpreter.ml}

\hypertarget{def-varlexprterm}{}
\section{Variable Assignment Expressions\label{sec:VariableAssignmentExpressions}}
\subsection{Abstract Syntax}
\begin{flalign*}
\lexpr \derives\ & \LEVar(\identifier) &
\end{flalign*}

\subsection{Typing}
\TypingRuleDef{LEVar}
\ProseParagraph
\OneApplies
\begin{itemize}
  \item $\vle$ denotes a left-hand-side variable expression for $\vx$, that is, $\LEVar(\vx)$;
  \item \AllApplyCase{local}
  \begin{itemize}
    \item $\vx$ is declared in $\tenv$ as a local storage element with type $\tty$ and local declaration keyword $k$;
    \item checking that $k$ corresponds to a mutable variable, that is, $\LDKVar$, yields $\True$\ProseTerminateAs{\AssignmentToImmutable};
    \item determining whether $\tty$ \typesatisfies\ $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\newle$ is $\vle$;
    \item \Proseeqdef{$\vses$}{the \WriteLocalTerm\ for $\vx$}.
  \end{itemize}

  \item \AllApplyCase{global}
  \begin{itemize}
    \item $\vx$ is declared in $\tenv$ as a global storage element with type $\tty$ and global declaration keyword $k$;
    \item checking that $k$ corresponds to a mutable variable, that is, $\GDKVar$, yields $\True$\ProseTerminateAs{\AssignmentToImmutable};
    \item determining whether $\tty$ \typesatisfies\ $\vte$ in $\tenv$ yields $\True$\ProseOrTypeError;
    \item $\newle$ is $\vle$;
    \item \Proseeqdef{$\vses$}{the \WriteGlobalTerm\ for $\vx$}.
  \end{itemize}

  \item \AllApplyCase{error\_undefined}
  \begin{itemize}
    \item $\vx$ is not declared in $\tenv$ as a local storage element nor as a global storage element;
    \item the result is a type error $\UndefinedIdentifier$.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[local]{
  L^\tenv.\localstoragetypes(\vx) = (\tty, k)\\
  \checktrans{k = \LDKVar}{\AssignmentToImmutable} \checktransarrow \True \OrTypeError\\\\
  \checktypesat(\tenv, \vte, \tty) \typearrow \True \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LEVar(\vx)}{\vle}, \vte} \typearrow
  (\overname{\vle}{\newle}, \{\WriteLocal(\vx)\})
}
\end{mathpar}

\begin{mathpar}
\inferrule[global]{
  L^\tenv.\globalstoragetypes(\vx) = (\tty, k)\\
  \checktrans{k = \GDKVar}{AssignToImmutable} \checktransarrow \True \OrTypeError\\\\
  \checktypesat(\tenv, \vte, \tty) \typearrow \True \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LEVar(\vx)}{\vle}, \vte} \typearrow
  (\overname{\vle}{\newle}, \{\WriteGlobal(\vx)\})
}
\end{mathpar}

\begin{mathpar}
\inferrule[error\_undefined]{
  L^\tenv.\localstoragetypes(\vx) = \bot\\
  L^\tenv.\globalstoragetypes(\vx) = \bot
}{
  \annotatelexpr{\tenv, \overname{\LEVar(\vx)}{\vle}, \vte} \typearrow \TypeErrorVal{\UndefinedIdentifier}
}
\end{mathpar}
\identr{WDGQ} \identr{GNTS} \identi{MMKF}
\identi{DGWJ} \identi{KKCC}  \identr{LXQZ}
\CodeSubsection{\LEVarBegin}{\LEVarEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{LEVar}
\ExampleDef{Local Variable}
In \listingref{semantics-levar}, \SemanticsRuleRef{LEVar} is (only) used
to assign the value $42$ to the left-hand-side expression
\texttt{x} within \texttt{x = 42;}.

\ASLListing{Semantics of a left-hand-side variable expression}{semantics-levar}{\semanticstests/SemanticsRule.LELocalVar.asl}

\ExampleDef{Global Variable}
In \listingref{semantics-leglobalvar},
\SemanticsRuleRef{LEVar} is (only) used to assign the value $42$ to the left-hand-side expression
\texttt{x} within \texttt{x = 42;}.
\ASLListing{Assignment to a global variable}{semantics-leglobalvar}{\semanticstests/SemanticsRule.LEGlobalVar.asl}

\ProseParagraph
\AllApply
\begin{itemize}
    \item $\vle$ denotes a variable, $\LEVar(\vx)$;
    \item view $\env$ as an environment where $\tenv$ is the static environment and $\denv$ is the dynamic environment;
    \item \OneApplies
    \begin{itemize}
        \item \AllApplyCase{local}
        \begin{itemize}
            \item $\vx$ is in the local dynamic environment ($L^\denv$);
            \item $\newenv$ is $\env$ where $\vx$ is bound to $\vv$ in the local dynamic environment ($L^\denv$).
        \end{itemize}

        \item \AllApplyCase{global}
        \begin{itemize}
            \item $\vx$ is bound in the global dynamic environment ($G^\denv.\storage$);
            \item $\newenv$ is $\env$ where $\vx$ is bound to $\vv$ in the $\storage$ map of the global dynamic environment $G^\denv$.
        \end{itemize}
    \end{itemize}
    \item $\newg$ is the ordered composition of $\vg$ and a Write Effect for $\vx$ with the $\asldata$ edge;
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[local]{
  \env \eqname (\tenv, \denv)\\
  \vx \in \dom(L^\denv)\\
  \newenv \eqdef (\tenv, (G^\denv, L^\denv[\vx \mapsto \vv]))\\
  \newg \eqdef \ordered{\vg}{\asldata}{\WriteEffect(\vx)}
}{
  \evallexpr{\env, \LEVar(\vx), (\vv, \vg)} \evalarrow \Normal(\newg,\newenv)
}
\end{mathpar}

\begin{mathpar}
\inferrule[global]{
  \env \eqname (\tenv, \denv)\\
  \vx \in \dom(G^\denv.\storage)\\
  \newenv \eqdef(\tenv, (G^\denv.\storage[\vx \mapsto \vv], L^\denv))\\
  \newg \eqdef \ordered{\vg}{\asldata}{\WriteEffect(\vx)}
}{
  \evallexpr{\env, \LEVar(\vx), (\vv, \vg)} \evalarrow \Normal(\newg,\newenv)
}
\end{mathpar}
\CodeSubsection{\EvalLEVarBegin}{\EvalLEVarEnd}{../Interpreter.ml}

\hypertarget{def-destructuringlexprterm}{}
\section{Multi-assignment Expressions\label{sec:MultiAssignmentExpressions}}
\subsection{Abstract Syntax}
\begin{flalign*}
\lexpr \derives\ & \LEDestructuring(\lexpr^*) &
\end{flalign*}

\subsection{Typing}
\TypingRuleDef{LEDestructuring}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes a tuple of left-hand-side expressions $\les$, that is, $\LEDestructuring(\les)$;
  \item $\les$ is a list $\ve_{1..k}$;
  \item checking whether $\vte$ is a \tupletypeterm{} yields $\True$\ProseTerminateAs{\UnexpectedType};
  \item $\vte$ is a \tupletypeterm{} over the list of types $\tys$, that is, $\TTuple(\tys)$;
  \item determining whether $\les$ and $\subtys$ have the same length yields $\True$\ProseTerminateAs{\UnexpectedType};
  \item $\subtys$ is the list of types $\vt_{1..k}$;
  \item annotating the left-hand-side expression $\ve_i$ with the type $\vt_i$, for $i=1..k$, yields $(\vep_i, \vxs_i)$\ProseOrTypeError;
  \item the list of expressions $\lesp$ is $\vep_i$, for $i=1..k$;
  \item $\newle$ is the list of left-hand-side expressions $\lesp$, that is, $\LEDestructuring(\lesp)$;
  \item define $\vses$ as the union of all sets $\vxs_i$, for $i=1..k$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \les \eqname [\ve_{1..k}]\\
  \checktrans{\astlabel(\vte) = \TTuple}{\UnexpectedType} \checktransarrow \True \OrTypeError\\\\
  \vte \eqname \TTuple(\tys)\\
  \equallength(\les, \tys) \typearrow \vb\\
  \checktrans{\vb}{\UnexpectedType} \checktransarrow \True \OrTypeError\\\\
  \tys \eqname [\vt_{1..k}]\\
  i=1..k: \annotatelexpr{\tenv, \ve_i,\vt_i} \typearrow (\vep_i, \vxs_i) \OrTypeError\\\\
  \lesp \eqname [i=1..k: \vep_i]\\
  \vses \eqdef \bigcup_{i=1..k}  \vxs_i
}{
  \annotatelexpr{\tenv, \overname{\LEDestructuring(\les)}{\vle}, \vte} \typearrow
  (\overname{\LEDestructuring(\lesp)}{\newle}, \vses)
}
\end{mathpar}
\CodeSubsection{\LEDestructuringBegin}{\LEDestructuringEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{LEDestructuring}
\ExampleDef{Multi-variable Assignments}
In \listingref{semantics-ledestructuring}, the assignment \texttt{(x, y) = (3, 42)} binds
\texttt{x} to $\nvint(3)$ and \texttt{y} to
$\nvint(42)$ in the environment where \texttt{x} is bound to $\nvint(42)$ and
\texttt{y} is bound to $\nvint(3)$.
\ASLListing{Assignment to multiple left-hand-side expressions}{semantics-ledestructuring}{\semanticstests/SemanticsRule.LEDestructuring.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes a list of left-hand-side expressions, $\LEDestructuring(\vlelist)$;
  \item $\vlelist$ is the list of expressions $\vle_{1..n}$;
  \item getting the values from the native vector $\vv$ at each index $i=1..n$
  results in $\vv_{i=1..n}$;
  \item $\nmonads$ is the list of pairs consisting of $\vv_i$ and $\vg$ for $i=1..n$;
  \item evaluating the multi-assignment between $\vlelist$ and the list $\nmonads$
  in $\env$ achieves the effects of assigning each value to the respective
  subexpressions, resulting in the output configuration $C$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \vlelist \eqname [\vle_{1..n}]\\
  i=1..n: \getindex(i, \vv) \evalarrow \vv_i\\
  \nmonads \eqdef [i=1..n: (\vv_i, \vg)]\\
  \evalmultiassignment(\env, \vlelist, \nmonads) \evalarrow C
}{
  \evallexpr{\env, \LEDestructuring(\vlelist), (\vv, \vg)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalLEDestructuringBegin}{\EvalLEDestructuringEnd}{../Interpreter.ml}

\SemanticsRuleDef{LEMultiAssign}
The helper relation
\hypertarget{def-evalmultiassign}{}
\[
  \evalmultiassignment(\overname{\envs}{\env} \aslsep \overname{\expr^*}{\vlelist} \aslsep \overname{(\vals \times \XGraphs)^*}{\vmlist}) \;\aslrel\;
  \Normal(\overname{\XGraphs}{\newg} \aslsep \overname{\envs}{\newenv}) \cup
  \overname{\TThrowing}{\ThrowingConfig} \cup \overname{\TDynError}{\DynErrorConfig}
\]
evaluates multi-assignments.
That is, the simultaneous assignment of the list of value-execution graph pairs $\vmlist$
to the corresponding list of left-hand side expressions $\vlelist$, in the environment $\env$.
The result is either the execution graph $\vg$ and new environment $\newenv$ or an abnormal configuration.

\ProseParagraph
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item both $\vlelist$ and $\vmlist$ are empty lists;
    \item \Proseeqdef{$\newg$}{the empth \executiongraph};
    \item \Proseeqdef{$\newenv$}{$\env$}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vle$ is a \Proselist{$\vle$}{$\vlelistone$};
    \item $\vmlist$ is a \Proselist{$\vm$}{$\vmlistone$};
    \item \Proseevallexpr{$\env$}{$\vle$}{$\vm$}{$\Normal(\envone, \vgone)$}\ProseOrAbnormal;
    \item applying $\evalmultiassignment$ to $\envone$, $\vlelistone$, and $\vmlistone$
          yields \\
          $\Normal(\newenv, \vgtwo)$\ProseOrAbnormal;
    \item \Proseeqdef{$\newg$}{the ordered composition of $\vgone$ and $\vgtwo$
          with the edge $\aslpo$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}
{
  \evalmultiassignment(\env, \overname{\emptylist}{\vlelist}, \overname{\emptylist}{\vmlist}) \evalarrow
  \Normal(\overname{\emptygraph}{\newg}, \overname{\env}{\newenv})
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \vlelist \eqname [\vle] \concat \vlelistone\\
  \vmlist \eqname [\vm] \concat \vmlistone\\
  \evallexpr{\env, \vle, \vm} \evalarrow \Normal(\envone, \vgone) \OrAbnormal\\\\
  \evalmultiassignment(\envone, \vlelistone, \vmlistone) \evalarrow \Normal(\newenv, \vgtwo) \OrAbnormal\\\\
  \newg \eqdef \ordered{\vgone}{\aslpo}{\vgtwo}
}{
  \evalmultiassignment(\env, \vlelist, \vmlist) \evalarrow \Normal(\newg, \newenv)
}
\end{mathpar}
Notice that this rule is only defined when the lists $\vlelist$ and $\vmlist$ have the same length.
To see this, notice that
to form a derivation tree, we must employ the \textsc{nonempty} case, which ensures both lists
have at least one element and shortens the lengths of both lists by one,
until both lists become empty
which is when the \textsc{empty} axiom case is used.

\hypertarget{def-setarraylexprterm}{}
\section{Array Assignment Expressions\label{sec:ArrayAssignmentExpressions}}
This section details the syntax, abstract syntax, semantics, and typing of array write expressions.
In the untyped AST, a write to either an integer-indexed array or an enumeration-indexed array is represented
the same way. They type system infers the kind of array and outputs a typed AST node differentiating
the two kinds of arrays, either a $\LESetArray$ or a $\LESetEnumArray$, via \TypingRuleRef{LESetArray}.
The semantics utilizes a rule matching the corresponding type of array ---
\SemanticsRuleRef{LESetArray} for integer-indexed arrays and
\SemanticsRuleRef{LESetEnumArray} for enumeration-indexed arrays.

\subsection{Abstract Syntax}
\begin{flalign*}
\lexpr \derives\ & \LESetArray(\lexpr, \expr) &\\
|\ & \LESetEnumArray(\overtext{\lexpr}{base}, \overtext{\expr}{index}) &\\
\end{flalign*}

\subsection{Typing}
\TypingRuleDef{LESetArray}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes the array access of a left-hand-side expression $\ebase$ by the index $\eindex$, that is, $\LESetArray(\ebase, \eindex)$;
  \item annotating the right-hand-side expression corresponding to $\ebase$ in $\tenv$ yields \\ $(\tbase, \Ignore, \Ignore)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\tbase$ in $\tenv$ yields $\tanonbase$\ProseOrTypeError;
  \item checking that $\tanonbase$ is an array type yields $\True$\ProseOrTypeError;
  \item view $\tanonbase$ as an array type of size $\size$ and element type $\telem$, that is, $\TArray(\size, \telem)$;
  \item annotating the left-hand-side expression $\ebase$ with type $\tbase$ in $\tenv$ yields $(\ebasep, \vsesbase)$\ProseOrTypeError;
  \item applying $\annotatesetarray$ to $(\size, \telem)$, $\vte$, and \\
        $(\ebasep, \vsesbase, \eindex)$ in $\tenv$ yields $(\newle, \vses)$\ProseOrTypeError.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\ebase)} \typearrow (\tbase, \Ignore, \Ignore) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbase) \typearrow \tanonbase \OrTypeError\\\\
  \checktrans{\astlabel(\tanonbase) = \TArray}{ExpectedArrayType} \typearrow \True \OrTypeError\\\\
  \tanonbase \eqname \TArray(\size, \telem)\\
  \annotatelexpr{\tenv, \ebase, \tbase} \typearrow (\ebasep, \vsesbase) \OrTypeError\\\\
  {
  \begin{array}{r}
    \annotatesetarray(\tenv, (\size, \telem), \vte, (\ebasep, \vsesbase, \eindex)) \typearrow \\
    (\newle, \vses) \OrTypeError
  \end{array}
  }
}{
  \annotatelexpr{\tenv, \overname{\LESetArray(\ebase, \eindex)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}
\CodeSubsection{\LESetArrayBegin}{\LESetArrayEnd}{../Typing.ml}

\TypingRuleDef{AnnotateSetArray}
\hypertarget{def-annotatesetarray}{}
The helper function
\[
\annotatesetarray\left(
  \begin{array}{c}
    \overname{\staticenvs}{\tenv} \aslsep \\
  (\overname{\arrayindex}{\size} \times \overname{\ty}{\telem}) \aslsep \\
  \overname{\ty}{\rhsty} \aslsep \\
  (\overname{\expr}{\ebase} \times \overname{\TSideEffectSet}{\vsesbase} \times \overname{\expr}{\eindex})
\end{array}
\right)
\aslto
(\overname{\lexpr}{\newle} \times \overname{\TSideEffectSet}{\vses})
\]
annotates an array update in the static environment $\tenv$
where $\size$ is the array index,
$\telem$ is the type of array elements,
$\rhsty$ is the type of the right-hand-side expression,
$\ebase$ is the annotated expression for the array base,
$\vsesbase$ is the \sideeffectsetterm\ inferred for $\ebase$,
and $\eindex$ is the index expression.
The result is the annotated assignable expression $\newle$ and
\sideeffectsetterm\ for the annotated expression $\vses$.
\ProseOrTypeError

\ProseParagraph
\AllApply
\begin{itemize}
  \item determining that $\telem$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
  \item annotating the index expression $\eindex$ in $\tenv$ yields \\
        $(\tindexp, \eindexp, \vsesindex)$\ProseOrTypeError;
  \item determining the array length type of $\size$ (via $\typeofarraylength$) yields \\
        $\wantedtindex$;
  \item determining whether $\tindexp$ \typesatisfies\ $\wantedtindex$ in $\tenv$ yields \\
        $\True$\ProseOrTypeError;
  \item \Prosenonconflictingunion{$\vsesbase$ and $\vsesindex$}{$\vses$};
  \item \Proseeqdef{$\newle$}{
    an integer-based array update for $\ebasep$ at index $\eindexp$, that is, $\LESetArray(\ebasep, \eindexp)$,
    if $\size$ is an integer-typed array index, and
    an enumeration-based array update for $\ebasep$ at index $\eindexp$, that is, \\ $\LESetEnumArray(\ebasep, \eindexp)$,
    if $\size$ is an enumeration-typed array index.
    }
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \checktypesat(\tenv, \rhsty, \telem) \typearrow \True \OrTypeError\\\\
  \annotateexpr{\tenv, \eindex} \typearrow (\tindexp, \eindexp, \vsesindex) \OrTypeError\\\\
  \typeofarraylength(\tenv, \size) \typearrow \wantedtindex\\
  \checktypesat(\tenv, \tindexp, \wantedtindex) \typearrow \True \OrTypeError\\\\
  \nonconflictingunion(\vsesbase, \vsesindex) \typearrow \vses \OrTypeError\\\\
  \newleint \eqdef \LESetArray(\ebasep, \eindexp)\\
  \newleenum \eqdef \LESetEnumArray(\ebasep, \eindexp)\\
  {
  \newle \eqdef \begin{cases}
    \newleint & \text{if }\astlabel(\size) = \ArrayLengthExpr\\
    \newleenum & \text{if }\astlabel(\size) = \ArrayLengthEnum\\
  \end{cases}
  }
}{
  {
  \begin{array}{r}
    \annotatesetarray(\tenv, (\size, \telem), \rhsty, (\ebase, \vsesbase, \eindex)) \typearrow \\
    (\newle, \vses)
  \end{array}
  }
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{LESetArray}
\ExampleDef{Array Update Assignments}
In \listingref{semantics-lesetarray}, the assignment \verb|my_array[[3]] = 53;| binds the third element
of \\
\texttt{my\_array} to the value \texttt{53}.
\ASLListing{Assignment to an array cell}{semantics-lesetarray}{\semanticstests/SemanticsRule.LESetArray.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes an array update expression, $\LESetArray(\rearray, \eindex)$;
  \item evaluating the right-hand-side expression corresponding to $\rearray$ in $\env$
  is \Normal(\rmarray, \envone)\ProseOrAbnormal;
  \item evaluating $\eindex$ in $\envone$ is \Normal(\mindex, \envtwo)\ProseOrAbnormal;
  \item $\mindex$ consists of the native integer $\vindex$ and the execution graph $\vgone$;
  \item $\vindex$ is the native integer for $\vi$;
  \item $\rmarray$ consists of the native vector $\rvarray$ and the execution graph $\vgtwo$;
  \item setting the value $\vv$ at index $\vi$ of $\rvarray$ is the native vector $\vvone$;
  \item $\vmone$ is the pair consisting of $\vvone$ and the parallel composition of $\vgone$ and $\vgtwo$;
  \item the steps so far computed the updated array, but have not assigned it to the variable
  bound to the array given by $\rearray$, which is achieved next.
  Evaluating the left-hand-side expression $\rearray$ in an environment $\envtwo$ with $\vmone$
  is the output configuration $C$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \torexpr(\rearray)} \evalarrow \Normal(\rmarray, \envone) \OrAbnormal\\
  \evalexpr{\envone, \eindex} \evalarrow \Normal(\mindex, \envtwo) \OrAbnormal\\
  \mindex \eqname (\vindex, \vgone)\\
  \vindex \eqname \nvint(\vi)\\
  \rmarray \eqname (\rvarray, \vgtwo)\\
  \setindex(\vi, \vv, \rvarray) \evalarrow \vvone\\
  \vmone \eqdef (\vvone, \vgone \parallelcomp \vgtwo)\\
  \evallexpr{\envtwo, \rearray, \vmone} \evalarrow C
}{
  \evallexpr{\env, \LESetArray(\rearray, \eindex), (\vv, \vg)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalLESetArrayBegin}{\EvalLESetArrayEnd}{../Interpreter.ml}

\subsubsection{Comments}
\identr{WHRS}
If the declared type of the \rhsexpression\ of a setter has the structure of a
bitvector or a type with fields, then if a bitslice or field selection is
applied to a setter invocation, then the assignment to that bitslice is
implemented using the following Read-Modify-Write (RMW) behavior:
\begin{itemize}
\item invoking the getter of the same name as the setter, with the same actual
arguments as the setter invocation
\item performing the assignment to the bitslice or field of the result of the
getter invocation
\item invoking the setter to assign the resulting value
\end{itemize}

We note that the index is guaranteed by the typechecker to be within the array bounds
via \TypingRuleRef{LESetArray}.

\SemanticsRuleDef{LESetEnumArray}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes an array update expression, $\LESetEnumArray(\rearray, \eindex)$;
  \item evaluating the right-hand-side expression corresponding to $\rearray$ in $\env$
  is \Normal(\rmarray, \envone)\ProseOrAbnormal;
  \item evaluating $\eindex$ in $\envone$ is \Normal(\mindex, \envtwo)\ProseOrAbnormal;
  \item $\mindex$ consists of the native value $\vindex$ and the execution graph $\vgone$;
  \item $\vindex$ is the native label for $\vl$;
  \item $\rmarray$ consists of the native value $\rvarray$ and the execution graph $\vgtwo$;
  \item setting the value $\vv$ of field $\vl$ of $\rvarray$ is the native record $\vvone$;
  \item $\vmone$ is the pair consisting of $\vvone$ and the parallel composition of $\vgone$ and $\vgtwo$;
  \item the steps so far computed the updated array, but have not assigned it to the variable
  bound to the array given by $\rearray$, which is achieved next.
  Evaluating the left-hand-side expression $\rearray$ in an environment $\envtwo$ with $\vmone$
  is the output configuration $C$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \torexpr(\rearray)} \evalarrow \Normal(\rmarray, \envone) \OrAbnormal\\
  \evalexpr{\envone, \eindex} \evalarrow \Normal(\mindex, \envtwo) \OrAbnormal\\
  \mindex \eqname (\vindex, \vgone)\\
  \vindex \eqname \nvlabel(\vl)\\
  \rmarray \eqname (\rvarray, \vgtwo)\\
  \setfield(\vl, \vv, \rvarray) \evalarrow \vvone\\
  \vmone \eqdef (\vvone, \vgone \parallelcomp \vgtwo)\\
  \evallexpr{\envtwo, \rearray, \vmone} \evalarrow C
}{
  \evallexpr{\env, \LESetEnumArray(\rearray, \eindex), (\vv, \vg)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalLESetEnumArrayBegin}{\EvalLESetEnumArrayEnd}{../Interpreter.ml}

\hypertarget{def-slicelexprterm}{}
\section{Bitvector Slice Assignment Expressions\label{sec:BitvectorSliceAssignmentExpressions}}
\subsection{Abstract Syntax}
\begin{flalign*}
\lexpr \derives\ & \LESlice(\lexpr, \slice^*) &
\end{flalign*}

\subsection{Typing}
\TypingRuleDef{LESlice}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes the slicing of a left-hand-side expression $\vleone$ by the slices $\slices$, that is, $\LESlice(\vleone, \slices)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\
        $(\vtleone, \Ignore, \Ignore)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vtleone$ in $\tenv$ yields $\tleoneanon$\ProseOrTypeError;
  \item checking that $\tleoneanon$ is a bitvector type yields $\True$\ProseTerminateAs{\UnexpectedType};
  \item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $(\vletwo, \vsesone)$\ProseOrTypeError;
  \item obtaining the width of the slices $\slices$ in $\tenv$ and simplifying them yields $\vwidth$;
  \item $\vt$ is the bitvector type of width $\width$ and empty list of bitfields;
  \item checking whether $\vte$ \typesatisfies\ $\vt$ yields $\True$\ProseOrTypeError;
  \item annotating $\slices$ in $\tenv$ yields $(\slicestwo, \vsestwo)$\ProseOrTypeError;
  \item checking that the slices $\slicestwo$ are all disjoint yields $\True$\ProseOrTypeError;
  \item checking that $\slices$ is not empty yields $\True$\ProseTerminateAs{\BadSlices};
  \item $\newle$ is the slicing of $\vletwo$ by $\slicestwo$, that is, $\LESlice(\vletwo, \slicestwo)$;
  \item \Prosenonconflictingunion{$\vsesone$ and $\vsestwo$}{$\vses$}.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore, \Ignore) \OrTypeError\\\\
  \makeanonymous(\tenv, \vtleone) \typearrow \tleoneanon \OrTypeError\\\\
  \checktrans{\astlabel(\tleoneanon) = \TBits}{\UnexpectedType} \typearrow \True \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow (\vletwo, \vsesone) \OrTypeError\\
  \sliceswidth(\tenv, \slices) \typearrow \widthp\\
  \normalize(\tenv, \widthp) \typearrow \vwidth\\
  \vt \eqdef \TBits(\vwidth, \emptylist)\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \annotateslices(\tenv, \slices) \typearrow (\slicestwo, \vsestwo) \OrTypeError\\\\
  \checkdisjointslices(\tenv, \slicestwo) \typearrow \True \OrTypeError\\\\
  \checktrans{\slices \neq \emptylist}{\BadSlices} \typearrow \True \OrTypeError\\\\
  \newle \eqdef \LESlice(\vletwo, \slicestwo)\\
  \nonconflictingunion([\vsesone, \vsestwo]) \typearrow \vses \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESlice(\vleone, \slices)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}
\CodeSubsection{\LESliceBegin}{\LESliceEnd}{../Typing.ml}

\TypingRuleDef{CheckDisjointSlices}
\hypertarget{def-checkdisjointslices}{}
The function
\[
\checkdisjointslices(\overname{\staticenvs}{\tenv} \aslsep \overname{\slice^*}{\slices})
\aslto \True \cup \overname{\TTypeError}{\TypeErrorConfig}
\]
tests whether the list of slices $\slices$ do not overlap in $\tenv$, yielding $\True$.
\ProseOtherwiseTypeError

\ProseParagraph
\AllApply
\begin{itemize}
  \item applying $\disjointslicestopositions$ to $\slices$ in $\tenv$ yields a set of positions\ProseOrTypeError.
  \item the result is $\True$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \disjointslicestopositions(\tenv, \slices) \typearrow \positions \OrTypeError
}{
  \checkdisjointslices(\tenv, \slices) \typearrow \True
}
\end{mathpar}
\CodeSubsection{\CheckDisjointSlicesBegin}{\CheckDisjointSlicesEnd}{../Typing.ml}

\subsection{Semantics}
\SemanticsRuleDef{LESlice}
\ExampleDef{Slice Assignments}
In \listingref{semantics-leslice}, the assignment \texttt{x[3:0] = '0000'} binds
\texttt{x} to $\nvbitvector(11110000)$
via the rule \SemanticsRuleRef{LESlice}
in the environment where \texttt{x} is bound to $\nvbitvector(11111111)$.

\ASLListing{Assignment to a slice}{semantics-leslice}{\semanticstests/SemanticsRule.LESlice.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes a left-hand-side slicing expression, $\LESlice(\ebv, \slices)$;
  \item evaluating the right-hand-side expression that corresponds to $\ebv$
  (given by applying $\torexpr$ to $\ebv$) in $\env$
    is $\Normal(\mbv,\envone)$\ProseOrAbnormal;
  \item evaluating $\slices$ in $\envone$ is $\Normal(\msliceranges, \envtwo)$\ProseOrAbnormal;
  \item $\msliceranges$ consists of the execution graph $\vgone$ and the list of indices\\
         $\sliceranges$;
  \item applying $\checknonoverlappingslices$ to $\sliceranges$ yields $\True$\ProseOrError;
  \item $\mbv$ consists of the native bitvector $\vbv$ and the execution graph $\vgtwo$;
  \item writing to the bitvector $\vbv$ at indices $\sliceranges$ using the values from $\vv$
  results in the updated native bitvector $\vvone$\ProseOrError;
  \item $\vgthree$ is the parallel composition of $\vgone$, and $\vgtwo$;
  \item $\newmbv$ is a pair consisting of $\vvone$ and the execution graph $\vgthree$;
  \item the steps so far computed the updated bitvector, but have not assigned it to the
  variable bound to the bitvector given by $\ebv$, which is achieved next.
  Evaluating the left-hand-side expression $\ebv$ with
  $\newmbv$ in an environment $\envtwo$ is the output configuration $C$,
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \torexpr(\ebv)} \evalarrow \Normal(\mbv,\envone) \OrAbnormal\\
  \evalslices(\envone, \slices) \evalarrow \Normal(\msliceranges, \envtwo) \OrAbnormal\\
  \msliceranges \eqname (\sliceranges, \vgone)\\
  \mbv \eqname (\vbv, \vgtwo)\\\\
  \checknonoverlappingslices(\sliceranges) \evalarrow \True \OrDynError\\\\
  \writetobitvector(\sliceranges, \vv, \vbv) \evalarrow \vvone \OrDynError\\\\
  \vgthree \eqdef \vgone \parallelcomp \vgtwo\\
  \newmbv \eqdef (\vvone, \vgthree)\\
  \evallexpr{\envtwo, \ebv, \newmbv} \evalarrow C
}{
  \evallexpr{\envtwo, \LESlice(\ebv, \slices), (\vv, \vg)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalLESliceBegin}{\EvalLESliceEnd}{../Interpreter.ml}
\subsubsection{Comments}
\identr{WHRS}

If the declared type of the \rhsexpression\ of a setter has the structure of a
bitvector or a type with fields, then if a bitslice or field selection is
applied to a setter invocation, then the assignment to that bitslice is
implemented using the following Read-Modify-Write (RMW) behavior:
\begin{itemize}
\item invoking the getter of the same name as the setter, with the same actual
arguments as the setter invocation
\item performing the assignment to the bitslice or field of the result of the
getter invocation
\item invoking the setter to assign the resulting value
\end{itemize}

\SemanticsRuleDef{CheckNonOverlappingSlices}
\hypertarget{def-checknonoverlappingslices}{}
The helper function
\[
  \checknonoverlappingslices(
    \overname{(\tint\times\tint)^*}{\valueranges}
  ) \evalarrow \{\True\} \cup \overname{\TDynError}{\DynErrorConfig}
\]
checks whether the sets of integers represented by the list of ranges $\valueranges$
overlap, yielding $\True$.
\ProseOrError

\ProseParagraph
\AllApply
\begin{itemize}
  \item view $\valueranges$ as the list $\vrange_{1..k}$;
  \item for every pair of indices $\vi$ and $\vj$ such that $1 \leq \vi < \vj \leq k$,
        applying \\
        $\checktworangesnonoverlapping$ to $\vrange_\vi$ and $\vrange_\vj$
        yields $\True$\ProseOrError;
  \item the result is $\True$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  {
    \begin{array}{r}
 1 \leq \vi < \vj \leq k:
 \checktworangesnonoverlapping(\vrange_\vi, \vrange_\vj) \evalarrow \\
 \True \OrDynError
    \end{array}
  }
}{
  \checknonoverlappingslices(\overname{\vrange_{1,,k}}{\valueranges}) \evalarrow \True
}
\end{mathpar}

\SemanticsRuleDef{CheckTwoRangesNonOverlapping}
\hypertarget{def-checktworangesnonoverlapping}{}
The helper function
\[
\begin{array}{r}
  \checktworangesnonoverlapping(
    (\overname{\tint}{\vsone}\times\overname{\tint}{\vlone}) \aslsep
    (\overname{\tint}{\vstwo}\times\overname{\tint}{\vltwo}) \aslsep
  ) \evalarrow \\
  \{\True\} \cup \overname{\TDynError}{\DynErrorConfig}
\end{array}
\]
checks whether two sets of integers represented by the
ranges $(\vsone, \vlone)$ and $(\vstwo, \vltwo)$ do not intersect, yielding $\True$.
\ProseOrError

\ProseParagraph
\AllApply
\begin{itemize}
  \item evaluating $\PLUS$ for $\vsone$ and $\vlone$ via $\binoprel$ yields $\vsonelone$;
  \item evaluating $\LEQ$ for $\vsonelone$ and $\vstwo$ yields $\vsonelonestwo$;
  \item evaluating $\PLUS$ for $\vstwo$ and $\vltwo$ yields $\vstwoltwo$;
  \item evaluating $\LEQ$ for $\vstwoltwo$ and $\vsone$ yields $\vstwoltwosone$;
  \item evaluating $\BOR$ for $\vsonelonestwo$ and $\vstwoltwosone$ yields $\nvbool(\vb)$;
  \item checking whether $\vb$ is $\True$ yields $\True$\ProseTerminateAs{\OverlappingSliceAssignment};
  \item the result is $\True$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \binoprel(\PLUS, \vsone, \vlone) \evalarrow \vsonelone\\
  \binoprel(\LEQ, \vsonelone, \vstwo) \evalarrow \vsonelonestwo\\
  \binoprel(\PLUS, \vstwo, \vltwo) \evalarrow \vstwoltwo\\
  \binoprel(\LEQ, \vstwoltwo, \vsone) \evalarrow \vstwoltwosone\\
  \binoprel(\BOR, \vsonelonestwo, \vstwoltwosone) \evalarrow \nvbool(\vb)\\
  \checktrans{\vb}{\OverlappingSliceAssignment} \checktransarrow \True\OrDynError
}{
  \checktworangesnonoverlapping((\vsone, \vlone), (\vstwo, \vltwo)) \evalarrow \True
}
\end{mathpar}

\hypertarget{def-setfieldlexprterm}{}
\section{Structured Type Field Assignment Expressions\label{sec:StructuredTypeFieldAssignmentExpressions}}
\subsection{Abstract Syntax}
\begin{flalign*}
\lexpr \derives\ & \LESetField(\lexpr, \identifier) &
\end{flalign*}

\subsection{Typing}
\TypingRuleDef{LESetBadField}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes the access to the field named $\field$ in $\vleone$, that is, \\ $\LESetField(\vleone, \field)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore, \Ignore)$\ProseOrTypeError;
  \item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $(\vletwo, \vses)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vtleone$ in $\tenv$ yields a type $\tleoneanon$\ProseOrTypeError;
  \item $\vt$ is neither a \structuredtype\ nor a bitvector type;
  \item the result is an error indicating that the type of $\vle$ conflicts with the requirements of a field access expression.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow (\vletwo, \vses) \OrTypeError\\\\
  \makeanonymous(\tenv, \vtleone) \typearrow \tleoneanon \OrTypeError\\\\
  \astlabel(\tleoneanon) \not\in \{\TException, \TRecord, \TBits\}
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \TypeErrorVal{\UnexpectedType}
}
\end{mathpar}
\CodeSubsection{\LESetBadFieldBegin}{\LESetBadFieldEnd}{../Typing.ml}

\TypingRuleDef{LESetStructuredField}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes the access to the field named \texttt{field} in $\vleone$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore, \Ignore)$\ProseOrTypeError;
  \item annotating the left-hand-side expression  $\vleone$ with type $\vtleone$ in $\tenv$ yields \\ $(\vletwo, \vses)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vtleone$ in $\tenv$ yields a \structuredtype\ with fields \\
        $\fields$\ProseOrTypeError;
  \item checking that there exists a type associated with the field $\field$ in $\fields$ $\True$ \ProseTerminateAs{\BadField};
  \item the type associated with the field $\field$ in $\fields$ is $\vt$;
  \item determining whether $\vte$ \typesatisfies\ $\vt$ yields $\True$\ProseOrTypeError;
  \item $\newle$ is the access to the field $\field$ in $\vletwo$, that is, $\LESetField(\vletwo, \field)$.
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow (\vletwo, \vses) \OrTypeError\\\\
  \makeanonymous(\tenv, \vtleone) \typearrow L(\fields) \OrTypeError\\\\
  L \in \{\TException, \TRecord\}\\
  \assocopt(\fields, \field) \typearrow \tyopt\\
  \checktrans{\tyopt \neq \None}{\BadField} \checktransarrow \True \OrTypeError\\\\
  \tyopt \eqname \langle\vt\rangle\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \newle \eqdef \LESetField(\vletwo, \field)
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}
\CodeSubsection{\LESetStructuredFieldBegin}{\LESetStructuredFieldEnd}{../Typing.ml}

\hypertarget{def-setfieldslexprterm}{}
\section{Structured Type Multi-field Assignment Expressions\label{sec:StructuredTypeMultiFieldAssignmentExpressions}}
\subsection{Abstract Syntax}
\begin{flalign*}
\lexpr \derives\ & \LESetFields(\lexpr, \identifier^*) &
\end{flalign*}

\subsection{Typing}
\TypingRuleDef{LESetFields}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ is an assignable expression for assigning the list of fields $\vlefields$ of the base
        expression $\lebase$;
  \item \Proseannotateexpr{$\tenv$}{the right-hand side expression corresponding to \\ $\lebaseannot$}{$(\tbase, \Ignore, \Ignore)$}\ProseOrTypeError;
  \item \Proseannotatelexpr{$\tenv$}{$\lebase$}{$\tbase$}{$(\lebaseannot, \vsesbase)$}\ProseOrTypeError;
  \item \Prosemakeanonymous{$\tenv$}{$\tbase$}{\\ $\tbaseanon$}\ProseOrTypeError;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{bits}
    \begin{itemize}
      \item $\tanonbase$ is a bitvector type with list of bitfields $\vbitfields$;
      \item applying $\findbitfieldsslices$ to $\name$ and $\vbitfields$, for every $\name$ in $\vlefields$, yields $\vslices_\name$\ProseOrTypeError;
      \item define $\vleslice$ as the \ProseLESlice\ for the base expression $\lebaseannot$ and list of slices formed by concatenating all
            slice lists $\vslices_\name$, for every $\name$ in $\vlefields$;
      \item \Proseannotatelexpr{$\tenv$}{$\vleslice$}{$\vte$}{$(\newle, \vses)$}\ProseOrTypeError.
    \end{itemize}

    \item \AllApplyCase{record}
    \begin{itemize}
      \item $\tanonbase$ is a record type with list of fields $\vbasefields$;
      \item applying $\foldbitvectorfields$ to $\vlefields$ and $\vbasefields$ in $\tenv$ yields $(\vlength, \vslices)$ \ProseOrTypeError;
      \item \Proseeqdef{$\vtlhs$}{the bitvector type of length $\vlength$ and no bitfields, that is, $\TBits(\ELInt{\vlength}, \emptylist)$};
      \item checking that $\vte$ \typesatisfies\ $\vtlhs$ in $\tenv$ yields $\True$\ProseOrTypeError;
      \item define $\newle$ as the assignable expression of the list of fields $\vlefields$ to the base expression $\lebase$, that is,
            $\LESetFields(\lebase, \vlefields)$;
      \item \Proseeqdef{$\vses$}{$\vsesbase$}.
    \end{itemize}

    \item \AllApplyCase{error}
    \begin{itemize}
      \item $\tanonbase$ is neither a bitvector type nor a record type;
      \item the result is a type error indicating that the type of the left-hand-side expression is expected to be
            either a bitvector type or a record type.
    \end{itemize}
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[bits]{
  \annotateexpr{\tenv, \torexpr(\lebase)} \typearrow (\tbase, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \lebase, \tbase} \typearrow (\lebaseannot, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbase) \typearrow \tbaseanon \OrTypeError\\\\
  \commonprefixline\\\\
  \tbaseanon = \TBits(\Ignore, \vbitfields)\\
  \name\in\vlefields: \findbitfieldsslices(\name, \vbitfields) \typearrow \vslices_\name \OrTypeError\\\\
  \vleslice \eqdef \LESlice(\lebaseannot, [\name\in\vlefields: \vslices_\name])\\
  \annotatelexpr{\tenv, \vleslice, \vte} \typearrow (\newle, \vses) \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESetFields(\lebase, \vlefields)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}

\begin{mathpar}
  \inferrule[record]{
  \annotateexpr{\tenv, \torexpr(\lebase)} \typearrow (\tbase, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \lebase, \tbase} \typearrow (\lebaseannot, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbase) \typearrow \tbaseanon \OrTypeError\\\\
  \commonprefixline\\\\
  \tbaseanon = \TRecord(\vbasefields)\\
  \foldbitvectorfields(\tenv, \vbasefields, \vlefields) \typearrow (\vlength, \vslices) \OrTypeError\\\\
  \vtlhs \eqdef \TBits(\ELInt{\vlength}, \emptylist)\\
  \checktypesat(\tenv, \vte, \vtlhs) \typearrow \True \OrTypeError
}{
  {
   \begin{array}{r}
    \annotatelexpr{\tenv, \overname{\LESetFields(\lebase, \vlefields)}{\vle}, \vte} \typearrow\\
    (\overname{\LESetFields(\lebaseannot, \vlefields, \vslices)}{\newle}, \overname{\vsesbase}{\vses})
  \end{array}
  }
}
\end{mathpar}

\begin{mathpar}
  \inferrule[error]{
  \annotateexpr{\tenv, \torexpr(\lebase)} \typearrow (\tbase, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \lebase, \tbase} \typearrow (\lebaseannot, \vsesbase) \OrTypeError\\\\
  \makeanonymous(\tenv, \tbase) \typearrow \tbaseanon \OrTypeError\\\\
  \commonprefixline\\\\
  \checktrans{\astlabel(\tbaseanon) \not\in \{\TBits, \TRecord\}}{\UnexpectedType} \typearrow \True \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESetFields(\lebase, \vlefields)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}
\CodeSubsection{\LESetFieldsBegin}{\LESetFieldsEnd}{../Typing.ml}

\TypingRuleDef{FoldBitvectorFields}
\hypertarget{def-foldbitvectorfields}{}
The helper function
\[
\foldbitvectorfields(\overname{\staticenvs}{\tenv} \aslsep \overname{\Field^*}{\vbasefields} \aslsep \overname{\bitfield^*}{\vlefields})
\aslto (\overname{\N}\vlength \times \overname{(\N \times N)^*}{\vslices})
\]

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\vlefields$ is empty;
    \item \Proseeqdef{$\vlength$}{$0$};
    \item \Proseeqdef{$\vslices$}{the empty list}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\vlefields$ is the list with prefix $\vlefieldsone$ (the elements excluding the last one) and last element $\vfield$;
    \item applying $\foldbitvectorfields$ to $\vbasefields$ and $\vlefieldsone$ in $\tenv$ yields $(\vstart, \vslicesone)$\ProseOrTypeError;
    \item applying $\assocopt$ to $\vfields$ and $\vbasefields$ yields $\tyopt$;
    \item checking that $\tyopt$ is different to $\None$ yields $\True$\ProseTerminateAs{\BadField};
    \item view $\tyopt$ as $\langle\vtfield\rangle$;
    \item applying $\getbitvectorconstwidth$ to $\vtfield$ in $\tenv$ yields $\vfieldwidth$\ProseOrTypeError;
    \item \Proseeqdef{$\vlength$}{$\vstart + \vfieldwidth$};
    \item \Proseeqdef{$\vslices$}{the list with \head\ $(\vstart, \vfieldwidth)$ and \tail\ $\vslicesone$}.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \foldbitvectorfields(\tenv, \vbasefields, \overname{\emptylist}{\vlefields}) \typearrow (\overname{0}{\vlength}, \overname{\emptylist}{\vslices})
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \foldbitvectorfields(\tenv, \vbasefields, \vlefieldsone) \typearrow (\vstart, \vslicesone)\OrTypeError\\\\
  \assocopt(\vfields, \vbasefields) \typearrow \tyopt\\
  \checktrans{\tyopt \neq \None}{\BadField} \typearrow \True \OrTypeError\\\\
  \tyoptp \eqname \langle\vtfield\rangle\\
  \getbitvectorconstwidth(\tenv, \vtfield) \typearrow \vfieldwidth \OrTypeError\\\\
}{
  {
  \begin{array}{r}
  \foldbitvectorfields(\tenv, \vbasefields, \overname{\vlefieldsone \concat [\vfield]}{\vlefields}) \typearrow\\
  (\overname{\vstart + \vfieldwidth}{\vlength}, \overname{[(\vstart, \vfieldwidth)] \concat \vslicesone}{\vslices})
  \end{array}
  }
}
\end{mathpar}

\subsection{Semantics}
\SemanticsRuleDef{LESetFields}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ is an expression for assigning each of the fields in $\fields$ of the record expression $\vlerecord$
        with the corresponding slices given in $\vslices$ from the bitvector value $\vv$
        (the rule \TypingRuleRef{LESetFields} ensures that the length of $\fields$ and $\vslices$ is the same);
  \item \Proseevalexpr{$\env$}{right-hand-side expression corresponding to $\vlerecord$}{$(\vrmrecord, \envone)$}\ProseOrAbnormal;
  \item \Proseeqdef{$\vm$}{$(\vv,\vg)$};
  \item applying $\assignbitvectorfields$ to $(\vv,\vg)$, $\vrmrecord$, $\fields$, and $\vslices$, yields \\
        $(\vmtwo, \envone)$\ProseOrError;
  \item view the \concurrentnativevalue\ $\vmtwo$ as the pair $(\vvtwo, \vgtwo)$;
  \item \Proseevallexpr{$\envone$}{$\vlerecord$}{the \concurrentnativevalue\ consisting of $\vvtwo$ and the parallel composition of $\vg$ and $\vgtwo$}{$C$}.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
  \evalexpr{\env, \torexpr(\vlerecord), \vrmrecordnew} \evalarrow (\vrmrecord, \envone) \OrAbnormal\\\\
  \vm \eqdef (\vv,\vg)\\
  \assignbitvectorfields(\vm, \vrmrecord, \fields, \vslices) \evalarrow (\vmtwo, \envone) \OrDynError\\\\
  \vmtwo \eqname (\vvtwo, \vgtwo)\\
  \evallexpr{\envone, \vlerecord, (\vvtwo, \vg \parallelcomp \vgtwo)} \evalarrow C
}{
  \evalexpr{\env, \overname{\LESetFields(\vlerecord, \fields, \vslices)}{\vle}, (\vv,\vg)} \evalarrow C
}
\end{mathpar}

\SemanticsRuleDef{AssignBitvectorFields}
\hypertarget{def-assignbitvectorfields}{}
The helper function
\[
  \assignbitvectorfields(
    \overname{(\trecord\times\XGraphs)}{\vm} \aslsep
    \overname{(\trecord\times\XGraphs)}{\vmone} \aslsep
    \overname{\identifier^*}{\fields} \aslsep
    \overname{(\N\times\N)^*}{\vslices}) \aslto
    \overname{(\trecord\times\XGraphs)}{\vmtwo}
\]
updates the list of fields $\fields$ of \concurrentnativevalue\ $\vmone$ with the
slices given by $\vslices$ of the \concurrentnativevalue\ $\vm$, yielding the
\concurrentnativevalue\ $\vmtwo$.

\ProseParagraph
\OneApplies
\begin{itemize}
  \item \AllApplyCase{empty}
  \begin{itemize}
    \item $\fields$ and $\vslices$ are both empty lists;
    \item \Proseeqdef{$\vmtwo$}{$\vmone$}.
  \end{itemize}

  \item \AllApplyCase{non\_empty}
  \begin{itemize}
    \item $\fields$ is a list with \head\ $\fieldname$ and \tail\ $\fieldsone$;
    \item $\vslices$ is a list with \head\ $(\vione, \vitwo)$ and \tail\ $\vslicesone$;
    \item \Proseeqdef{$\vslice$}{the singleton list comprised of the pair of native integer values for $\vione$ and $\vitwo$};
    \item view $\vm$ as $(\vv, \vg)$;
    \item view $\vmone$ as $(\rvrecord, \vgone)$;
    \item applying $\readfrombitvector$ to $\vv$ and $\vslice$ yields $\vvrecordslices$\ProseOrError;
    \item applying $\setfield$ to $\fieldname$, $\vvrecordslices$, and $\rvrecord$ yields \\ $\rvrecordone$;
    \item \Proseeqdef{the \concurrentnativevalue\ $\vrmrecordone$}{the pair consisting of the \nativevalue\ $\rvrecordone$
          and the \executiongraph, which is the parallel composition of $\vg$ and $\vgone$};
    \item applying $\assignbitvectorfields$ to $\vm$, $\vrmrecordone$, $\fieldsone$, and $\vslicesone$, yields $\vmtwo$\ProseOrError.
  \end{itemize}
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule[empty]{}{
  \assignbitvectorfields(\vm, \vmone, \overname{\emptylist}{\fields}, \overname{\emptylist}{\vslices}) \evalarrow
  \overname{\vmone}{\vmtwo}
}
\end{mathpar}

\begin{mathpar}
\inferrule[non\_empty]{
  \vslice \eqdef [(\nvint(\vione), \nvint(\vitwo))]\\
  \vm \eqname (\vv, \vg)\\
  \vmone \eqname (\rvrecord, \vgone)\\
  \readfrombitvector(\vv, \vslice) \evalarrow \vvrecordslices \OrDynError\\\\
  \setfield(\fieldname, \vvrecordslices, \rvrecord) \evalarrow \rvrecordone\\
  \vrmrecordone \eqdef (\rvrecordone, \vg \parallelcomp \vgone)\\
  \assignbitvectorfields(\vm, \vrmrecordone, \fieldsone, \vslicesone) \evalarrow \vmtwo \OrDynError
}{
  {
    \begin{array}{r}
  \assignbitvectorfields(
    \vm,
    \vmone,
    \overname{[\fieldname]\concat\fieldsone}{\fields},
    \overname{[(\vione, \vitwo)]\concat\vslicesone}{\vslices}) \evalarrow \\
    \vmtwo
    \end{array}
  }
}
\end{mathpar}

\section{Bitfield Assignment Expressions\label{sec:BitfieldAssignmentExpressions}}
\subsection{Abstract Syntax}
\begin{flalign*}
\lexpr \derives\ & \LESlice(\lexpr, \slice^*) &
\end{flalign*}

\subsection{Typing}
\TypingRuleDef{LESetBitField}
\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes the access to the field named $\field$ in $\vleone$, that is, \\ $\LESetField(\vleone, \field)$;
  \item annotating the right-hand-side expression corresponding to $\vleone$ in $\tenv$ yields \\ $(\vtleone, \Ignore, \Ignore)$\ProseOrTypeError;
  \item annotating the left-hand-side expression $\vleone$ in $\tenv$ yields $(\vletwo, \vses)$\ProseOrTypeError;
  \item obtaining the \underlyingtype\ of $\vtleone$ in $\tenv$ yields a bitvector type with bitfields $\bitfields$\ProseOrTypeError;
  \item \OneApplies
  \begin{itemize}
    \item \AllApplyCase{error\_missing\_field}
    \begin{itemize}
      \item applying $\findbitfieldopt$ to $\bitfields$ and $\vfield$ yields $\None$, meaning the field is not declared
            in $\vtleone$;
      \item the result is a type error $\BadField$.
    \end{itemize}

    \item \AllApplyCase{field\_simple}
    \begin{itemize}
      \item applying $\findbitfieldopt$ to $\bitfields$ and $\vfield$ yields a bitfield with corresponding slices $\slices$,
            that is, $\BitFieldSimple(\Ignore, \slices)$;
      \item $\vw$ is the width of $\slices$;
      \item $\vt$ is defined as the bitvector type of width $\vw$ and empty list of bitfields, that is, $\TBits(\vw, \emptylist)$;
      \item checking whether$\vte$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
      \item $\vletwo$ is defined as the slicing of $\vleone$ by $\slices$, that is, \\ $\LESlice(\vleone, \slices)$;
      \item annotating the left-hand-side expression $\vletwo$ in $\tenv$ yields \\ $(\newle, \vses)$\ProseOrTypeError.
    \end{itemize}

    \item \AllApplyCase{field\_nested}
    \begin{itemize}
      \item applying $\findbitfieldopt$ to $\bitfields$ and $\vfield$ yields a nested bitfield with corresponding
            slices $\slices$ and list of bitfields $\bitfieldsp$, that is, \\ $\BitFieldNested(\Ignore, \slices, \bitfieldsp)$;
      \item $\vw$ is the width of $\slices$;
      \item $\vt$ is defined as the bitvector type of width $\vw$ and list of bitfields $\bitfieldsp$, that is, $\TBits(\vw, \bitfieldsp)$;
      \item checking whether$\vte$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
      \item $\vlethree$ is defined as the slicing of $\vleone$ by $\slices$, that is, \\ $\LESlice(\vleone, \slices)$;
      \item annotating the left-hand-side expression $\vlethree$ in $\tenv$ yields \\ $(\newle, \vses)$\ProseOrTypeError.
    \end{itemize}

    \item \AllApplyCase{field\_typed}
    \begin{itemize}
      \item applying $\findbitfieldopt$ to $\bitfields$ and $\vfield$ yields a typed bitfield with corresponding
            slices $\slices$ and a type $\vt$, that is, \\ $\BitFieldType(\Ignore, \vslices, \vt)$;
      \item $\vw$ is the width of $\slices$;
      \item $\vtp$ is defined as the bitvector type of width $\vw$ and an empty list of bitfields, that is, $\TBits(\vw , \emptylist)$;
      \item checking whether $\vtp$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
      \item checking whether $\vte$ \typesatisfies\ $\vt$ in $\tenv$ yields $\True$\ProseOrTypeError;
      \item $\vletwo$ is defined as the slicing of $\vleone$ by $\slices$, that is, \\ $\LESlice(\vleone, \slices)$;
      \item annotating the left-hand-side expression $\vletwo$ in $\tenv$ yields \\ $(\newle, \vses)$\ProseOrTypeError.
    \end{itemize}
  \end{itemize}
\end{itemize}
\FormallyParagraph
\begin{mathpar}
\inferrule[error\_missing\_field]{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow (\vletwo, \vses) \OrTypeError\\\\
  \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields) \OrTypeError\\\\
  \commonprefixline\\\\
  \findbitfieldopt(\bitfields, \field) \typearrow \None\
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow \TypeErrorVal{\BadField}
}
\end{mathpar}

\begin{mathpar}
\inferrule[field\_simple]{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow (\vletwo, \vses) \OrTypeError\\\\
  \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields) \OrTypeError\\\\
  \commonprefixline\\\\
  \findbitfieldopt(\bitfields, \field) \typearrow \langle \BitFieldSimple(\Ignore, \slices) \rangle\\
  \sliceswidth(\tenv, \vslices) \typearrow \vw\\
  \vt \eqdef \TBits(\vw, \emptylist)\\\\
  \commonsuffixline\\\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \vletwo \eqdef \LESlice(\vleone, \slices)\\
  \annotatelexpr{\tenv, \vletwo, \vte} \typearrow (\newle, \vses) \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[field\_nested]{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow (\vletwo, \vses) \OrTypeError\\\\
  \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields) \OrTypeError\\\\
  \commonprefixline\\\\
  \findbitfieldopt(\bitfields, \field) \typearrow \langle \BitFieldNested(\Ignore, \slices, \bitfieldsp) \rangle\\
  \sliceswidth(\tenv, \vslices) \typearrow \vw\\
  \vt \eqdef \TBits(\vw, \bitfieldsp)\\\\
  \commonsuffixline\\\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \vletwo \eqdef \LESlice(\vleone, \slices)\\
  \annotatelexpr{\tenv, \vletwo, \vte} \typearrow (\newle, \vses) \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}

\begin{mathpar}
\inferrule[field\_typed]{
  \annotateexpr{\tenv, \torexpr(\vleone)} \typearrow (\vtleone, \Ignore, \Ignore) \OrTypeError\\\\
  \annotatelexpr{\tenv, \vleone, \vtleone} \typearrow (\vletwo, \vses) \OrTypeError\\\\
  \tstruct(\tenv, \vtleone) \typearrow \TBits(\Ignore, \bitfields) \OrTypeError\\\\
  \commonprefixline\\\\
  \findbitfieldopt(\bitfields, \field) \typearrow \langle \BitFieldType(\Ignore, \vslices, \vt) \rangle\\
  \sliceswidth(\tenv, \vslices) \typearrow \vw\\
  \vtp \eqdef \TBits(\vw , \emptylist)\\
  \checktypesat(\tenv, \vtp, \vt) \typearrow \True \OrTypeError\\\\
  \commonsuffixline\\\\
  \checktypesat(\tenv, \vte, \vt) \typearrow \True \OrTypeError\\\\
  \vletwo \eqdef \LESlice(\vleone, \slices)\\
  \annotatelexpr{\tenv, \vletwo, \vte} \typearrow (\newle, \vses) \OrTypeError
}{
  \annotatelexpr{\tenv, \overname{\LESetField(\vleone, \field)}{\vle}, \vte} \typearrow (\newle, \vses)
}
\end{mathpar}

\subsection{Semantics}
The semantics for assigning to individual bitvector bitfields is covered by \SemanticsRuleRef{LESlice}
as the type system transforms the \untypedast\ for assigning to an individual bitfield into an $\LESlice$ \typedast.

\SemanticsRuleDef{LESetField}

\ExampleDef{Field Assignment}
In \listingref{semantics-lesetfield}, the assignment
\verb|my\_record.a = 42;| binds \texttt{my\_record} to \texttt{\{a: 42, b: 100\}}
in the environment where \texttt{my\_record} is bound to \texttt{\{a: 3, b: 100\}}.

\ASLListing{Assignment to a field}{semantics-lesetfield}{\semanticstests/SemanticsRule.LESetField.asl}

\ProseParagraph
\AllApply
\begin{itemize}
  \item $\vle$ denotes a field update expression, $\LESetField(\rerecord, \fieldname)$;
  \item evaluating the right-hand-side expression corresponding to $\rerecord$
  in $\env$ is $\Normal(\rmrecord, \envone)$\ProseOrAbnormal;
  \item $\rmrecord$ is a pair consisting of the native record $\rvrecord$ and
  the execution graph $\vgone$;
  \item setting the field $\fieldname$ in the native record $\rvrecord$ to $\vv$
  is the updated native record $\vvone$;
  \item $\vmone$ is the pair consisting of the native vector $\vvone$ and the
  execution graph that is, the parallel composition of $\vg$ and $\vgone$;
  \item the steps so far computed the updated record, but have not assigned it to
  the variable holding the record given by $\record$, which is achieved next.
  Evaluating the left-hand-side expression $\rerecord$ in an environment $\envone$ with $\vmone$
  is the output configuration $C$.
\end{itemize}

\FormallyParagraph
\begin{mathpar}
\inferrule{
    \evalexpr{\env, \torexpr(\rerecord)} \evalarrow \Normal(\rmrecord, \envone) \OrAbnormal\\
    \rmrecord \eqname (\rvrecord, \vgone)\\
    \setfield(\fieldname, \vv, \rvrecord) \evalarrow \vvone\\
    \vmone \eqdef (\vvone, \vg \parallelcomp \vgone)\\
    \evallexpr{\env1, \rerecord, \vmone} \evalarrow C
}{
    \evallexpr{\env, \LESetField(\rerecord, \fieldname), (\vv, \vg)} \evalarrow C
}
\end{mathpar}
\CodeSubsection{\EvalLESetFieldBegin}{\EvalLESetFieldEnd}{../Interpreter.ml}

\subsubsection{Comments}
We note that the typechecker guarantees that $\fieldname$ exists in the record given by $\record$
via \TypingRuleRef{LESetStructuredField}.

\identr{WHRS}
If the declared type of the \rhsexpression\ of a setter has the structure of a
bitvector or a type with fields, then if a bitslice or field selection is
applied to a setter invocation, then the assignment to that bitslice is
implemented using the following Read-Modify-Write (RMW) behavior:
\begin{itemize}
    \item invoking the getter of the same name as the setter, with the same actual
    arguments as the setter invocation
    \item performing the assignment to the bitslice or field of the result of the
    getter invocation
    \item invoking the setter to assign the resulting value
\end{itemize}
